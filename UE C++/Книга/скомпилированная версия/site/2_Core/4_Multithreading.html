
<!doctype html>
<html lang="ru" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Справочник Unreal Engine">
      
      
        <meta name="author" content="aftamat4ik">
      
      
      
        <link rel="prev" href="3_SubObjects.html">
      
      
        <link rel="next" href="5_Function_Libraries.html">
      
      
      <link rel="icon" href="../assets/icon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.3.2">
    
    
      
        <title>Многопоточность - Справочник Unreal Engine</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.30068a00.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.85d0ee34.min.css">
      
      


    
    
      
        <script src="https://unpkg.com/iframe-worker/shim"></script>
      
    
    
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Перейти к содержанию
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Верхний колонтитул">
    <a href="../index.html" title="Справочник Unreal Engine" class="md-header__button md-logo" aria-label="Справочник Unreal Engine" data-md-component="logo">
      
  <img src="../assets/icon.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Справочник Unreal Engine
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Многопоточность
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Поиск" placeholder="Поиск" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Поиск">
        
        <button type="reset" class="md-search__icon md-icon" title="Очистить" aria-label="Очистить" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Инициализация поиска
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Вкладки" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../index.html" class="md-tabs__link">
        
  
    
  
  Главная

      </a>
    </li>
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../1_Basics/1_First_Project.html" class="md-tabs__link">
          
  
  Основы

        </a>
      </li>
    
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="1_Delegates.html" class="md-tabs__link">
          
  
  Ключевые системы

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../3_Advanced/1_HUD.html" class="md-tabs__link">
          
  
  Продвинутая разработка

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../4_Resolving%20Issues/LiveCoding_Encoding_Issues.html" class="md-tabs__link">
          
  
  Решение проблем

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../5_Tips/Change_Asset_Icons.html" class="md-tabs__link">
          
  
  Советы

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Навигация" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="Справочник Unreal Engine" class="md-nav__button md-logo" aria-label="Справочник Unreal Engine" data-md-component="logo">
      
  <img src="../assets/icon.png" alt="logo">

    </a>
    Справочник Unreal Engine
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Главная
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Основы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Основы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/1_First_Project.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Создаем первый проект в Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/2_Engine_Introduction.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Знакомство с движком
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/3_CPP_Recommendations.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Рекомендации по написанию кода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/4_SimplePlugin.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Создание простейшего плагина для Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/5_Macroses_Reflection_System.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Макросы Reflection System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/6_Logging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Печать информации в лог
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/7_Pointers.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Указатели
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/8_ModernCpp.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Возможности современного c++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/9_Working_With_Strings.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа со строками
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/10_Timers_In_%D0%A1%2B%2B.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Таймеры
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/11_Instances_Access.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Доступ к различным сущностям
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_12" >
        
          <label class="md-nav__link" for="__nav_2_12" id="__nav_2_12_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Debug
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_12">
            <span class="md-nav__icon md-icon"></span>
            Debug
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/Debug/Debug_Asserts.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Asserts
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../1_Basics/Debug/Debug_Console_Commands.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Console Commands
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Ключевые системы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Ключевые системы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="1_Delegates.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    События и Делегаты
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="2_Components.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Компоненты в Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="3_SubObjects.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Суб Объекты
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Многопоточность
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="4_Multithreading.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Многопоточность
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Содержание">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Содержание
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Подготовка к работе
  </a>
  
    <nav class="md-nav" aria-label="Подготовка к работе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Создаем модуль
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Создаем компонент
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Зависимости
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Добавляем компонент к персонажу
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Генерация простых чисел
  </a>
  
    <nav class="md-nav" aria-label="Генерация простых чисел">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    Измерение времени работы кода
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    Итоговый код
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#asynctask" class="md-nav__link">
    AsyncTask
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#asyncthread" class="md-nav__link">
    AsyncThread
  </a>
  
    <nav class="md-nav" aria-label="AsyncThread">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stacksize" class="md-nav__link">
    StackSize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threadprioirty" class="md-nav__link">
    ThreadPrioirty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#completioncallback" class="md-nav__link">
    CompletionCallback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asyncthread_1" class="md-nav__link">
    Получение результата вычислений из AsyncThread
  </a>
  
    <nav class="md-nav" aria-label="Получение результата вычислений из AsyncThread">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#then" class="md-nav__link">
    .Then()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next" class="md-nav__link">
    .Next()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#asyncpool" class="md-nav__link">
    AsyncPool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#async" class="md-nav__link">
    Async
  </a>
  
    <nav class="md-nav" aria-label="Async">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#async_1" class="md-nav__link">
    Получение результатов вычислений из Async
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadsafe-code" class="md-nav__link">
    Безопасность данных при работе с потоками (Threadsafe code)
  </a>
  
    <nav class="md-nav" aria-label="Безопасность данных при работе с потоками (Threadsafe code)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    Блокировка потоков: Мутексы
  </a>
  
    <nav class="md-nav" aria-label="Блокировка потоков: Мутексы">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lock-unlock" class="md-nav__link">
    Lock - Unlock
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fscopelock" class="md-nav__link">
    FScopeLock
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    Применение мутексов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutable" class="md-nav__link">
    mutable в Мутексах
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lockfree-threadsafety" class="md-nav__link">
    Неблокирующая потокобезопасность (lockfree threadsafety)
  </a>
  
    <nav class="md-nav" aria-label="Неблокирующая потокобезопасность (lockfree threadsafety)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#atomic" class="md-nav__link">
    Шаблон Atomic
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    Умные указатели и потокобезопасность
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tlockfreepointerlist" class="md-nav__link">
    TLockFreePointerList
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#taskgraph" class="md-nav__link">
    TaskGraph
  </a>
  
    <nav class="md-nav" aria-label="TaskGraph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#taskgraph_1" class="md-nav__link">
    Создание задач для TaskGraph
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructandhold" class="md-nav__link">
    ConstructAndHold
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-graphtask" class="md-nav__link">
    Вложенный класс - как GraphTask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ffunctiongraphtask" class="md-nav__link">
    Запуск функции в FFunctionGraphTask
  </a>
  
    <nav class="md-nav" aria-label="Запуск функции в FFunctionGraphTask">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mycompletiongraphevent" class="md-nav__link">
    Событие завершения задачи MyCompletionGraphEvent
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fdelegategraphtask-fsimpledelegategraphtask" class="md-nav__link">
    Запуск асинхронных событий в FDelegateGraphTask и FSimpleDelegateGraphTask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    Управление задачами в графе
  </a>
  
    <nav class="md-nav" aria-label="Управление задачами в графе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fnullgraphtask" class="md-nav__link">
    FNullGraphTask
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tfuture-tpromise" class="md-nav__link">
    TFuture - TPromise
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    Собственные функции для запуска задач в графе
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    Пул потоков
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    Создание пула потоков
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-asynctasks" class="md-nav__link">
    Асинхронные задачи в пуле потоков -AsyncTask's
  </a>
  
    <nav class="md-nav" aria-label="Асинхронные задачи в пуле потоков -AsyncTask's">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    Подготовка к работе
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iqueuedwork" class="md-nav__link">
    Интерфейс IQueuedWork
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fnonabandonabletask" class="md-nav__link">
    FNonAbandonableTask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fautodeleteasynctask" class="md-nav__link">
    Автоматически удаляемые задачи FAutoDeleteAsyncTask
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#runnable-threads" class="md-nav__link">
    Runnable Threads
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parallelfor" class="md-nav__link">
    ParallelFor
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#links" class="md-nav__link">
    Links
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="5_Function_Libraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Библиотеки Функций для Blueprint
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="6_Latent_And_Async_Actions.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Latent и Async Action
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="7_Gameplay_Tags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gameplay Tags
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="8_DataAssets_AssetManager.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа с ассетами и данными
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="9_FileSystem.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа с файловой системой
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="10_Anim_Instance.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Anim Instance
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="11_SubSystems.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Подсистемы
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="12.%20UObject%20Interface.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UObject Interface или UInterface
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Продвинутая разработка
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Продвинутая разработка
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/1_HUD.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HUD или Heads-up Display
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/2_UFUNCTION_Wildcard.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UFUNCTION Wildcard
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/3_Slate%20Runtime.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Slate Runtimе, введение в Slate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/4_UMG.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UMG
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/5_K2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    K2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/6_Registe_New_Asset_Type.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Регистрируем новый тип ассета
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/7_ACharacter_And_Enhanced%20Input.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ACharacter и Enhanced Input
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/8_Gameplay_Ability_System.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gameplay Ability System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/9_Global_Data_Access.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глобальнный доступ к данным
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/10_Global_Event_Bus.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глобальная шина событий
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Решение проблем
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Решение проблем
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/LiveCoding_Encoding_Issues.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Проблемы с кодировкой в LiveCoding
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/Reset_Project.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Сброс (Reset) проекта
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/generatedh_Problems.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Проблемы с файлом .generated.h
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Советы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Советы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Change_Asset_Icons.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Change Asset Icons
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Character_And_EnhancedInput.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Character Boilerplate with Enhanced Input Setup
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/DefaultToSelf_WorldContext.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DefaultToSelf WorldContext
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Different_UPROPERTY.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Переменные разных типов
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/GameInputMode.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Изменение GameInputMode
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Get_UScriptStruct_FromStruct.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ::UScriptStruct из встроенной структуры
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Input_Binding.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    События ввода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Iterate_TMap.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Iterate TMap
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Read_Blueprint_Properties.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Чтение параметров Blueprint класса
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Return_UObject.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Возвращение UObject по ссылке из функции
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Run_Console_Commands.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Запуск консольных команд
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Screen_Size.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Размер экрана
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Slate_Snippets.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Полезные сниппеты Slate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Spawn_Actors.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Spawn, призыв объектов
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Time_Measuring.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Замер времени исполнения кода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Trace.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Trace
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/UEnum_To_String.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UEnum to FString
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/UObject_Base_Class.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UObject Base Class
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Variable_Type_Print_Template.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Шаблон для печати типа переменной
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/struct_operator%3D%3D.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    struct и оператор ==
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Содержание">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Содержание
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Подготовка к работе
  </a>
  
    <nav class="md-nav" aria-label="Подготовка к работе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Создаем модуль
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Создаем компонент
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Зависимости
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Добавляем компонент к персонажу
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Генерация простых чисел
  </a>
  
    <nav class="md-nav" aria-label="Генерация простых чисел">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    Измерение времени работы кода
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    Итоговый код
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#asynctask" class="md-nav__link">
    AsyncTask
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#asyncthread" class="md-nav__link">
    AsyncThread
  </a>
  
    <nav class="md-nav" aria-label="AsyncThread">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stacksize" class="md-nav__link">
    StackSize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threadprioirty" class="md-nav__link">
    ThreadPrioirty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#completioncallback" class="md-nav__link">
    CompletionCallback
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asyncthread_1" class="md-nav__link">
    Получение результата вычислений из AsyncThread
  </a>
  
    <nav class="md-nav" aria-label="Получение результата вычислений из AsyncThread">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#then" class="md-nav__link">
    .Then()
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#next" class="md-nav__link">
    .Next()
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#asyncpool" class="md-nav__link">
    AsyncPool
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#async" class="md-nav__link">
    Async
  </a>
  
    <nav class="md-nav" aria-label="Async">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#async_1" class="md-nav__link">
    Получение результатов вычислений из Async
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#threadsafe-code" class="md-nav__link">
    Безопасность данных при работе с потоками (Threadsafe code)
  </a>
  
    <nav class="md-nav" aria-label="Безопасность данных при работе с потоками (Threadsafe code)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    Блокировка потоков: Мутексы
  </a>
  
    <nav class="md-nav" aria-label="Блокировка потоков: Мутексы">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lock-unlock" class="md-nav__link">
    Lock - Unlock
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fscopelock" class="md-nav__link">
    FScopeLock
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    Применение мутексов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutable" class="md-nav__link">
    mutable в Мутексах
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lockfree-threadsafety" class="md-nav__link">
    Неблокирующая потокобезопасность (lockfree threadsafety)
  </a>
  
    <nav class="md-nav" aria-label="Неблокирующая потокобезопасность (lockfree threadsafety)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#atomic" class="md-nav__link">
    Шаблон Atomic
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    Умные указатели и потокобезопасность
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tlockfreepointerlist" class="md-nav__link">
    TLockFreePointerList
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#taskgraph" class="md-nav__link">
    TaskGraph
  </a>
  
    <nav class="md-nav" aria-label="TaskGraph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#taskgraph_1" class="md-nav__link">
    Создание задач для TaskGraph
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constructandhold" class="md-nav__link">
    ConstructAndHold
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-graphtask" class="md-nav__link">
    Вложенный класс - как GraphTask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ffunctiongraphtask" class="md-nav__link">
    Запуск функции в FFunctionGraphTask
  </a>
  
    <nav class="md-nav" aria-label="Запуск функции в FFunctionGraphTask">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mycompletiongraphevent" class="md-nav__link">
    Событие завершения задачи MyCompletionGraphEvent
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fdelegategraphtask-fsimpledelegategraphtask" class="md-nav__link">
    Запуск асинхронных событий в FDelegateGraphTask и FSimpleDelegateGraphTask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    Управление задачами в графе
  </a>
  
    <nav class="md-nav" aria-label="Управление задачами в графе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#fnullgraphtask" class="md-nav__link">
    FNullGraphTask
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tfuture-tpromise" class="md-nav__link">
    TFuture - TPromise
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    Собственные функции для запуска задач в графе
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    Пул потоков
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    Создание пула потоков
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-asynctasks" class="md-nav__link">
    Асинхронные задачи в пуле потоков -AsyncTask's
  </a>
  
    <nav class="md-nav" aria-label="Асинхронные задачи в пуле потоков -AsyncTask's">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    Подготовка к работе
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iqueuedwork" class="md-nav__link">
    Интерфейс IQueuedWork
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fnonabandonabletask" class="md-nav__link">
    FNonAbandonableTask
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fautodeleteasynctask" class="md-nav__link">
    Автоматически удаляемые задачи FAutoDeleteAsyncTask
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#runnable-threads" class="md-nav__link">
    Runnable Threads
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#parallelfor" class="md-nav__link">
    ParallelFor
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#links" class="md-nav__link">
    Links
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">Многопоточность</h1>
<p>В движке Unreal представлен весьма гибкий функционал для реализации многопоточности. Это одна из важнейших возможностей движка, применять которую придется очень часто, как для реализации фоновых задач (например для анализа видимости окружающих врагов), так и для реализации локальных, но очень тяжелых вычислений.</p>
<h2 id="_2">Подготовка к работе</h2>
<p>Весь код этой главы, как и в прошлый раз, будем писать внутри <code>ActorComponent'а</code>. Который разместим в отдельном модуле.</p>
<h3 id="_3">Создаем модуль</h3>
<p>Назовем модуль - <code>ThreadsModule</code>.</p>
<p><a class="glightbox" href="../images/a57ce2d4234d4069aaa8639453458f6d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a57ce2d4234d4069aaa8639453458f6d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a57ce2d4234d4069aaa8639453458f6d.png" /></a></p>
<h3 id="_4">Создаем компонент</h3>
<p>Компонент назовем - <code>ThreadsComponent</code>.</p>
<p><a class="glightbox" href="../images/cd1139e9e47071f18b167eccbf841426.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="cd1139e9e47071f18b167eccbf841426.png" auto_="auto;" display="block;" margin:="margin:" src="../images/cd1139e9e47071f18b167eccbf841426.png" /></a></p>
<h3 id="_5">Зависимости</h3>
<p>Никаких особых зависимостей для нашей работы не потребуется. Тем не менее я привожу содержимое файла <code>ThreadsModule.build.cs</code>, на всякий случай.
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">UnrealBuildTool</span><span class="p">;</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ThreadsModule</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ModuleRules</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">ThreadsModule</span><span class="p">(</span><span class="n">ReadOnlyTargetRules</span><span class="w"> </span><span class="n">Target</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">base</span><span class="p">(</span><span class="n">Target</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">IncludeOrderVersion</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EngineIncludeOrderVersion</span><span class="p">.</span><span class="n">Latest</span><span class="p">;</span>
<span class="w">        </span><span class="n">PCHUsage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PCHUsageMode</span><span class="p">.</span><span class="n">UseExplicitOrSharedPCHs</span><span class="p">;</span>
<span class="w">        </span><span class="n">PublicDependencyModuleNames</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s">&quot;Core&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CoreUObject&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Engine&quot;</span><span class="p">});</span>
<span class="w">        </span><span class="n">PublicIncludePaths</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;ThreadsModule/Public&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ThreadsModule/Public/Tasks&quot;</span><span class="p">});</span>
<span class="w">        </span><span class="n">PrivateIncludePaths</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;ThreadsModule/Private&quot;</span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="_6">Добавляем компонент к персонажу</h3>
<p>После компиляции кода, добавьте полученный компонент к <code>BP_ThirdPersonCharacter</code>.</p>
<p><a class="glightbox" href="../images/6a31b2f53998de552fbe4e89be857364.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6a31b2f53998de552fbe4e89be857364.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6a31b2f53998de552fbe4e89be857364.png" /></a></p>
<h3 id="_7">Генерация простых чисел</h3>
<p>Я решил использовать алгоритм генерации простых чисел <code>primary number</code>, для тестирования многопоточности. Этот алгоритм часто используется для замеров производительности языка программирования. Главная фишка алгоритма в том, что чем более крупное число мы тестируем - тем больше итераций  проверки требуется сделать. И чем дальше способен пройти алгоритм за заданное время, тем более производительным является язык программирования. Но мы не будем использовать этот алгоритм "в длину". Мы используем генерацию фиксированного количества простых чисел для того, чтобы просто нагрузить систему.</p>
<p>Определение:</p>
<blockquote>
<p>Простое число - натуральное число, имеющее ровно два различных натуральных делителя. Само себя и <code>1</code>. Самое маленькое простое число это <code>2</code>.
Собственно, вычисление простого числа сводится к проверке внутри цикла, делится ли это число на что-либо кроме <code>1</code> и самого себя.</p>
</blockquote>
<p><a class="glightbox" href="../images/7882f3a22284b763802af3d1a0c064f1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7882f3a22284b763802af3d1a0c064f1.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7882f3a22284b763802af3d1a0c064f1.png" /></a></p>
<p>Я буду генерировать простые числа до тех пор, пока не будет сгенерировано, например, <code>10 000</code> простых чисел.
<div class="highlight"><pre><span></span><code><span class="c1">// Lambda checker for prime number</span>
<span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IsPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">Num</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// since 0 and 1 is not prime return false.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Run a loop from 2 to n-1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// if the number is divisible by i, then n is not a</span>
<span class="w">        </span><span class="c1">// prime number.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// otherwise, n is prime number.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// Generate prime numbers until their amount less than 10000</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">CurrentTestNumber</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">CurrentTestNumber</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PrimesFound</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Такие вычисления, в два цикла, сильно нагружают систему. Что и требуется, для тестирования  многопоточности.</p>
<h4 id="_8">Измерение времени работы кода</h4>
<p>Так-же, давайте добавим измерение времени работы нашего алгоритма.</p>
<p>Для этого обернем генератор простых чисел в такой код:
<div class="highlight"><pre><span></span><code><span class="c1">// Time Measuring</span>
<span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="c1">// тут вычисление простого числа</span>
<span class="c1">// ...</span>
<span class="c1">// Time Measuring</span>
<span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Code Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
</code></pre></div>
Обернем вычисления в функцию <code>CalculatePrimes</code>.</p>
<h4 id="_9">Итоговый код</h4>
<p>Итоговый код будет таким:
<div class="highlight"><pre><span></span><code><span class="c1">// Calculation of PrimeNumbers</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">UThreadsComponent::CalculatePrimes</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Amount</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Searching For Primes&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="c1">// Lambda checker for prime number</span>
<span class="w">    </span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IsPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">Num</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// since 0 and 1 is not prime return false.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Run a loop from 2 to n-1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// if the number is divisible by i, then n is not a</span>
<span class="w">            </span><span class="c1">// prime number.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// otherwise, n is prime number.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Generate prime numbers until their amount less than 10000</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Amount</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CurrentTestNumber</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">CurrentTestNumber</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PrimesFound</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Primes Found = %i, Number = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">PrimesFound</span><span class="p">,</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Code Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/1fe71192898d7f3aec4a65032ef0ef8c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1fe71192898d7f3aec4a65032ef0ef8c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1fe71192898d7f3aec4a65032ef0ef8c.png" /></a></p>
<p><a class="glightbox" href="../images/c56d33d66114c79f77a7c38e132a3512.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c56d33d66114c79f77a7c38e132a3512.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c56d33d66114c79f77a7c38e132a3512.png" /></a></p>
<p>Чтобы проверить как все работает - можете добавить функцию в <code>BeginPlay</code> и запустить игру.</p>
<p><a class="glightbox" href="../images/b8922f58bc83719f3b2e5f26a67f7312.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b8922f58bc83719f3b2e5f26a67f7312.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b8922f58bc83719f3b2e5f26a67f7312.png" /></a></p>
<p>Если компонент уже добавлен к классу персонажа, то при запуске игры произойдет весьма заметный лаг, в течении которого движок будет вычислять простые числа.</p>
<p><a class="glightbox" href="../images/468749225f99fe9068830b0fc5963232.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="468749225f99fe9068830b0fc5963232.png" auto_="auto;" display="block;" margin:="margin:" src="../images/468749225f99fe9068830b0fc5963232.png" /></a></p>
<p>Как вы видите, поиск 10 000 простых чисел на с++  занимает 2.133 секунды.</p>
<p>Давайте так-же напишем алгорим вычисления простых чисел в <code>blueprint</code>.</p>
<p><a class="glightbox" href="../images/e97e95f57dcc1baa2b20542fc8824ecf.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e97e95f57dcc1baa2b20542fc8824ecf.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e97e95f57dcc1baa2b20542fc8824ecf.png" /></a></p>
<p><a class="glightbox" href="../images/c91a88751e88fad9d1cdf3b72ed7a8b8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c91a88751e88fad9d1cdf3b72ed7a8b8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c91a88751e88fad9d1cdf3b72ed7a8b8.png" /></a></p>
<p><a class="glightbox" href="../images/6d54b812e68bf6dcecb535617e0302fa.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6d54b812e68bf6dcecb535617e0302fa.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6d54b812e68bf6dcecb535617e0302fa.png" /></a></p>
<p>Важно помнить, что при попытке запустить <code>blueprint</code> на  поиск 10 000 простых чисел - как движок крашнется. Максимально большое число для теста рекомендую брать в районе 200.</p>
<p><a class="glightbox" href="../images/0e28cfe264b9a44ef3af69085b3d3298.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0e28cfe264b9a44ef3af69085b3d3298.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0e28cfe264b9a44ef3af69085b3d3298.png" /></a></p>
<p><a class="glightbox" href="../images/69aecc2ee95eb6f6b3bb52db1c015855.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="69aecc2ee95eb6f6b3bb52db1c015855.png" auto_="auto;" display="block;" margin:="margin:" src="../images/69aecc2ee95eb6f6b3bb52db1c015855.png" /></a></p>
<p>Производительность <code>blueprint</code> кода сильно хуже, чем производительность с++ кода.</p>
<p>В с++ вычисление 250 простых чисел происходит почти мгновенно - за <code>0.000877</code> секунды.</p>
<p><a class="glightbox" href="../images/f1de739cbff31b6a50a2609b845d12e5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f1de739cbff31b6a50a2609b845d12e5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f1de739cbff31b6a50a2609b845d12e5.png" /></a></p>
<p>Если провести простейшую операцию - <code>0.577 / 0.000877</code> мы поймем, что <code>blueprint</code> код в <code>657.9</code> раз медленнее, чем с++ код.</p>
<p>Тут стоит отметить, что если запустить проект в упакованной и готовой к релизу версии, то вычисления будут быстрее, потому что <code>blueprint</code> упакуются в байткод и избавятся от дебаг-привязок. Но не ждите что производительность выростет значительно. Полагаю будет с++ все равно будет раз в 200 быстрее. Это та причина, по которой игры, особенно стратегии или рпг - надо писать на<code>c++</code> хотите вы этого или нет.</p>
<p>Основные асинхронные методы движка находятся в файле <code>#include "Async/Async.h"</code>. Для начала рассмотрим их.</p>
<h2 id="asynctask"><code>AsyncTask</code></h2>
<p>Самое первое, что вам удастся найти в интернете по теме многопоточности в <code>Unreal</code>, это, несомненно <code>AsyncTask</code>. И причина тут проста - это самый простой и базовый способ сделать какой-либо код асинхронным.</p>
<p>Если до этого вы работали с <code>с#</code>, то знакомы с классом <code>BackgroundWorker</code>,  <code>AsyncTask</code> является его аналогом.</p>
<p>Функция (или лямбда), переданная <code>AsyncTask</code> будет помещена в очередь на обработку одним из существующих в движке потоков (<code>Task Graph</code>, я рассмотрю эту систему очень подробно в одной из последующих глав).</p>
<p>Используется <code>AsyncTask</code> так:
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// Run CalculatePrimes on any random task graph</span>
<span class="n">AsyncTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/ae38c29dbc01271fdaeece6fbfbc4128.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ae38c29dbc01271fdaeece6fbfbc4128.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ae38c29dbc01271fdaeece6fbfbc4128.png" /></a></p>
<p><a class="glightbox" href="../images/2332f01e0ad9633d044a2084160e918d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2332f01e0ad9633d044a2084160e918d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2332f01e0ad9633d044a2084160e918d.png" /></a></p>
<p>Такой код приведет к асинхронному вызову функции <code>CalculatePrimes</code>.
Для большего понимания картины - обернем <code>AsyncTask</code> в таймер. Чтобы код срабатывал периодически.
<div class="highlight"><pre><span></span><code><span class="c1">// Timer to sequentally call long calculations</span>
<span class="n">GetWorld</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetTimerManager</span><span class="p">().</span><span class="n">SetTimer</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">FTimerHandle</span><span class="p">()),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Run CalculatePrimes on any random thread</span>
<span class="w">    </span><span class="n">AsyncTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">},</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/93fc7890431a32856042b04b21c7c47f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="93fc7890431a32856042b04b21c7c47f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/93fc7890431a32856042b04b21c7c47f.png" /></a></p>
<p>При этом вычисления не вызывают никаких лагов на основном потоке игры. Но это лишь потому, что в качестве графа для исполнения потока у нас выбран <code>ENamedThreads::AnyThread</code>.
Достаточно заменить <code>ENamedThreads::AnyThread</code> на <code>ENamedThreads::GameThread</code>, чтобы увидеть лаги.
<div class="highlight"><pre><span></span><code><span class="c1">// Run CalculatePrimes on any random thread</span>
<span class="n">AsyncTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">GameThread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
Поскольку метод <code>AsyncTask</code> просто помещает указатель на функцию или лямбду в очередь указанного графа потоков, а мы выбрали в качестве потока <code>GameThread</code>, именно там и возникнет задержка.</p>
<p>С какими графами мы можем работать через <code>AsyncTask</code>?
Список можно найти в файле <code>Runtime\Core\Public\Async\TaskGraphInterfaces.h</code> и он довольно длинный.</p>
<p><a class="glightbox" href="../images/ddd00f6a55913d55c4a1d25518c77a2b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ddd00f6a55913d55c4a1d25518c77a2b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ddd00f6a55913d55c4a1d25518c77a2b.png" /></a></p>
<p>Минусы использования <code>AsyncTask</code> очевидны:
- Выбранный граф потоков всегда блокируется вашими вычислениями. При небольшом объеме вычислений проблем это не создает. Но если требуется посчитать какую-то очень сложную и долгую логику, выбор <code>AsyncTask</code> с модификатором <code>AnyThread</code> - плохая идея. Поведение кода при длительных вычислениях на любом из графов может быть непредсказуемым.
- Невозможно узнать (без мутексов, о них далее) завершил поток свою работу или нет, из-за чего, при сколь-либо сложной логике, возникают проблемы. Это решаемо, вы можете использовать <code>TFuture</code> - <code>TPromise</code>, в одной из следующих глав я рассматриваю подобный подход.</p>
<p>Так почему-же, при таких ограничениях, <code>AsycTask</code> используют? Потому что блокировка потока иногда полезна. Например, вы можете разместить несколько <code>AsyncTask</code> подряд в один и тот-же граф потоков, чтобы они выполнились последовательно.</p>
<p>Так-же, из метода <code>AsycTask</code> очень удобно создавать другие потоки и отслеживать их состояния.</p>
<h2 id="asyncthread"><code>AsyncThread</code></h2>
<p>Эта функция является оберткой над <code>FRunnableThread</code> и создает поток, с указанным приоритетом и размером стека.</p>
<p>Самый примитивный вызов данной функции выглядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// ...</span>
<span class="c1">// .cpp</span>
<span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/d9b1108b7f8e3cce3d31b81348fdddaa.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="d9b1108b7f8e3cce3d31b81348fdddaa.png" auto_="auto;" display="block;" margin:="margin:" src="../images/d9b1108b7f8e3cce3d31b81348fdddaa.png" /></a></p>
<p>У <code>Async Thread</code> имеется ряд аргументов: <code>StackSize</code>, <code>ThreadPrioirty</code> и <code>CompletionCallback</code>.</p>
<h3 id="stacksize">StackSize</h3>
<p><code>StackSize</code> отвечает за размер стека указателей и  переменных, который будет доступен в создаваемом потоке. 0 - значение по умолчанию, указывается байтах <code>bytes</code>.
Зачем эта переменная нужна? Если вы внутри потока создаете очень сложную логику, например, работы окна или какой-либо системы, то размер стека должен быть увеличен, чтобы его хватило для всех созданных переменных. Тут важно заметить - от размера стека указателей не зависит размер данных, на которые они ссылаются. От размера стека зависит лишь количество указателей, которые в этот стек можно засунуть. В разных ОС размер стека разный.</p>
<p>По умолчанию он задается функцией <code>GetDefaultStackSize()</code>.</p>
<p><a class="glightbox" href="../images/42175ac465ac58844ce70180bc25a51c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="42175ac465ac58844ce70180bc25a51c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/42175ac465ac58844ce70180bc25a51c.png" /></a></p>
<p>В Windows все потоки имеют размер 1МБ, которого более чем достаточно для большого количества переменных и указателей внутри потока.</p>
<p>У меня в потоке вызывается лишь одна функция, поэтому стека по умолчанию вполне хватает - использую <code>0.0f</code>.</p>
<h3 id="threadprioirty">ThreadPrioirty</h3>
<p><code>ThreadPrioirty</code> - очевидный приоритет потока. Intellisense автоматически выведет вам список доступных опций, если напечатать <code>PTri</code>.</p>
<p><a class="glightbox" href="../images/45fa581cb7dd9fefceb47d718d2b5bf6.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="45fa581cb7dd9fefceb47d718d2b5bf6.png" auto_="auto;" display="block;" margin:="margin:" src="../images/45fa581cb7dd9fefceb47d718d2b5bf6.png" /></a></p>
<p>Полный же список опций находится тут - <code>/Runtime/Core/Public/GenericPlatform/GenericPlatformAffinity.h</code>.
Я использую <code>TPri_Normal</code>, но есть и более интересные варианты: <code>TPri_TimeCritical</code>, <code>TPri_Highest</code>, <code>TPri_Lowest</code>.</p>
<p><a class="glightbox" href="../images/1056b1ad896d9f12de111bbbaa461756.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1056b1ad896d9f12de111bbbaa461756.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1056b1ad896d9f12de111bbbaa461756.png" /></a></p>
<h3 id="completioncallback">CompletionCallback</h3>
<p><code>CompletionCallback</code> - параметр, позволяющий вызвать лямбду, по завершении вычислений.
<div class="highlight"><pre><span></span><code><span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">,</span>
<span class="p">[]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Calculations Completed&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;------------&quot;</span><span class="p">))</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/1c203fc044c712a8828a1c11d57613e0.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1c203fc044c712a8828a1c11d57613e0.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1c203fc044c712a8828a1c11d57613e0.png" /></a></p>
<p>К сожалению, в параметре <code>CompletionCallback</code> нельзя получить возвращаемое из потока значение. Однако есть более гибкий способ.</p>
<h3 id="asyncthread_1">Получение результата вычислений из <code>AsyncThread</code></h3>
<p>Функция <code>AsyncThread</code> возвращает объект типа <code>TFuture</code>. Этот объект ждет, пока поток передаст ему значение, а затем пересылает его функции-обработчику.</p>
<h4 id="then"><code>.Then()</code></h4>
<p>Обратиться к <code>TFuture</code> можно сразу после вызова функции, например через привязку метода <code>Then</code> к лямбде:
<div class="highlight"><pre><span></span><code><span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">)</span>
<span class="p">.</span><span class="n">Then</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Make Sure it&#39;s valid</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Future</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Future</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b22246239159c7c2adfef042bf959928.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b22246239159c7c2adfef042bf959928.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b22246239159c7c2adfef042bf959928.png" /></a></p>
<p>Метод <code>Then</code> передает всего один аргумент - сам объект <code>TFuture</code>. При этом данный метод срабатывает всегда, даже тогда, когда поток ничего не возвратил или завершился с ошибкой. Поэтому важно проводить проверку, внутри метода, на валидность объекта <code>if (Future.IsValid())</code>.</p>
<h4 id="next"><code>.Next()</code></h4>
<p>Есть альтернативный способ привязки  - метод <code>Next</code>, который является безопасной оберткой над <code>Then</code>:
<div class="highlight"><pre><span></span><code><span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">)</span>
<span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div>
Данный метод срабатывает лишь когда поток возвращает валидное значение. Если поток прервется или завершится с ошибкой - метод <code>Next</code> вызван не будет.</p>
<p><a class="glightbox" href="../images/b18988c526a745dd46cd257428a73456.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b18988c526a745dd46cd257428a73456.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b18988c526a745dd46cd257428a73456.png" /></a></p>
<p>Вместо прямой привязки можно так-же использовать переменную.
<div class="highlight"><pre><span></span><code><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">);</span>
<span class="n">Result</span><span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div>
Тут я вынес <code>TFuture</code> в переменную и присоединил к ней метод <code>Next</code>.
Обратите внимание, что привязать обработчики одновременно к <code>Next</code> и <code>Then</code> нельзя.</p>
<p>То есть такой код работать не будет:
<div class="highlight"><pre><span></span><code><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">);</span>
<span class="n">Result</span><span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span>
<span class="p">});</span>
<span class="n">Result</span><span class="p">.</span><span class="n">Then</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Make Sure it&#39;s valid</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Future</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Future</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
При попытке запустить такой код движок крашнется, после чего выдаст ошибку: <code>UnrealEditor-ThreadsModule.patch_0.exe!TFutureBase&lt;int&gt;::Then</code>.
Только одна функция-обработчик может быть присоединена к <code>TFuture</code>: или <code>Then</code> или <code>Next</code>.
<div class="highlight"><pre><span></span><code><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AsyncThread</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">0.f</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">);</span>
<span class="cm">/*Result.Next([&amp;](int Number)-&gt;void {</span>
<span class="cm">    UE_LOG(LogTemp, Warning, TEXT(&quot;Result calculated in thread is %i&quot;), Number)</span>
<span class="cm">});*/</span>
<span class="n">Result</span><span class="p">.</span><span class="n">Then</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Make Sure it&#39;s valid</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Future</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Future</span><span class="p">.</span><span class="n">Get</span><span class="p">())</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
Вы можете найти в этой статье, чуть ниже, главу, посвященную более тесной работе с  <code>TFuture - TPromise</code>. Там я рассмотрел способ самостоятельного использования этих объектов, для получения данных из потока.</p>
<h2 id="asyncpool"><code>AsyncPool</code></h2>
<p>Данный метод позволяет добавить новую задачу в один из существующих пулов потоков. Пул потоков (не путать с графом потоков) вы можете создать как сами (это я рассмотрю ниже), так и использовать один из тех пулов, что существуют в движке по умолчанию и доступны глобально. Например - <code>GThreadPool</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Add lambda to given global thread pool</span>
<span class="n">AsyncPool</span><span class="p">(</span><span class="o">*</span><span class="n">GThreadPool</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">},</span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">EQueuedWorkPriority</span><span class="o">::</span><span class="n">Normal</span><span class="p">)</span>
<span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div>
Как вы видите <code>AsyncPool</code> так-же позволяет получать значение через <code>TFuture</code>.</p>
<h2 id="async"><code>Async</code></h2>
<p>Метод <code>Async</code> является упрощенной комбинацией предыдущих подходов, позволяя запускать переданный код в одной из асинхронных систем на выбор.</p>
<p>Вызывается так:
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// ...</span>
<span class="c1">// .cpp</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">ThreadPool</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
Обратите внимание на параметр <code>EAsyncExecution</code>. Он определяет где будет запущен поток.</p>
<p>Возможные значения:
<code>EAsyncExecution::TaskGraph</code> и <code>EAsyncExecution::TaskGraphMainThread</code> - запускают асинхронный код внутри <code>TGraphTask</code>.
Граф выбирается по следующей логике:
<code>ENamedThreads::AnyThread</code> в случае с <code>EAsyncExecution::TaskGraph</code>
<code>ENamedThreads::GameThread</code> в случае  с<code>EAsyncExecution::TaskGraphMainThread</code>.
<code>TGraphTask</code> не предназначен для объемных и долгих вычислений, а так-же бесконечных циклов.
<code>EAsyncExecution::Thread</code> - запускает поток внутри <code>FRunnableThread</code>. Это полноценный поток, работающий парралельно основным потокам движка.</p>
<p>Созданному через метод <code>Async</code> потоку не получится установить приоритет, поэтому лучше использовать метод <code>AsyncThread</code>, который предоставляет больше контроля.
<code>EAsyncExecution::ThreadIfForkSafe</code> - запускает <code>FRunnableThread</code> только в том случае, если в системе выставлена поддержка многопоточности <code>FPlatformProcess::SupportsMultithreading</code>.
Если такой поддержки нет - поток создан не будет.
<code>EAsyncExecution::ThreadPool</code> - помещает функцию в очередь на обработку к глобальному пулу потоков <code>GThreadPool</code>. Очевидный аналог <code>AsyncPool(*GThreadPool)</code>.
<code>EAsyncExecution::LargeThreadPool</code> - помещает функцию в очередь на обработку к глобальному пулу потоков <code>GLargeThreadPool</code>, если в системе выставлена поддержка многопоточности  - <code>FPlatformProcess::SupportsMultithreading</code>.</p>
<h3 id="async_1">Получение результатов вычислений из <code>Async</code></h3>
<p>Из потока, созданного через функцию <code>Async</code> можно получить результаты вычислений используя объект <code>TFutute</code>. Я уже делал подробный разбор работы с этим объектом, когда описывал <code>AsyncThread</code>.
Приведу короткий пример:
<div class="highlight"><pre><span></span><code><span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">ThreadPool</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="p">})</span>
<span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Number</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/6e0da91d23ccfdd130f8bfccab2bc8f4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6e0da91d23ccfdd130f8bfccab2bc8f4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6e0da91d23ccfdd130f8bfccab2bc8f4.png" /></a></p>
<h2 id="threadsafe-code">Безопасность данных при работе с потоками (Threadsafe code)</h2>
<p>Рассмотрим ситуацию, в которой два потока должны записывать данные в одну и ту-же переменную.</p>
<p>Поскольку потоки работают не по очереди, а парралельно и одновременно - возникает проблема с безопасностью памяти при доступе таких потоков к общим объектам. Суть проблемы сводится к тому, что если одновременно записывать или считывать данные из одного и того-же участка памяти - можно сломать эту самую память или получить там неопределенного вида кашу.</p>
<p>Давайте воплотим проблему потокобезопасности на практике, для большей наглядности.</p>
<p>Создадим переменную, например массив:
<div class="highlight"><pre><span></span><code><span class="c1">// Testing ThreadSave Variable</span>
<span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span>
</code></pre></div>
Теперь нужны два потока. В первом потоке будем добавлять к массиву цифру <code>1</code>, во втором будем добавлять цифру <code>2</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Usafe thread tests</span>
<span class="c1">// Async Thread 1</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// Async Thread 2</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
Ну и напишем код печати массива, а потом поместим все это в циклический таймер.
<div class="highlight"><pre><span></span><code><span class="c1">//.cpp</span>
<span class="c1">// BeginPlay</span>
<span class="c1">// Timer to sequentally call long calculations</span>
<span class="n">GetWorld</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetTimerManager</span><span class="p">().</span><span class="n">SetTimer</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">FTimerHandle</span><span class="p">()),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Usafe thread tests</span>
<span class="w">        </span><span class="c1">// Async Thread 1</span>
<span class="w">        </span><span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">        </span><span class="c1">// Async Thread 2</span>
<span class="w">        </span><span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">        </span><span class="c1">// Print Array</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ArrayItem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[ArrayItem] = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ArrayItem</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">},</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
</code></pre></div>
Если скомпилировать такой код, а потом запустить проект - в какой-то момент в движке возникает сбой и он закрывается, потому что код не потокобезопасен. Переменная <code>ThreadSafeTest</code> вызывается парралельно в двух потоках, что и создает проблему.
<div class="highlight"><pre><span></span><code><span class="n">Unhandled</span><span class="w"> </span><span class="n">Exception</span><span class="o">:</span><span class="w"> </span><span class="n">EXCEPTION_ACCESS_VIOLATION</span><span class="w"> </span><span class="n">writing</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="mh">0x0000000000000004</span>
</code></pre></div>
Ошибка - <code>EXCEPTION_ACCESS_VIOLATION</code> - прямо намекает разработчику, что система не может одновременно из двух потоков записывать в один адрес памяти.</p>
<p>После нескольких попыток я смог заснять фрагмент вывода этого кода до того, как закроется движок.</p>
<p><a class="glightbox" href="../images/792b31fd39de38ec8f4a726bacebdd64.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="792b31fd39de38ec8f4a726bacebdd64.png" auto_="auto;" display="block;" margin:="margin:" src="../images/792b31fd39de38ec8f4a726bacebdd64.png" /></a></p>
<p>Как вы видите, в массиве есть участки с повторяющимися значениями. А так-же значение <code>2576</code>. Оно появилось тут, потому что цикл печати данных из потока - не потокобезопасен и может обращаться к ячейкам памяти, которые в данный момент обрабатываются одним из потоков. Это вызывает появление подобных, непредсказуемых, значений.</p>
<h3 id="_10">Блокировка потоков: Мутексы</h3>
<p>Дабы предотвратить одновременную работу нескольких потоков над одними и теми-же данными, разработчики создали систему т.н. мутексов. Используя мутексы программист  может заблокировать участок памяти, пока над ним работает какой-либо поток. Пока память блокирована - доступ к ней возможен лишь из одного потока, все остальные - ждут в очереди.</p>
<blockquote>
<p>Важно помнить, что злоупотребление мутексами сводит на нет все преимущества от многопоточности. Поэтому блокировать участки памяти надо лишь там, где выполняется чтение или запись в переменные. Сложные вычисления должны быть избавлены от мутексов.</p>
</blockquote>
<p>Мутексы создаются из типа <code>FCriticalSection</code>.
При этом мутекс всегда задается в глобальном пространстве, внутри класса.
<div class="highlight"><pre><span></span><code><span class="k">mutable</span><span class="w"> </span><span class="n">FCriticalSection</span><span class="w"> </span><span class="n">Mutex</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/017e3605c4d2cfee3e191b400e7257e7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="017e3605c4d2cfee3e191b400e7257e7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/017e3605c4d2cfee3e191b400e7257e7.png" /></a></p>
<h4 id="lock-unlock"><code>Lock</code> - <code>Unlock</code></h4>
<p>Мутекс можно использовать двумя способами. Первый - непосредственно из самой переменной вызывать методы <code>.lock()</code> и <code>.unlock()</code>.
Метод <code>.Lock()</code> заблокирует участок памяти, над которым работает поток. Другие потоки не смогут получить доступ к этому участку и будут ждать разблокирования через функцию <code>.Unlock()</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Async Thread 2</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Mutex</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">Mutex</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></p>
<h4 id="fscopelock"><code>FScopeLock</code></h4>
<p>Однако, не всегда получается вызвать <code>.Unlock()</code>, например может быть метод такого вида:
<div class="highlight"><pre><span></span><code><span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetThreadSafeTest</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
В котором используется <code>return</code>. Где здесь можно прописать <code>.Unlock()</code>, ведь такой код работать не будет:
<div class="highlight"><pre><span></span><code><span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetThreadSafeTest</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Mutex</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span><span class="w"> </span><span class="c1">// code will exit here</span>
<span class="w">    </span><span class="n">Mutex</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span><span class="w"> </span><span class="c1">// это не сработает, потому что функция завершит исполнение после return</span>
<span class="p">}</span>
</code></pre></div>
Для таких случаев используется блокирование области действия <code>{}</code>, через <code>FScopeLock ScopeLock{ &amp;Mutex };</code>. Блокировка снимается с данных автоматически, при выходе из области действия, в которой вызван <code>FScopeLock</code>.
Вышеуказанную функцию надо реализовывать вот так:
<div class="highlight"><pre><span></span><code><span class="c1">// ThreadSafeTest variable thread safe getter</span>
<span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetThreadSafeTest</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FScopeLock</span><span class="w"> </span><span class="n">ScopeLock</span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Mutex</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<code>FScopeLock</code> можно разблокировать, при необходимости, таким образом:
<div class="highlight"><pre><span></span><code><span class="n">FScopeLock</span><span class="w"> </span><span class="n">ScopeLock</span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Mutex</span><span class="w"> </span><span class="p">};</span>
<span class="c1">// какие-то вычисления</span>
<span class="n">ScopeLock</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span><span class="w"> </span><span class="c1">// разблокировка</span>
</code></pre></div></p>
<h4 id="_11">Применение мутексов</h4>
<p>Рассмотрим применение мутексов к нашим потокам, записывающим данные в массив.
<div class="highlight"><pre><span></span><code><span class="c1">// Threadsafe tests</span>
<span class="c1">// Async Thread 1</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FScopeLock</span><span class="w"> </span><span class="n">ScopeLock</span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Mutex</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">});</span>
<span class="c1">// Async Thread 2</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Mutex</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
<span class="w">    </span><span class="n">ThreadSafeTest</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">Mutex</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;-------&quot;</span><span class="p">))</span>
<span class="c1">// Print Array</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ArrayItem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FScopeLock</span><span class="w"> </span><span class="n">ScopeLock</span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Mutex</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[ArrayItem] = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ArrayItem</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
Обратите внимание, что в цикле печати массива я тоже использую мутекс. Это делается, потому что операция чтения данных из переменной - не потокобезопасна.</p>
<p>Если этот код скомпилировать, а потом запустить, то мы увидим, что потоки работают с переменной <code>ThreadSafeTest</code> последовательно.</p>
<p><a class="glightbox" href="../images/04a504237231bfefe109d9aae660d2a9.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="04a504237231bfefe109d9aae660d2a9.png" auto_="auto;" display="block;" margin:="margin:" src="../images/04a504237231bfefe109d9aae660d2a9.png" /></a></p>
<h4 id="mutable"><code>mutable</code> в Мутексах</h4>
<p>В вышеуказанном примере я добавил мутексу префикс <code>mutable</code>.
Зачем?
Чтобы использовать мутекс в <code>const</code> функциях.</p>
<p>Рассмотрим пример <code>const</code> функции, которая читает данные переменой <code>ThreadSafeTest</code>.
<div class="highlight"><pre><span></span><code><span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetThreadSafeTest</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Парралельное чтение переменной без применения блокировки - не потокобезопасно. При чтении данных надо использовать мутекс. Однако, если создать мутекс без спецификатора <code>mutable</code>, то возникнет проблема.
<div class="highlight"><pre><span></span><code><span class="c1">// Mutex</span>
<span class="n">FCriticalSection</span><span class="w"> </span><span class="n">Mutex</span><span class="p">;</span>
<span class="c1">// ThreadSafeTest variable getter</span>
<span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetThreadSafeTest</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FScopeLock</span><span class="w"> </span><span class="n">ScopeLock</span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Mutex</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/fe30b951abc4f853b12b7e74cd6bff09.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fe30b951abc4f853b12b7e74cd6bff09.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fe30b951abc4f853b12b7e74cd6bff09.png" /></a></p>
<p>Потому что из <code>const</code> функций нельзя изменять параметры класса. А блокировка мутекса - подразумевает его изменение.</p>
<p>Чтобы изменять некоторые переменные внутри <code>const</code> обходя их ограничения - был придуман префикс <code>mutable</code>. Рекомендуется создавать мутексы с этим префиксом.
<div class="highlight"><pre><span></span><code><span class="c1">// Mutex</span>
<span class="k">mutable</span><span class="w"> </span><span class="n">FCriticalSection</span><span class="w"> </span><span class="n">Mutex</span><span class="p">;</span>
<span class="c1">// ThreadSafeTest variable thread safe getter</span>
<span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">GetThreadSafeTest</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FScopeLock</span><span class="w"> </span><span class="n">ScopeLock</span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Mutex</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ThreadSafeTest</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/8549efb73ff3010db937bc1c57b57b8f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="8549efb73ff3010db937bc1c57b57b8f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/8549efb73ff3010db937bc1c57b57b8f.png" /></a></p>
<h2 id="lockfree-threadsafety">Неблокирующая потокобезопасность (lockfree threadsafety)</h2>
<p>Как я уже писал, частое использование мутексов сводит на нет преимущества от многопоточности. Поэтому давайте рассмотрим альтернативные подходы к работе с данными из нескольких потоков.</p>
<h3 id="atomic">Шаблон Atomic</h3>
<p><code>Atomic</code> операции позволяют работать с данными не используя блокировку потока.
<code>std::atomic</code> - единственный шаблон стандартной библиотеки<code>c++</code> который рекомендован к использованию вместе с Unreal.
Для большинства шаблонов из стандартной библиотеки в Unreal есть свои собственные аналоги (<code>std::function -&gt; TFunction</code>, <code>std::shared_ptr -&gt; TSharedPtr</code> и так далее). Так и для <code>atomic</code> операций есть встроенный тип <code>TAtomic</code>. Однако, в данный момент (2023 год), встроенные типы данного семейства являются <code>Deprecated</code>, а саму систему, вероятно, планируют переделать.</p>
<p><a class="glightbox" href="../images/b8132d37241cb285382f01ce1e1a38d4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b8132d37241cb285382f01ce1e1a38d4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b8132d37241cb285382f01ce1e1a38d4.png" /></a></p>
<p>На что явно намекают всплывающие подсказки, а так-же документация к типу <code>TAtomic</code>.</p>
<p><a class="glightbox" href="../images/04f8e6a4ce18d317fc47e1b6a7122d4b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="04f8e6a4ce18d317fc47e1b6a7122d4b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/04f8e6a4ce18d317fc47e1b6a7122d4b.png" /></a></p>
<p>Вместо <code>TAtomic</code> разработчики рекомендуют использовать стандартный шаблон - <code>std::atomic</code>.
Данный шаблон подключается командой <code>#include &lt;atomic&gt;</code>.
Для получения значения из шаблона используется команда <code>.load()</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// BeginPlay</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ThreadCounter</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span><span class="w"> </span><span class="c1">// Threadsafe counter</span>
<span class="c1">// Parallel Calculations 1</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">Thread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">GraphEvents</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">200</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// add 200 tasks to graph event list</span>
<span class="w">        </span><span class="n">GraphEvents</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FFunctionGraphTask</span><span class="o">::</span><span class="n">CreateAndDispatchWhenReady</span><span class="p">([</span><span class="o">&amp;</span><span class="n">ThreadCounter</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">0.005</span><span class="p">);</span><span class="w"> </span><span class="c1">// delay before incrementing</span>
<span class="w">            </span><span class="n">ThreadCounter</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">FTaskGraphInterface</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">WaitUntilTasksComplete</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">GraphEvents</span><span class="p">),</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">);</span><span class="w"> </span><span class="c1">// run all tasks in parralel</span>
<span class="p">});</span>
<span class="c1">// Parallel Calculations 2</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">Thread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ParallelFor</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">ThreadCounter</span><span class="p">](</span><span class="n">int32</span><span class="w"> </span><span class="n">Index</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">);</span><span class="w"> </span><span class="c1">// delay before incrementing</span>
<span class="w">        </span><span class="n">ThreadCounter</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">});</span>
<span class="c1">// Wait some time and get ThreadCounter in the middle of calculations</span>
<span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">0.03</span><span class="p">);</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;ThreadCounter Atomic Value is %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ThreadCounter</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/33fc8b89284376bf69d7015b04b6cf2d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="33fc8b89284376bf69d7015b04b6cf2d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/33fc8b89284376bf69d7015b04b6cf2d.png" /></a></p>
<p>Обратите внимание: <code>std::atomic</code> не получится использовать с указателями.</p>
<p>Указатель хранит в себе всего-лишь адрес объекта, а не сам объект. Из-за этого доступ к объекту по его адресу, пусть даже и из <code>atomic</code> операции <strong>не будет</strong> потокобезопасным.</p>
<h3 id="_12">Умные указатели и потокобезопасность</h3>
<p>Указатели типа <code>TSharedPtr</code> и <code>TUniquePtr</code> имеют параметр, отвечающий за потокобезопасность - <code>ESPMode::ThreadSafe</code>. Но он отвечает лишь за <strong>чтение</strong> данных из указателя. Не за запись. Это очень важно.</p>
<p>Все мои попытки заставить движок записывать данные в умный указатель - провалились.
<div class="highlight"><pre><span></span><code><span class="n">TSharedPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">ESPMode</span><span class="o">::</span><span class="n">ThreadSafe</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TestSharedPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeShared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">Thread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">TestSharedPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/28a71006a8c997dd999528bef5ad5f80.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="28a71006a8c997dd999528bef5ad5f80.png" auto_="auto;" display="block;" margin:="margin:" src="../images/28a71006a8c997dd999528bef5ad5f80.png" /></a></p>
<p>Виной тому - сама сущность указателей. Ведь они хранят лишь <strong>ардес</strong> памяти и больше ничего. Любая попытка изменить память по этому адресу - неизбежно будет не безопасной.</p>
<p>Аналогичная проблема наблюдается и с <code>std::shared_ptr</code>.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TestSharedPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">);</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">Thread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">*</span><span class="n">TestSharedPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div>
На <code>Stackoverflow</code> есть более детальное <a href="https://stackoverflow.com/a/14485302/2574125">объяснение</a> причины, по которой так происходит.</p>
<p>Таким образом:</p>
<blockquote>
<p>При записи данных по указателю избежать блокировки потока не получится. Придется использовать мутексы.</p>
</blockquote>
<h3 id="tlockfreepointerlist"><code>TLockFreePointerList</code></h3>
<p>Потокобезопасные списки, которые могут применятся для парралельной обработки данных.
<code>TLockFreePointerListFIFO</code> - потокобезопасная очередь.
<code>TLockFreePointerListLIFO</code> - потокобезопасный стек.
<code>TLockFreePointerListUnordered</code> - потокобезопасная куча.</p>
<p>Наш массив <code>TArray&lt;int&gt; ThreadSafeTest</code> запросто может быть заменен на потокобезопасный стек.</p>
<p>Тогда приведенный выше пример будет выглядеть так:
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// Timer executions count</span>
<span class="kt">int</span><span class="w"> </span><span class="n">TimerCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">// ThreadSafe stack test</span>
<span class="n">TLockFreePointerListLIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ThreadSafeStack</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="c1">// .cpp</span>
<span class="c1">// Threadsafe tests</span>
<span class="c1">// Async Thread 1</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">ThreadSafeStack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">});</span>
<span class="c1">// Async Thread 2</span>
<span class="n">Async</span><span class="p">(</span><span class="n">EAsyncExecution</span><span class="o">::</span><span class="n">TaskGraph</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">ThreadSafeStack</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">});</span>
<span class="c1">// since ThreadSafeStack.PopAll will clear stack items, i need to give system some values to write into it before printing</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">TimerCount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;-------&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="c1">// Print Array</span>
<span class="w">    </span><span class="n">TArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">StackItems</span><span class="p">;</span>
<span class="w">    </span><span class="n">ThreadSafeStack</span><span class="p">.</span><span class="n">PopAll</span><span class="p">(</span><span class="n">StackItems</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ArrayItem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">StackItems</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[ArrayItem] = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">ArrayItem</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b903b58c7af454f2a46f64f23bf20a05.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b903b58c7af454f2a46f64f23bf20a05.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b903b58c7af454f2a46f64f23bf20a05.png" /></a></p>
<p>Поскольку <code>TLockFreePointerListLIFO</code> это потокобезопасный тип - он не блокирует пространство при записи данных. Что, в свою очередь, разрешает парралелизм для данной переменной. Именно поэтому в результатах вы можете наблюдать две <code>1, 1</code> идущие подряд.</p>
<h2 id="taskgraph">TaskGraph</h2>
<p>Многопоточность движка <code>Unreal Engine</code> построена вокруг графа потоков. Каждый крупный блок логики движка выполняется на одном из графов, они перечислены в списке <code>ENamedThreads</code>.
Интерфейс <code>TGraphTask</code> позволяет запустить класс, соблюдающий ряд условий, в выбранном <code>TaskGraph</code> движка.</p>
<p>Классы, которые предполагается запускать в <code>TGraphTask</code> называются "классами задач" или тасками (я буду использовать оба термина, дабы избежать тавтологии).
Задачи в <code>TGraphTask</code> могут быть связаны между  собой логически, образуя целые деревья, следящие за выполнением той или иной логики. При этом система распределяет задачи тасков по различным ядрам движка, что позволяет получить серьезный прирост производительности.</p>
<p>Реализация задач для графа должна содержать в себе четыре метода - <code>DoTask</code>, <code>GetStatId</code>, <code>GetDesiredThread</code> и <code>GetSubsequentsMode</code>. При этом класс наследовать ни от чего не надо.</p>
<p>В методе <code>DoTask</code> осуществляется основная логика работы задачи.</p>
<p><a class="glightbox" href="../images/0257b34faeeb303c9b9fea75752400fd.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0257b34faeeb303c9b9fea75752400fd.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0257b34faeeb303c9b9fea75752400fd.png" /></a></p>
<p>Реализация этого метода выглядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// Task calculations should go here</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// из метода DoTask можно создавать новые задачи</span>
<span class="w">    </span><span class="c1">// Так-же новые задачи можно привязывать к MyCompletionGraphEvent, который вызывается по завершению таска</span>
<span class="w">    </span><span class="c1">//MyCompletionGraphEvent-&gt;DontCompleteUntil(TGraphTask&lt;FSomeChildTask&gt;::CreateTask(NULL, CurrentThread).ConstructAndDispatchWhenReady());</span>
<span class="p">}</span>
</code></pre></div>
Метод <code>GetStatId</code> отвечает за идентификацию потока, в большинстве случаев его реализуют следующим образом:
<div class="highlight"><pre><span></span><code><span class="c1">// Object Id</span>
<span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">([</span><span class="n">класс_задачи</span><span class="p">],</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/7abf6eee65182d887630c7cf5819aa3f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7abf6eee65182d887630c7cf5819aa3f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7abf6eee65182d887630c7cf5819aa3f.png" /></a></p>
<p>Метод <code>GetDesiredThread</code> отвечат за поток, в котором будет выполнена задача. Возвращает одно из значений типа <code>ENamedThreads</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Named Thread where our task will be executed</span>
<span class="k">static</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="nf">GetDesiredThread</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Метод <code>GetSubsequentsMode</code> отвечает за механику обработки потоков, которые были созданы из этого потока. Он возвращает одно из значений типа <code>ESubsequentsMode</code>, это:
<code>ESubsequentsMode::TrackSubsequents</code> - данный таск не будет завершен и удален из памяти до тех пор, пока все задачи, которые были в нем созданы, не завершат свою работу.
<code>ESubsequentsMode::FireAndForget</code> - данный таск не следит за задачами, которые были в нем созданы.
<div class="highlight"><pre><span></span><code><span class="c1">// Sub tasks called from this task track mode</span>
<span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="nf">GetSubsequentsMode</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">TrackSubsequents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="taskgraph_1">Создание задач для TaskGraph</h3>
<p>Давайте сделаем свой собственный тип таска (задачи) для графа потоков.</p>
<p>Разработчики оставили пример реализации таска в файле - <code>/Runtime/Core/Public/Async/TaskGraphInterfaces.h</code>.</p>
<p><a class="glightbox" href="../images/e2f24ef692da82b355e6c9c0886a798e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e2f24ef692da82b355e6c9c0886a798e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e2f24ef692da82b355e6c9c0886a798e.png" /></a></p>
<p>Его можно просто скопировать задав соответствующие значения.</p>
<p>Но для начала создадим отдельную категорию файлов под наши таски. Для этого в каталоге модуля, в папке <code>/Public/</code> создайте подпапку <code>/Tasks</code>, а в ней файл - <code>GeneratePrimesTask.h</code>.</p>
<p><a class="glightbox" href="../images/86931a57fbcdd445e545dfabe060b559.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="86931a57fbcdd445e545dfabe060b559.png" auto_="auto;" display="block;" margin:="margin:" src="../images/86931a57fbcdd445e545dfabe060b559.png" /></a></p>
<p>Чтобы файл появился в проекте <code>Visual Studio</code>, из движка вызовите команду <code>Tools -&gt; Refresh Visual Studio 2022 Project</code>.</p>
<p><a class="glightbox" href="../images/f4288dbfdcfe13f3e8441b9c66093ae9.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f4288dbfdcfe13f3e8441b9c66093ae9.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f4288dbfdcfe13f3e8441b9c66093ae9.png" /></a></p>
<p>Теперь поместим в файл код задачи. Я написал его заранее в виде класса <code>FGeneratePrimesTask</code>, который вычисляет простые числа и пишет результаты вычислений в лог.
<div class="highlight"><pre><span></span><code><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CoreMinimal.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Stats/Stats.h&gt;</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// FThreadManager</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HAL/ThreadManager.h&quot;</span>
<span class="cm">/**</span>
<span class="cm">* Task to generate Prime Numbers</span>
<span class="cm">* based on TaskGraphInterfaces.h / FGenericTask (it&#39;s commented section)</span>
<span class="cm">*/</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FGeneratePrimesTask</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Arguments</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">NumsAmount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">OffsetFromNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// For Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">FGeneratePrimesTask</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">InNumsAmount</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">InOffsetFromNum</span><span class="p">)</span><span class="w"> </span><span class="c1">// CAUTION!: Must not use references in the constructor args; use pointers instead if you need by reference</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">NumsAmount</span><span class="p">(</span><span class="n">InNumsAmount</span><span class="p">)</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">OffsetFromNum</span><span class="p">(</span><span class="n">InOffsetFromNum</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Usually the constructor doesn&#39;t do anything except save the arguments for use in DoWork or GetDesiredThread.</span>
<span class="w">        </span><span class="c1">// In my case i&#39;l do time measuring for task</span>
<span class="w">        </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">FGeneratePrimesTask</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Task Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">        </span><span class="n">Log</span><span class="p">(</span><span class="n">__FUNCTION__</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Object Id</span>
<span class="w">    </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FGeneratePrimesTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Named Thread where our task will be executed</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetDesiredThread</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Sub tasks called from this task track mode</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetSubsequentsMode</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">TrackSubsequents</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Task calculations should go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* // Completion event of current task</span>
<span class="cm">        // тут я использую FFunctionGraphTask для привязки его к событию завершения задачи</span>
<span class="cm">        // про FFunctionGraphTask я напишу чуть ниже</span>
<span class="cm">        MyCompletionGraphEvent-&gt;DontCompleteUntil(FFunctionGraphTask::CreateAndDispatchWhenReady([this]() {</span>
<span class="cm">            UE_LOG(LogTemp, Warning, TEXT(&quot;MyCompletionGraphEvent has Been Called!&quot;))</span>
<span class="cm">            // Sleep</span>
<span class="cm">            FPlatformProcess::Sleep(3.1);</span>
<span class="cm">            UE_LOG(LogTemp, Warning, TEXT(&quot;MyCompletionGraphEvent has Been Fnished!&quot;))</span>
<span class="cm">        }, TStatId(), nullptr, ENamedThreads::AnyBackgroundThreadNormalTask));</span>
<span class="cm">        // We can also call another task from here</span>
<span class="cm">        //MyCompletionGraphEvent-&gt;DontCompleteUntil(TGraphTask&lt;FGeneratePrimesTask&gt;::CreateTask(NULL, CurrentThread).ConstructAndDispatchWhenReady());</span>
<span class="cm">        */</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Searching For Primes&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">FinalNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">();</span>
<span class="w">        </span><span class="n">Log</span><span class="p">(</span><span class="n">__FUNCTION__</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%d Prime Numbers found between %d and %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">NumsAmount</span><span class="p">,</span><span class="w"> </span><span class="n">OffsetFromNum</span><span class="p">,</span><span class="w"> </span><span class="n">FinalNumber</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// log</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Log</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">Action</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">uint32</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
<span class="w">        </span><span class="n">FString</span><span class="w"> </span><span class="n">CurrentThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">CurrentThreadId</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d] - %s&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">CurrentThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">ANSI_TO_TCHAR</span><span class="p">(</span><span class="n">Action</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Calculation of PrimeNumbers</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">CalculatePrimes</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Lambda checker for prime number</span>
<span class="w">        </span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IsPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">Num</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// since 0 and 1 is not prime return false.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Run a loop from 2 to n-1</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// if the number is divisible by i, then n is not a</span>
<span class="w">                </span><span class="c1">// prime number.</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// otherwise, n is prime number.</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OffsetFromNum</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Generate prime numbers until their amount less than 10000</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumsAmount</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">CurrentTestNumber</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">CurrentTestNumber</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">PrimesFound</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Данный таск генерирует в потоке указанное кол-во простых чисел, начиная от указанного числа.</p>
<p>Чтобы запустить приведенный выше класс задачи внутри графа вызывается следующая команда:
<div class="highlight"><pre><span></span><code><span class="c1">// Generate Primes Task</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Tasks/GeneratePrimesTask.h&quot;</span>
<span class="c1">// ...</span>
<span class="c1">// Construct test task</span>
<span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FGeneratePrimesTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mi">10500</span><span class="p">,</span><span class="mi">20000</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/1b7d56591b08737781f4f1e876920610.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1b7d56591b08737781f4f1e876920610.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1b7d56591b08737781f4f1e876920610.png" /></a></p>
<p>Запуск осуществляется мной внутри таймера:
<div class="highlight"><pre><span></span><code><span class="n">GetWorld</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetTimerManager</span><span class="p">().</span><span class="n">SetTimer</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">FTimerHandle</span><span class="p">()),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Construct test task</span>
<span class="w">    </span><span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">TaskEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FGeneratePrimesTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mi">10500</span><span class="p">,</span><span class="mi">20000</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/06353fc280480d734528512ad8e6f0b8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="06353fc280480d734528512ad8e6f0b8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/06353fc280480d734528512ad8e6f0b8.png" /></a></p>
<h3 id="constructandhold"><code>ConstructAndHold</code></h3>
<p>Иногда есть необходимость создать задачу, но не запускать ее сразу, для этого используется метод <code>TGraphTask::ConstructAndHold</code>.
Созданную таким образом задачу разработчик может запустить в любой момент, используя <code>TGraphTask::Unlock</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Construct task and hold it&#39;s execution</span>
<span class="c1">// Constructor will be called, but DoTask will not be called</span>
<span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FGeneratePrimesTask</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">Task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FGeneratePrimesTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndHold</span><span class="p">(</span><span class="mi">10500</span><span class="p">,</span><span class="mi">20000</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">SomethingHappend</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// Run Task</span>
<span class="w">    </span><span class="n">Task</span><span class="o">-&gt;</span><span class="n">Unlock</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="-graphtask">Вложенный класс - как <code>GraphTask</code></h3>
<p>Одна из самых недооцененных особенностей с++ состоит в возможности вложения классов, структур и перечислений(enum) внутрь других классов, структур, перечислений и даже методов.</p>
<p>В предыдущих примерах я создал отдельный файл под таск, вычисляющий простые числа. Если вам такого делать не хочется или ситуация не позволяет реализовывать глобально доступный класс, можно реализовать класс под таск прямо внутри метода. И он будет работать.
<div class="highlight"><pre><span></span><code><span class="c1">// Nested class that is used as Task Graph task that generates and prints out Fibbonacci numbers</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FFibbonacciCalculationTask</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Fibbonacci numbers amount to generate</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">GenerationCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Constructor</span>
<span class="w">    </span><span class="n">FFibbonacciCalculationTask</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">inGenerationCount</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">GenerationCount</span><span class="p">(</span><span class="n">inGenerationCount</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Object Id</span>
<span class="w">    </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FFibbonacciCalculationTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Named Thread where our task will be executed</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetDesiredThread</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Sub tasks called from this task track mode</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetSubsequentsMode</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">FireAndForget</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Task calculations should go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">int32</span><span class="w"> </span><span class="n">ThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
<span class="w">        </span><span class="n">FString</span><span class="w"> </span><span class="n">ThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Print out fibonacci numbers until</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">GenerationCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">Fibn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d], Next Fibbonacci Number:%d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">ThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">Fibn</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Recursive Fibbonacci</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// fibbonacci - each nex fib number is summ of n-1 and n-2 numbers</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1 and 1 is first fib numbers</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// Run class as task</span>
<span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">OutEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FFibbonacciCalculationTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/465baacb7ccd63344bdf5b577c51a139.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="465baacb7ccd63344bdf5b577c51a139.png" auto_="auto;" display="block;" margin:="margin:" src="../images/465baacb7ccd63344bdf5b577c51a139.png" /></a></p>
<h3 id="ffunctiongraphtask">Запуск функции в <code>FFunctionGraphTask</code></h3>
<p>Класс <code>FFunctionGraphTask</code> создан для того, чтобы не мучать разработчика постоянным написанием классов под примитивные задачи. <code>FFunctionGraphTask</code> - это уже готовый класс задачи, который позволяет напрямую запустить функцию или лямбду из переданную в качестве аргумента.
<div class="highlight"><pre><span></span><code><span class="c1">// FFunctionGraphTask</span>
<span class="n">FFunctionGraphTask</span><span class="o">::</span><span class="n">CreateAndDispatchWhenReady</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Thread Id</span>
<span class="w">    </span><span class="n">uint32</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">CurrentThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">CurrentThreadId</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Thread Sleeps&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// Sleep</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Debug</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d] - Duration: %f&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">CurrentThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="n">TStatId</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b0a4a39200b66765553dc13e937d2fbb.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b0a4a39200b66765553dc13e937d2fbb.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b0a4a39200b66765553dc13e937d2fbb.png" /></a></p>
<p>Так-же <code>FFunctionGraphTask</code> можно использовать, например, для обработки завершающего события.</p>
<h4 id="mycompletiongraphevent">Событие завершения задачи <code>MyCompletionGraphEvent</code></h4>
<p>В <code>DoTask(ENamedThreads::Type CurrentThread, const FGraphEventRef&amp; MyCompletionGraphEvent)</code>  есть параметр <code>MyCompletionGraphEvent</code>, который вызывается автоматически, при завершении задачи.</p>
<p>Мы можем подключить к этому параметру обработчик в виде вызова <code>FFunctionGraphTask</code> следующим образом:
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="c1">// Wait for FFunctionGraphTask to finish</span>
<span class="w">    </span><span class="n">MyCompletionGraphEvent</span><span class="o">-&gt;</span><span class="n">DontCompleteUntil</span><span class="p">(</span><span class="n">FFunctionGraphTask</span><span class="o">::</span><span class="n">CreateAndDispatchWhenReady</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;MyCompletionGraphEvent has Been Called!&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="c1">// Sleep</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">3.1</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;MyCompletionGraphEvent has Been Fnished!&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="n">TStatId</span><span class="p">(),</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// We can also call another task from here</span>
<span class="w">    </span><span class="c1">//MyCompletionGraphEvent-&gt;DontCompleteUntil(TGraphTask&lt;FGeneratePrimesTask&gt;::CreateTask(NULL, CurrentThread).ConstructAndDispatchWhenReady());</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/32b4015928290697e23d8ebfb868d418.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="32b4015928290697e23d8ebfb868d418.png" auto_="auto;" display="block;" margin:="margin:" src="../images/32b4015928290697e23d8ebfb868d418.png" /></a></p>
<p>Поскольку обе задачи запускаются в графе <code>AnyThread</code> они работают синхронно. Если нужно добавить асинхронности - установите граф исполнения <code>MyCompletionGraphEvent</code> на <code>ENamedThreads::AnyBackgroundThreadNormalTask</code>.</p>
<p><a class="glightbox" href="../images/324df06716fb093ab30dc196a8a67cb7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="324df06716fb093ab30dc196a8a67cb7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/324df06716fb093ab30dc196a8a67cb7.png" /></a></p>
<p><a class="glightbox" href="../images/411fcdee988746bdd2230840590c56b8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="411fcdee988746bdd2230840590c56b8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/411fcdee988746bdd2230840590c56b8.png" /></a></p>
<h3 id="fdelegategraphtask-fsimpledelegategraphtask">Запуск асинхронных событий в <code>FDelegateGraphTask</code> и <code>FSimpleDelegateGraphTask</code></h3>
<p>Помимо<code>FFunctionGraphTask</code> в движке так-же присутствуют еще два интерфейса для упрощенного запуска асинхронной логики.</p>
<p>Интерфейс <code>FDelegateGraphTask</code> позволяет запустить в одном из потоков метод, привязанный к одному, конкретному, делегату. При этом делегат должен принимать два параметра: <code>NamedThreads::Type CurrentThread</code> и  <code>const FGraphEventRef&amp; MyCompletionGraphEvent</code>, которые соответствуют аргументам метода <code>DoTask</code>.
Есть и упрощенный вариант данного интерфейса - <code>FSimpleDelegateGraphTask</code>, без аргументов.
<div class="highlight"><pre><span></span><code><span class="c1">// FSimpleDelegateGraphTask Sample</span>
<span class="n">FSimpleDelegateGraphTask</span><span class="o">::</span><span class="n">CreateAndDispatchWhenReady</span><span class="p">(</span><span class="n">FSimpleDelegateGraphTask</span><span class="o">::</span><span class="n">FDelegate</span><span class="o">::</span><span class="n">CreateLambda</span><span class="p">([</span><span class="k">this</span><span class="p">](){</span>
<span class="w">    </span><span class="c1">// Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Thread Id</span>
<span class="w">    </span><span class="n">uint32</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">CurrentThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">CurrentThreadId</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Thread Sleeps&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// Sleep</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Debug</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d] - Duration: %f&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">CurrentThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="p">}),</span><span class="w"> </span><span class="n">TStatId</span><span class="p">());</span>
<span class="c1">// FDelegateGraphTask Sample</span>
<span class="n">FDelegateGraphTask</span><span class="o">::</span><span class="n">CreateAndDispatchWhenReady</span><span class="p">(</span>
<span class="w">    </span><span class="n">FDelegateGraphTask</span><span class="o">::</span><span class="n">FDelegate</span><span class="o">::</span><span class="n">CreateLambda</span><span class="p">([</span><span class="k">this</span><span class="p">](</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">InCurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// Thread Id</span>
<span class="w">        </span><span class="n">uint32</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
<span class="w">        </span><span class="n">FString</span><span class="w"> </span><span class="n">CurrentThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">CurrentThreadId</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Thread Sleeps&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="c1">// Sleep</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mf">3.0</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d] - Duration: %f&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">CurrentThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">CurrentThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">    </span><span class="p">}),</span>
<span class="n">TStatId</span><span class="p">());</span>
</code></pre></div></p>
<h3 id="_13">Управление задачами в графе</h3>
<p>Задачам в графе можно задавать порядок исполнения, а так-же создавать из задач сложные логические цепочки. Такой подход позволяет разбивать сложные вычисления на несколько этапов.</p>
<p>Давайте создадим отдельный файл для задач, которыми мы собираемся управлять. Я назвал его <code>SimpleTask.h</code></p>
<p><a class="glightbox" href="../images/aeac0a82e0235670fa859dffaf833a48.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="aeac0a82e0235670fa859dffaf833a48.png" auto_="auto;" display="block;" margin:="margin:" src="../images/aeac0a82e0235670fa859dffaf833a48.png" /></a></p>
<p>С таким кодом:
<div class="highlight"><pre><span></span><code><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CoreMinimal.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Stats/Stats.h&gt;</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// FThreadManager</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;HAL/ThreadManager.h&quot;</span>
<span class="cm">/**</span>
<span class="cm">* Very Simple graph task</span>
<span class="cm">* based on TaskGraphInterfaces.h / FGenericTask (it&#39;s commented section)</span>
<span class="cm">*/</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FSimpleTask</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Arguments</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">SleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">TaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// For Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">FSimpleTask</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">InSleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="w"> </span><span class="n">InTaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">SleepTime</span><span class="p">(</span><span class="n">InSleepTime</span><span class="p">),</span><span class="w"> </span><span class="n">TaskName</span><span class="p">(</span><span class="n">InTaskName</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// i&#39;l do time measuring for task</span>
<span class="w">        </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Constructed task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">FSimpleTask</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Object Id</span>
<span class="w">    </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FSimpleTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Named Thread where our task will be executed</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetDesiredThread</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Sub tasks called from this task track mode</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetSubsequentsMode</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">TrackSubsequents</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Task calculations should go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Running task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Sleep</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="n">SleepTime</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Все что делает этот таск, как видите - ждет <code>SleepTime</code> секунд. При реальной разработке, вместо ожидания, должна идти сложная логика.</p>
<p>Вызывается этот таск простым кодом:
<div class="highlight"><pre><span></span><code><span class="c1">// Construct test task</span>
<span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">TaskEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">);</span>
</code></pre></div>
Давайте посмотрим на метод <code>CreateTask</code>, точнее на его реализацию в движке, файл <code>\Runtime\Core\Public\Async\TaskGraphInterfaces.h</code>, строка 1297 (в <code>UE5.1</code>).
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  Factory to create a task and return the helper object to construct the embedded task and set it up for execution.</span>
<span class="cm"> *  @param Prerequisites; the list of FGraphEvents that must be completed prior to this task executing.</span>
<span class="cm"> *  @param CurrentThreadIfKnown; provides the index of the thread we are running on. Can be ENamedThreads::AnyThread if the current thread is unknown.</span>
<span class="cm"> *  @return a temporary helper class which can be used to complete the process.</span>
<span class="cm">**/</span>
<span class="k">static</span><span class="w"> </span><span class="n">FConstructor</span><span class="w"> </span><span class="n">CreateTask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventArray</span><span class="o">*</span><span class="w"> </span><span class="n">Prerequisites</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThreadIfKnown</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">)</span>
</code></pre></div>
Метод <code>CreateTask</code> имеет параметр <code>Prerequisites</code>, на котором я заострю внимание. <code>Prerequisites</code> - это массив событий, которые должны быть завершены, прежде чем запустится таск, созданный через <code>CreateTask</code>.
Таким образом можно заставить систему синхронизировать выполнение задач.
<div class="highlight"><pre><span></span><code><span class="c1">// Task A -&gt; Task B -&gt; Task D -&gt; ---------------</span>
<span class="c1">//   |                           | Task Finish |</span>
<span class="c1">//   ------&gt; Task C -----------&gt; ---------------</span>
<span class="c1">// Global scope variables</span>
<span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">TaskAEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskBEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskCEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskDEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskFinishEvt</span><span class="p">;</span>
<span class="c1">// Task A</span>
<span class="n">TaskAEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="c1">// Since Prerequisites passed by ref we can&#39;t call all tasks with same Prerequisites refrence</span>
<span class="c1">// So need to use scope</span>
<span class="c1">// Variables defined in scope - acessible only inisde of it</span>
<span class="c1">// Task B Scope</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">Prerequisites</span><span class="p">;</span>
<span class="w">    </span><span class="n">Prerequisites</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TaskAEvt</span><span class="p">);</span><span class="w"> </span><span class="c1">// Task B Waits for Task A</span>
<span class="w">    </span><span class="n">TaskBEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Prerequisites</span><span class="p">).</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">2.1f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Task C Scope</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">Prerequisites</span><span class="p">;</span>
<span class="w">    </span><span class="n">Prerequisites</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TaskAEvt</span><span class="p">);</span><span class="w"> </span><span class="c1">// Task C Waits for Task A</span>
<span class="w">    </span><span class="n">TaskCEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Prerequisites</span><span class="p">).</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Task D Scope</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">Prerequisites</span><span class="p">;</span>
<span class="w">    </span><span class="n">Prerequisites</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">TaskBEvt</span><span class="p">);</span><span class="w"> </span><span class="c1">// Task D Waits for Task B</span>
<span class="w">    </span><span class="n">TaskDEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Prerequisites</span><span class="p">).</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">1.5f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// Task Finish Scope</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">Prerequisites</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">TaskAEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskBEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskCEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskDEvt</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// Task Finish Waits for all Tasks to be completed</span>
<span class="w">    </span><span class="n">TaskFinishEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Prerequisites</span><span class="p">).</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Finish&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
В этом коде я реализую следующую схему:
<div class="highlight"><pre><span></span><code><span class="c1">// Task A -&gt; Task B -&gt; Task D -&gt; ---------------</span>
<span class="c1">//   |                           | Task Finish |</span>
<span class="c1">//   ------&gt; Task C -----------&gt; ---------------</span>
</code></pre></div>
Таск <code>B</code> зависит от <code>А</code>, а <code>D</code> зависит от <code>B</code>. Таск <code>C</code> зависит от <code>A</code>, поэтому выполняется в промежутке, парралельно таскам <code>B</code> и <code>D</code>.
Финальный таск ждет выполнения всех остальных и лишь потом запускается.</p>
<p>Вывод в лог выглядит так:
<div class="highlight"><pre><span></span><code><span class="o">---------</span>
<span class="n">Constructed</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;A&quot;</span>
<span class="o">---------</span>
<span class="n">Constructed</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;B&quot;</span>
<span class="n">Running</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;A&quot;</span>
<span class="o">---------</span>
<span class="n">Constructed</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;C&quot;</span>
<span class="o">---------</span>
<span class="n">Constructed</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;D&quot;</span>
<span class="o">---------</span>
<span class="n">Constructed</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;Finish&quot;</span>
<span class="n">Task</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="w"> </span><span class="n">Executed</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mf">2.000110</span><span class="w"> </span><span class="n">seconds</span><span class="p">.</span>
<span class="o">---------</span>
<span class="n">Running</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;B&quot;</span>
<span class="n">Running</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;C&quot;</span>
<span class="n">Task</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="n">Executed</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mf">3.000357</span><span class="w"> </span><span class="n">seconds</span><span class="p">.</span>
<span class="o">---------</span>
<span class="n">Task</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="n">Executed</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mf">4.100642</span><span class="w"> </span><span class="n">seconds</span><span class="p">.</span>
<span class="o">---------</span>
<span class="n">Running</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;D&quot;</span>
<span class="n">Task</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="w"> </span><span class="n">Executed</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mf">5.600780</span><span class="w"> </span><span class="n">seconds</span><span class="p">.</span>
<span class="o">---------</span>
<span class="n">Running</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="s">&quot;Finish&quot;</span>
<span class="n">Task</span><span class="w"> </span><span class="s">&quot;Finish&quot;</span><span class="w"> </span><span class="n">Executed</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="mf">6.601250</span><span class="w"> </span><span class="n">seconds</span><span class="p">.</span>
<span class="o">---------</span>
</code></pre></div>
Обратите внимание - задача <code>C</code> работает парралельно задаче <code>B</code>, а задача <code>Finish</code> запускается самой последней и ее суммарное время исполнения (между конструктором и деструктором) самое большое.</p>
<h4 id="fnullgraphtask"><code>FNullGraphTask</code></h4>
<p>В движке есть предзаданная задача - <code>FNullGraphTask</code>, единственный смысл которой состоит в том, чтобы закрывать последовательное исполнение группы задач.</p>
<p><a class="glightbox" href="../images/e7e187bbc2e0bc4f4c8a269c072e38d4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e7e187bbc2e0bc4f4c8a269c072e38d4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e7e187bbc2e0bc4f4c8a269c072e38d4.png" /></a></p>
<p>В приведенном выше примере я использовал таск <code>Finish</code>, чтобы сгруппировать таски.</p>
<p>Давайте используем <code>FNullGraphTask</code> для той-же цели.
<div class="highlight"><pre><span></span><code><span class="c1">//  Task A -&gt;</span>
<span class="c1">//          | -&gt; NullTask(Gather/Fence)</span>
<span class="c1">//  Task B -&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// We need  only STAT ID for Null task, so declare it in macro</span>
<span class="w">    </span><span class="n">DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;FNullGraphTask.Gather&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">FStat_STAT_FNullGraphTask_Gather</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">    </span><span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">TaskAEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">TaskBEvt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FSimpleTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">Prerequisites</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">TaskAEvt</span><span class="p">,</span><span class="w"> </span><span class="n">TaskBEvt</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">FGraphEventRef</span><span class="w"> </span><span class="n">CompleteEvent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FNullGraphTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Prerequisites</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="n">GET_STATID</span><span class="p">(</span><span class="n">FStat_STAT_FNullGraphTask_Gather</span><span class="p">),</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">GameThread</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Waiting until Tasks A and B completed!&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="n">CompleteEvent</span><span class="o">-&gt;</span><span class="n">Wait</span><span class="p">();</span><span class="w"> </span><span class="c1">// this will FREEZE THREAD!</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Tasks A and B completed!&quot;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/a102ae0b20052163d38d6a19f9a06e38.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a102ae0b20052163d38d6a19f9a06e38.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a102ae0b20052163d38d6a19f9a06e38.png" /></a></p>
<h3 id="tfuture-tpromise"><code>TFuture</code> - <code>TPromise</code></h3>
<p>Связка типов <code>TFuture</code> - <code>TPromise</code> используется для получения данных из потока.</p>
<p>Данные типы являются аналогами типов <code>std::future</code> и <code>std::promise</code> из стандартной библиотеки
Более подробно прочитать про эти объекты можно на <a href="https://stackoverflow.com/a/11020645/2574125">stackoverflow</a>.</p>
<ul>
<li><code>TPromise</code> - это тип, используя который можно передать данные в <code>TFuture</code>.</li>
<li><code>TFuture</code> - это тип, к которому можно привязать событие получения данных. Это событие будет вызвано, когда <code>TPromise</code> получает обещанное значение.</li>
</ul>
<p>Работа с этими типами выполняется по следующей концепции:
<div class="highlight"><pre><span></span><code>Создаем TPromise Promise, то есть обещание какого-то результата
TPromise&lt;int&gt; Promise - тут я обещаю передать целое число.

Promise.GetFuture() - При создании объекта TPromise в нем генерируется переменная состояния типа TFutureState&lt;ResultType&gt;, значение которой можно получить методом GetFuture()
TFuture&lt;int&gt; FutureValue = Promise.GetFuture()
Объект FutureValue, привязанный к Promise таким образом, будет автоматически вызван, когда обещание будет исполнено.

Promise.SetValue(5) - данный метод позволяет исполнить обещание о передаче значения. Исполнение обещания автоматически активирует привязанный через Promise.GetFuture() объект FutureValue.
</code></pre></div>
Важным элементом системы обещаний является проверка на исполнимость обещаний. Если мы не вызываем <code>TPromise::SetValue</code> в текущей области видимости, то в движке случается сбой. Не создавайте объекты <code>TPromise</code>, которым вы не собираетесь установить значение.</p>
<p>Рассмотрим использование такого подхода применительно к функции <code>AsyncTask</code>.
Она возвращает <code>void</code>, поэтому одним из способов получения данных из <code>AsyncTask</code> может быть связка <code>TFuture</code> - <code>TPromise</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// TFuture - TPromise tests</span>
<span class="n">TPromise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Promise</span><span class="p">;</span><span class="w"> </span><span class="c1">// Empty Promise Initialisation</span>
<span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Promise</span><span class="p">.</span><span class="n">GetFuture</span><span class="p">();</span><span class="w"> </span><span class="c1">// Promise Future</span>
<span class="n">AsyncTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">PR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Promise</span><span class="p">)]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Fulfill the promise&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">PR</span><span class="p">.</span><span class="n">SetValue</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// since lambda is &#39;mutable&#39; we can set value to promise alias, which will &#39;Fulfill Promise&#39;</span>
<span class="p">});</span>
<span class="c1">// Promise SHULD ALWAYS BEEN FULFILLED before calling .Then() or .Next() OR IT CRASH with error - Assertion Failed</span>
<span class="c1">// this callback will be called once Promise is fulfilled</span>
<span class="c1">//Future.Then([&amp;](TFuture&lt;int&gt; Future) -&gt; void {</span>
<span class="w">    </span><span class="c1">// Make Sure it&#39;s valid</span>
<span class="w">    </span><span class="c1">//if (Future.IsValid()) {</span>
<span class="w">        </span><span class="c1">//UE_LOG(LogTemp, Warning, TEXT(&quot;Result calculated in thread is %i&quot;), Future.Get())</span>
<span class="w">    </span><span class="c1">//}</span>
<span class="c1">//});</span>
<span class="c1">// or we can use binding to Next</span>
<span class="n">Future</span><span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Result</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Result calculated in thread is %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Result</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/2173da322c41dcda0d28d49a6c61e4fe.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2173da322c41dcda0d28d49a6c61e4fe.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2173da322c41dcda0d28d49a6c61e4fe.png" /></a></p>
<p>Я использовал <code>MoveTemp</code>, чтобы передать <code>Promise</code> в тело лямбды как <code>rvalue</code>. Такой подход позволяет передавать обещания внутрь потоков и возвращать оттуда значения. Важно, чтобы лямбда, запускаемая в потоке была <code>mutable</code>, потому что полученный "по значению" псевдоним <code>PR</code> изменить из нее иначе не получится.</p>
<h3 id="_14">Собственные функции для запуска задач в графе</h3>
<p>Функция <code>AsyncTask</code>, которую я описал ранее, имеет очень убогую реализацию. Предлагаю переписать ее с учетом механики <code>TFuture</code> - <code>TPromise</code>.</p>
<p><a class="glightbox" href="../images/21443cefff37ec214fb7177aca39d43a.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="21443cefff37ec214fb7177aca39d43a.png" auto_="auto;" display="block;" margin:="margin:" src="../images/21443cefff37ec214fb7177aca39d43a.png" /></a></p>
<p>Для начала создадим с этой целью отдельный заголовочный файл в подпапке модуля <code>Tasks</code>. Назовем - <code>AsyncHelpers.h</code>.</p>
<p><a class="glightbox" href="../images/272fb6bf709821da5d440a25e4687d34.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="272fb6bf709821da5d440a25e4687d34.png" auto_="auto;" display="block;" margin:="margin:" src="../images/272fb6bf709821da5d440a25e4687d34.png" /></a></p>
<p>После создания файла, в Unreal Engine выполняем команду <code>Tool -&gt; Refresh Visual Studio 2022 Project</code>, чтобы этот файл появился в проекте Visual Studio.</p>
<p><a class="glightbox" href="../images/30af89bdeb1b24079307de1fa2fbfea4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="30af89bdeb1b24079307de1fa2fbfea4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/30af89bdeb1b24079307de1fa2fbfea4.png" /></a></p>
<p><a class="glightbox" href="../images/d1eab013907e12c951b2f39d8a2b6678.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="d1eab013907e12c951b2f39d8a2b6678.png" auto_="auto;" display="block;" margin:="margin:" src="../images/d1eab013907e12c951b2f39d8a2b6678.png" /></a></p>
<p>Внутри файла создадим класс <code>AsyncHelpers</code>, в который можно будет добавлять собственные <code>static</code> методы, в частности новый <code>AsyncTask</code>.
<div class="highlight"><pre><span></span><code><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CoreMinimal.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Stats/Stats.h&gt;</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// Class to store our custom async methods</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AsyncHelpers</span><span class="w"> </span><span class="p">{</span>
<span class="p">};</span>
</code></pre></div>
В качестве заготовки для класса можно использовать функцию <code>Async</code> из файла <code>\Runtime\Core\Public\Async\Async.h</code>.</p>
<p><a class="glightbox" href="../images/eb80c648e29b501c978d97709d471830.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="eb80c648e29b501c978d97709d471830.png" auto_="auto;" display="block;" margin:="margin:" src="../images/eb80c648e29b501c978d97709d471830.png" /></a></p>
<p>Учтите, что функция <code>Async</code> написана под с++ 11 или 14, поэтому некоторые ее конструкции можно упростить. А от некоторых и вовсе - отказаться. Например определение возвращаемого типа через <code>-&gt;</code> сейчас уже не обязательно.</p>
<p>Так-же не обязательно отдельно передавать <code>CompletionCallback</code> в <code>Promise</code>.
Класс задачи, которую я буду запускать - реализую прямо внутри функции, как я это делал в предыдущей главе с классом <code>FFibbonacciCalculationTask</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Class to store our custom async methods</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AsyncHelpers</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">CallableType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">CAsyncTask</span><span class="p">(</span><span class="n">CallableType</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ThreadBody</span><span class="p">)</span><span class="c1">// -&gt; TFuture&lt;decltype(Forward&lt;CallableType&gt;(ThreadBody)())&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">ResultType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">)());</span><span class="w"> </span><span class="c1">// detect return type of passed ThreadBody callable (lambda)</span>
<span class="w">        </span><span class="c1">// make UniqueFunction based on ThreadBody</span>
<span class="w">        </span><span class="c1">// &quot;Perfect Forwarding&quot; logics are used here, it&#39;s very complex question to explain in comments</span>
<span class="w">        </span><span class="c1">// short explanation:</span>
<span class="w">        </span><span class="c1">// if ThreadBody copyable (TFunction), it will be copied into Function variable using copy-constructor</span>
<span class="w">        </span><span class="c1">// if ThreadBody movable (TUniqueFunction), it will be moved into Function using move-constructor</span>
<span class="w">        </span><span class="c1">// exact explanations about &quot;Perfect Forwarding&quot; and how it works, you can find in my article about move-logics in this book</span>
<span class="w">        </span><span class="c1">// we also can use MoveTemp, but this will force copyable objects also move into Function variable</span>
<span class="w">        </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Function</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">));</span>
<span class="w">        </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Promise</span><span class="p">;</span>
<span class="w">        </span><span class="n">TFuture</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Promise</span><span class="p">.</span><span class="n">GetFuture</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// use nested class for task, because we can</span>
<span class="w">        </span><span class="k">class</span><span class="w"> </span><span class="nc">FExecuteAsyncTask</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="k">private</span><span class="o">:</span>
<span class="w">            </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will hold passed function</span>
<span class="w">            </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TaskPromise</span><span class="p">;</span>
<span class="w">        </span><span class="k">public</span><span class="o">:</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// remove default constructor</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">(</span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inLogicToExecute</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// remove copy-constructor</span>
<span class="w">            </span><span class="c1">// move-constructor, works only with rvalues</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">(</span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">inLogicToExecute</span><span class="p">,</span><span class="w"> </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">inPromise</span><span class="p">)</span>
<span class="w">                </span><span class="o">:</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">inLogicToExecute</span><span class="p">)),</span><span class="w"> </span><span class="c1">// store thread logic in private class field</span>
<span class="w">                </span><span class="n">TaskPromise</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">inPromise</span><span class="p">))</span>
<span class="w">            </span><span class="p">{}</span>
<span class="w">            </span><span class="c1">// Object Id</span>
<span class="w">            </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FFibbonacciCalculationTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Named Thread where our task will be executed</span>
<span class="w">            </span><span class="k">static</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetDesiredThread</span><span class="p">()</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Sub tasks called from this task track mode</span>
<span class="w">            </span><span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetSubsequentsMode</span><span class="p">()</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">FireAndForget</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Task calculations should go here</span>
<span class="w">            </span><span class="kt">void</span><span class="w"> </span><span class="n">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">SetPromise</span><span class="p">(</span><span class="n">TaskPromise</span><span class="p">,</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will also run LogicToExecute(), because SetPromise gets result of the function</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="c1">// Run class as task</span>
<span class="w">        </span><span class="cm">/*FGraphEventRef OutEvent = */</span>
<span class="w">        </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FExecuteAsyncTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Function</span><span class="p">),</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Promise</span><span class="p">));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Future</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Задумка тут такова: я передаю в метод <code>AsyncHelpers::CAsyncTask</code> лямбду (которая может возвращать значение) и эта лямбда вызывается в таске, попадая туда через аргументы <code>ConstructAndDispatchWhenReady</code>.
Лямбда конструируется из переменной <code>ThreadBody</code> прямо на лету, в начале функции.
<div class="highlight"><pre><span></span><code><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Function</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">));</span>
</code></pre></div>
Тут-же создается и возвращаемый объект - <code>TFuture</code>, который привязывается к <code>Promise</code>. Сам <code>Promise</code> передается в класс таска, где и вызывается.</p>
<p>В коде используется <code>move</code> семантика и <code>perfect forwarding</code>. Это техники для передачи объектов между разными переменными без копирования. Объяснять данные темы в этой статье бессмысленно - они слишком объемные.</p>
<p>Код прекрасно работает:
<div class="highlight"><pre><span></span><code><span class="c1">//.h</span>
<span class="c1">// Async Helpers Library</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Tasks/AsyncHelpers.h&quot;</span>
<span class="c1">///</span>
<span class="c1">//.cpp</span>
<span class="c1">// Begin Play</span>
<span class="n">AsyncHelpers</span><span class="o">::</span><span class="n">CAsyncTask</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Test Running Callable&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">}).</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Result</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[completed] Result = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Result</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/1f61c9188f9acd846af89800e8bd5d59.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1f61c9188f9acd846af89800e8bd5d59.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1f61c9188f9acd846af89800e8bd5d59.png" /></a></p>
<p>Чего в такой реализации не хватает? Не хватает ключевой возможности системы <code>GraphTask</code> - объединять несколько задач в цепочки, а так-же запускать их по своему желанию.</p>
<p>Давайте этот недочет исправим.
<div class="highlight"><pre><span></span><code><span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/Async.h&quot;</span>
<span class="c1">// Class to store our custom async methods</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AsyncHelpers</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">CallableType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">CAsyncTask</span><span class="p">(</span><span class="n">CallableType</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ThreadBody</span><span class="p">,</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">TargetThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">)</span><span class="c1">// -&gt; TFuture&lt;decltype(Forward&lt;CallableType&gt;(ThreadBody)())&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">ResultType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">)());</span><span class="w"> </span><span class="c1">// detect return type of passed ThreadBody callable (lambda)</span>
<span class="w">        </span><span class="c1">// make UniqueFunction based on ThreadBody</span>
<span class="w">        </span><span class="c1">// &quot;Perfect Forwarding&quot; logics are used here, it&#39;s very complex question to explain in comments</span>
<span class="w">        </span><span class="c1">// short explanation:</span>
<span class="w">        </span><span class="c1">// if ThreadBody copyable (TFunction), it will be copied into Function variable using copy-constructor</span>
<span class="w">        </span><span class="c1">// if ThreadBody movable (TUniqueFunction), it will be moved into Function using move-constructor</span>
<span class="w">        </span><span class="c1">// exact explanations about &quot;Perfect Forwarding&quot; and how it works, you can find in my article about move-logics in this book</span>
<span class="w">        </span><span class="c1">// we also can use MoveTemp, but this will force copyable objects also move into Function variable</span>
<span class="w">        </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Function</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">));</span>
<span class="w">        </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Promise</span><span class="p">;</span>
<span class="w">        </span><span class="n">TFuture</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Promise</span><span class="p">.</span><span class="n">GetFuture</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// use nested class for task, because we can</span>
<span class="w">        </span><span class="k">class</span><span class="w"> </span><span class="nc">FExecuteAsyncTask</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="k">private</span><span class="o">:</span>
<span class="w">            </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will hold passed function</span>
<span class="w">            </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TaskPromise</span><span class="p">;</span>
<span class="w">            </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">TargetThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span><span class="w"> </span><span class="c1">// thread that we will use to run our task</span>
<span class="w">        </span><span class="k">public</span><span class="o">:</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// remove default constructor</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">(</span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">inLogicToExecute</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// remove copy-constructor</span>
<span class="w">            </span><span class="c1">// move-constructor, works only with rvalues</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">(</span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">inLogicToExecute</span><span class="p">,</span><span class="w"> </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">inPromise</span><span class="p">)</span>
<span class="w">                </span><span class="o">:</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">inLogicToExecute</span><span class="p">)),</span><span class="w"> </span><span class="c1">// store thread logic in private class field</span>
<span class="w">                </span><span class="n">TaskPromise</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">inPromise</span><span class="p">))</span>
<span class="w">            </span><span class="p">{}</span>
<span class="w">            </span><span class="c1">// Object Id</span>
<span class="w">            </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FFibbonacciCalculationTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Named Thread where our task will be executed</span>
<span class="w">            </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetDesiredThread</span><span class="p">()</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">TargetThread</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Sub tasks called from this task track mode</span>
<span class="w">            </span><span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetSubsequentsMode</span><span class="p">()</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">FireAndForget</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Task calculations should go here</span>
<span class="w">            </span><span class="kt">void</span><span class="w"> </span><span class="n">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">SetPromise</span><span class="p">(</span><span class="n">TaskPromise</span><span class="p">,</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will also run LogicToExecute(), because SetPromise gets result of the function</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="c1">// Run class as task</span>
<span class="w">        </span><span class="cm">/*FGraphEventRef OutEvent = */</span>
<span class="w">        </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FExecuteAsyncTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndDispatchWhenReady</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Function</span><span class="p">),</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Promise</span><span class="p">));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Future</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Controllable Async Task</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">CallableType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">ControllableAsyncTask</span><span class="p">(</span><span class="n">CallableType</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ThreadBody</span><span class="p">,</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">TargetThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">)</span><span class="c1">// -&gt; TFuture&lt;decltype(Forward&lt;CallableType&gt;(ThreadBody)())&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">ResultType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">)());</span><span class="w"> </span><span class="c1">// detect return type of passed ThreadBody callable (lambda)</span>
<span class="w">        </span><span class="c1">// make UniqueFunction based on ThreadBody</span>
<span class="w">        </span><span class="c1">// &quot;Perfect Forwarding&quot; logics are used here, it&#39;s very complex question to explain in comments</span>
<span class="w">        </span><span class="c1">// short explanation:</span>
<span class="w">        </span><span class="c1">// if ThreadBody copyable (TFunction), it will be copied into Function variable using copy-constructor</span>
<span class="w">        </span><span class="c1">// if ThreadBody movable (TUniqueFunction), it will be moved into Function using move-constructor</span>
<span class="w">        </span><span class="c1">// exact explanations about &quot;Perfect Forwarding&quot; and how it works, you can find in my article about move-logics in this book</span>
<span class="w">        </span><span class="c1">// we also can use MoveTemp, but this will force copyable objects also move into Function variable</span>
<span class="w">        </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Function</span><span class="p">(</span><span class="n">Forward</span><span class="o">&lt;</span><span class="n">CallableType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ThreadBody</span><span class="p">));</span>
<span class="w">        </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Promise</span><span class="p">;</span>
<span class="w">        </span><span class="n">TFuture</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Promise</span><span class="p">.</span><span class="n">GetFuture</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// use nested class for task, because we can</span>
<span class="w">        </span><span class="k">class</span><span class="w"> </span><span class="nc">FExecuteAsyncTask</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="k">private</span><span class="o">:</span>
<span class="w">            </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will hold passed function</span>
<span class="w">            </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TaskPromise</span><span class="p">;</span>
<span class="w">            </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">TargetThread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">;</span><span class="w"> </span><span class="c1">// thread that we will use to run our task</span>
<span class="w">        </span><span class="k">public</span><span class="o">:</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// remove default constructor</span>
<span class="w">            </span><span class="c1">// move-constructor, works only with rvalues</span>
<span class="w">            </span><span class="k">explicit</span><span class="w"> </span><span class="n">FExecuteAsyncTask</span><span class="p">(</span><span class="w"> </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="p">()</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">inLogicToExecute</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">TPromise</span><span class="o">&lt;</span><span class="n">ResultType</span><span class="o">&gt;&amp;&amp;</span><span class="w"> </span><span class="n">inPromise</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">inTargetThread</span>
<span class="w">                                        </span><span class="p">)</span>
<span class="w">                </span><span class="o">:</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">inLogicToExecute</span><span class="p">)),</span><span class="w"> </span><span class="c1">// store thread logic in private class field</span>
<span class="w">                </span><span class="n">TaskPromise</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">inPromise</span><span class="p">)),</span>
<span class="w">                </span><span class="n">TargetThread</span><span class="p">(</span><span class="n">inTargetThread</span><span class="p">)</span>
<span class="w">            </span><span class="p">{}</span>
<span class="w">            </span><span class="c1">// Object Id</span>
<span class="w">            </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FFibbonacciCalculationTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_TaskGraphTasks</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Named Thread where our task will be executed</span>
<span class="w">            </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetDesiredThread</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">TargetThread</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Sub tasks called from this task track mode</span>
<span class="w">            </span><span class="k">static</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">GetSubsequentsMode</span><span class="p">()</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">ESubsequentsMode</span><span class="o">::</span><span class="n">FireAndForget</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// Task calculations should go here</span>
<span class="w">            </span><span class="kt">void</span><span class="w"> </span><span class="n">DoTask</span><span class="p">(</span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">Type</span><span class="w"> </span><span class="n">CurrentThread</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FGraphEventRef</span><span class="o">&amp;</span><span class="w"> </span><span class="n">MyCompletionGraphEvent</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">SetPromise</span><span class="p">(</span><span class="n">TaskPromise</span><span class="p">,</span><span class="w"> </span><span class="n">LogicToExecute</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will also run LogicToExecute(), because SetPromise gets result of the function</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="c1">// Construct task here</span>
<span class="w">        </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FExecuteAsyncTask</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">OutTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FExecuteAsyncTask</span><span class="o">&gt;::</span><span class="n">CreateTask</span><span class="p">().</span><span class="n">ConstructAndHold</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Function</span><span class="p">),</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Promise</span><span class="p">),</span><span class="w"> </span><span class="n">TargetThread</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// *note TGraphTask::ExecuteTask has parameter bDeleteOnCompletion which automatically clears task object from memory</span>
<span class="w">        </span><span class="c1">// because of that we don&#39;t need smart pointer here</span>
<span class="w">        </span><span class="c1">// also - task destructor is deleted, so we anyway can&#39;t make smart pointer out of it&#39;s instance</span>
<span class="w">        </span><span class="c1">// just use raw pointer as i did, Unreal will take care of the rest, no memory leaks here</span>
<span class="w">        </span><span class="c1">// results struct</span>
<span class="w">        </span><span class="c1">// *note You may not belive me, but in c++17, we not only can do temporal structs, we even can return them</span>
<span class="w">        </span><span class="c1">// but, since one of types in struct use compile-time decuction, only way to use this function results will be - thru &#39;auto&#39; keyword</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">CAsyncTaskResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">decltype</span><span class="p">(</span><span class="n">Future</span><span class="p">)</span><span class="w"> </span><span class="n">Future</span><span class="p">;</span><span class="w"> </span><span class="c1">// or TFuture&lt;decltype(Forward&lt;CallableType&gt;(ThreadBody)())&gt;</span>
<span class="w">            </span><span class="n">TGraphTask</span><span class="o">&lt;</span><span class="n">FExecuteAsyncTask</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">TaskPointer</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">CAsyncTaskResult</span><span class="p">{</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Future</span><span class="p">),</span><span class="w"> </span><span class="n">OutTask</span><span class="w"> </span><span class="p">};</span><span class="w"> </span><span class="c1">// rvalue</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div></p>
<blockquote>
<p>В коде используется не совсем очевидная логика, которую я обычно стараюсь избегать, дабы упростить жизнь читателю. Однако, в этом случае, без подобного было не обойтись. Я комментировал код как мог, но темы, рассматриваемые в нем куда шире, чем мои комментарии к ним.</p>
</blockquote>
<p>Я написал метод <code>ControllableAsyncTask</code>, который создает задачу, но не запускает, возвращая лишь ее экземпляр, благодаря <code>ConstructAndHold</code>. Задачу можно запустить вручную, при помощи метода <code>Unlock</code>.
Добиться работы аргумента <code>Prerequisites</code> я не смог, потому что <code>FGraphEventRef</code> невозможно передать в другую область видимости, сохранив валидность, даже через <code>move</code> семантику.
<div class="highlight"><pre><span></span><code><span class="c1">//.h</span>
<span class="c1">// Async Helpers Library</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Tasks/AsyncHelpers.h&quot;</span>
<span class="c1">///</span>
<span class="c1">//.cpp</span>
<span class="c1">// Begin Play</span>
<span class="c1">// simple async task with finish event</span>
<span class="n">AsyncHelpers</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[simple task] started&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[simple task] finished&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">})</span>
<span class="p">.</span><span class="n">Then</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">TFuture</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// this will be triggered once simple task finished</span>
<span class="w">    </span><span class="c1">// Make Sure it&#39;s valid</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Future</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[simple task][completed] Result = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Future</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
<span class="cm">/*.Next([&amp;](int Result)-&gt;void {</span>
<span class="cm">    UE_LOG(LogTemp, Warning, TEXT(&quot;[simple task][completed] Result = %i&quot;), Result);</span>
<span class="cm">});*/</span>
<span class="c1">// controllable async task 1</span>
<span class="n">FGraphEventArray</span><span class="w"> </span><span class="n">Task1Prereq</span><span class="p">{};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">Task1Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AsyncHelpers</span><span class="o">::</span><span class="n">ControllableAsyncTask</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// wait for simple task</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[task1] started&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[task1] finished&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">},</span><span class="w"> </span><span class="n">ENamedThreads</span><span class="o">::</span><span class="n">AnyThread</span><span class="p">);</span>
<span class="c1">// controllable async task 2</span>
<span class="k">auto</span><span class="w"> </span><span class="n">Task2Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AsyncHelpers</span><span class="o">::</span><span class="n">ControllableAsyncTask</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[task2] started&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[task2] finished&quot;</span><span class="p">));</span>
<span class="p">});</span>
<span class="c1">// make simple chain: Task1 -&gt; Task2</span>
<span class="c1">// this event will be called once task is finished</span>
<span class="n">Task1Data</span><span class="p">.</span><span class="n">Future</span><span class="p">.</span><span class="n">Next</span><span class="p">([</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">TP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">Task2Data</span><span class="p">.</span><span class="n">TaskPointer</span><span class="p">)](</span><span class="kt">int</span><span class="w"> </span><span class="n">Result</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// since TaskPointer is non-copyable i had to use MoveTemp in lambda captures</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;[task1][completed] Result = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Result</span><span class="p">);</span>
<span class="w">    </span><span class="n">TP</span><span class="o">-&gt;</span><span class="n">Unlock</span><span class="p">();</span><span class="w"> </span><span class="c1">// unlock [task 2]</span>
<span class="p">});</span>
<span class="n">Task1Data</span><span class="p">.</span><span class="n">TaskPointer</span><span class="o">-&gt;</span><span class="n">Unlock</span><span class="p">();</span><span class="w"> </span><span class="c1">// unlock tasks chain</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/8ac132b430cf60d9eaa943d994162347.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="8ac132b430cf60d9eaa943d994162347.png" auto_="auto;" display="block;" margin:="margin:" src="../images/8ac132b430cf60d9eaa943d994162347.png" /></a></p>
<p>В этом коде, сначала, идет запуск простой задачи, без управления. Далее происходит инициализация двух задач с задержкой запуска. К первой задаче привязывается лямбда, которая срабатывает по завершению задачи. В эту лямбду я поместил запуск второй задачи. Что создает последовательность: <code>Задача 1 -&gt; Задача 2</code>.
Таким образом можно делать цепочки из задач, которые могут быть выполнены на выбранном графе, в выбранный вами момент.</p>
<h2 id="_15">Пул потоков</h2>
<p>Пул потоков - это система, запускающая переданные ей потоки (помещаются в массив) порциями указанного размера.</p>
<p>За интерфейс пула потоков в Unreal Engine отвечает класс <code>FQueuedThreadPool</code>, используя который и предполагается создавать пул потоков. Создание пула потоков, в большинстве случаев, сводится к созданию переменной типа <code>FQueuedThreadPool</code>.
В движке уже есть готовые пулы потоков. Их список можно найти в <code>\Runtime\Core\Private\HAL\ThreadingBase.cpp</code>.</p>
<p 0="0" align="center;" auto_="auto;" display="block;" margin:="margin:"><a class="glightbox" href="../images/3109c9e1739b5d2c7e921972f8294ea3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3109c9e1739b5d2c7e921972f8294ea3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3109c9e1739b5d2c7e921972f8294ea3.png" /></a></p>
<p>Доступ к глобальным пулам потоков возможен из любого места, если вы подключили <code>#include "CoreMinimal.h"</code>.
Реализация пула потоков находится в классе <code>FQueuedThreadPoolBase</code> по пути <code>\Runtime\Core\Private\HAL\ThreadingBase.cpp</code>.</p>
<p><a class="glightbox" href="../images/8a7544e5f6be55b3d4da0287336290c4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="8a7544e5f6be55b3d4da0287336290c4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/8a7544e5f6be55b3d4da0287336290c4.png" /></a></p>
<p>Работает пул потоков по следующему принципу. Разработчик добавляет в массив пула определенное количество задач. Далее пул берет определенное количество потоков из массива и запускает их.</p>
<p>Когда пачка потоков отработает - берется следующая.</p>
<p>Для чего создана такая система? Представьте, что одновременно вы запустили сто потоков на вашем процессоре. Это мгновенно парализует работу всех ядер. Пул позволяет распределять нагрузку, проводя вычисления равномерными порциями.</p>
<p>Те, кто работал с <code>C#</code>, наверняка уже использовали <code>ThreadPool</code> там. Принцип работы пула в <code>Unreal Engine</code> ничем не отличается, разве что имена классов другие.</p>
<h2 id="_16">Создание пула потоков</h2>
<p>Создание пула потоков сводится к инициализации объекта типа <code>FQueuedThreadPool</code>.
Давайте добавим собственный пул потоков внутри класса <code>ThreadsComponent</code>.
<div class="highlight"><pre><span></span><code><span class="c1">//.h</span>
<span class="c1">// Threads Pool</span>
<span class="n">FQueuedThreadPool</span><span class="o">*</span><span class="w"> </span><span class="n">LocalPool</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">OnComponentDestroyed</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">bDestroyingHierarchy</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// we need to clear pool memory, since it&#39;s not garbage collected</span>
<span class="w">    </span><span class="n">LocalPool</span><span class="o">-&gt;</span><span class="n">Destroy</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/5edfdd2e9a57cc1ad2766986d14aedaa.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5edfdd2e9a57cc1ad2766986d14aedaa.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5edfdd2e9a57cc1ad2766986d14aedaa.png" /></a></p>
<p>Важно понимать, что пул потоков и его память не освобождаются автоматически. Пул надо выгружать вручную, для чего там есть метод <code>Destroy</code>. При уничтожении компонента - должен уничтожаться и пул потоков, который в нем находится. Иначе будет утечка памяти.</p>
<p>Инициализация пула будет осуществлена в конструкторе класса.
<div class="highlight"><pre><span></span><code><span class="c1">//.cpp</span>
<span class="c1">// === Initialize Thread Pool ===</span>
<span class="n">LocalPool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FQueuedThreadPool</span><span class="o">::</span><span class="n">Allocate</span><span class="p">();</span><span class="w"> </span><span class="c1">// allocate memory</span>
<span class="n">int32</span><span class="w"> </span><span class="n">NumThreadsInThreadPool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">SupportsMultithreading</span><span class="p">())</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">FPlatformMisc</span><span class="o">::</span><span class="n">NumberOfWorkerThreadsToSpawn</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Creating pool with number of active threads = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">NumThreadsInThreadPool</span><span class="p">);</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">StackSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="n">verify</span><span class="p">(</span><span class="n">LocalPool</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="n">NumThreadsInThreadPool</span><span class="p">,</span><span class="w"> </span><span class="n">StackSize</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_SlightlyBelowNormal</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;LocalThreadPool&quot;</span><span class="p">)));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/36b452189fa5986325c0f2be95f9b218.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="36b452189fa5986325c0f2be95f9b218.png" auto_="auto;" display="block;" margin:="margin:" src="../images/36b452189fa5986325c0f2be95f9b218.png" /></a></p>
<p><a class="glightbox" href="../images/2b3e2a97316e2214e8655649425fd679.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2b3e2a97316e2214e8655649425fd679.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2b3e2a97316e2214e8655649425fd679.png" /></a></p>
<p>Число потоков в пуле определяется или самим пользователем или, как сделал я, на основе платформы - <code>FPlatformMisc::NumberOfWorkerThreadsToSpawn()</code>.
Я печатаю это значение в лог, чтобы узнать, сколько именно там определено потоков. На моей системе это 10 возможных активных потоков.</p>
<p>В коде используется сокращенный <code>if</code>, я не помню описывал ли эту конструкцию, некоторые начинающие разработчики имеют сложности с ней.</p>
<p>Синтаксис сокращенного <code>if</code> такой:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// если a &gt; b то value = 1</span>
</code></pre></div>
Размер стека, по умолчанию, равен <code>1024 * 1024</code>, найти его можно в файле <code>\Source\Runtime\Launch\Private\LaunchEngineLoop.cpp</code>.</p>
<p><a class="glightbox" href="../images/6b750add74d888034345e2d82f52b15b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6b750add74d888034345e2d82f52b15b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6b750add74d888034345e2d82f52b15b.png" /></a></p>
<p>Я просто взял это значение, мне было в падлу считать чо там будет по умножению, поэтому было решено оставить это препроцессору. Оператор <code>constexpr</code> заменит умножение простым числом, при компиляции, так, что это вычисление не будет отнимать производительность.</p>
<p>Макрос <code>verify</code> прерывает исплнение кода и закрывает движок (с выводом ошибки), если выражение, находящееся в нем, возвращает <code>false</code>. Метод <code>Create</code> возвращает <code>bool</code>, поэтому он прекрасно может быть использован в <code>verify</code>.</p>
<p><a class="glightbox" href="../images/5115fb5599187ecf07e2f4266525d670.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5115fb5599187ecf07e2f4266525d670.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5115fb5599187ecf07e2f4266525d670.png" /></a></p>
<p>Теперь, когда у нас есть пул потоков - нужны задачи, которые в этом пуле будут запускаться.</p>
<h2 id="-asynctasks">Асинхронные задачи в пуле потоков -<code>AsyncTask's</code></h2>
<p>В дополнение к графу задач, Unreal Engine имеет интерфейсы <code>FAsyncTask</code> и <code>FAutoDeleteAsyncTask</code>, которые позволяют запускать асинхронные задачи в глобальных пулах потоков. Их список можно найти в <code>\Runtime\Core\Private\HAL\ThreadingBase.cpp</code>.</p>
<p 0="0" align="center;" auto_="auto;" display="block;" margin:="margin:"><a class="glightbox" href="../images/3109c9e1739b5d2c7e921972f8294ea3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3109c9e1739b5d2c7e921972f8294ea3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3109c9e1739b5d2c7e921972f8294ea3.png" /></a></p>
<p>Эти задачи могут быть как повторяемыми, так и авто-удаляемыми.</p>
<p>При этом классы задач чем-то схожи с классами задач для графа задач, с той лишь разницей, что им не требуется указывать метод <code>GetDesiredThread</code>.
В отличие от задач графа, асинхронные задачи запускаются внутри специально созданного под эти цели пула потоков.</p>
<h3 id="_17">Подготовка к работе</h3>
<p>В подпапке нашего модуля <code>ThreadsModule/Public/Tasks</code> создадим файл: <code>AsyncTasks.h</code>.</p>
<p><a class="glightbox" href="../images/dc8122673f7f4fe8e4bffe97f9d32092.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="dc8122673f7f4fe8e4bffe97f9d32092.png" auto_="auto;" display="block;" margin:="margin:" src="../images/dc8122673f7f4fe8e4bffe97f9d32092.png" /></a></p>
<p>В этом файле я буду создавать все классы асинхронных задач.</p>
<p>После создания файла, в движке Unreal выполните команду: <code>Tools -&gt; Refresh Visual Studio 2022 Project</code>, чтобы обновить проект.</p>
<p><a class="glightbox" href="../images/e9d724dc55bf2c6bb1e291a73dfdbca2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e9d724dc55bf2c6bb1e291a73dfdbca2.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e9d724dc55bf2c6bb1e291a73dfdbca2.png" /></a></p>
<p>В Visual Studio нажмите <code>Reload All</code>. После этого файл появится в <code>Solution Explorer</code>.</p>
<p><a class="glightbox" href="../images/e4fce64ee4b9465a36e51930bfec87e0.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e4fce64ee4b9465a36e51930bfec87e0.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e4fce64ee4b9465a36e51930bfec87e0.png" /></a></p>
<p>Файл пока пустой. Пропишем туда  стандартый заголовок:
<div class="highlight"><pre><span></span><code><span class="cp">#pragma once</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;CoreMinimal.h&quot;</span>
<span class="c1">// Async</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Async/AsyncWork.h&quot;</span><span class="c1"> // Non Abandonable Task</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;Stats/Stats.h&gt;</span><span class="c1"> // Time measuring</span>
</code></pre></div></p>
<h3 id="iqueuedwork">Интерфейс <code>IQueuedWork</code></h3>
<p>Интерфейс <code>IQueuedWork</code> позволяет создавать примитивные задачи для непосредственной загрузки в пул потоков.</p>
<p>Базовый шаблон для таких задач можно найти в файле <code>\Runtime\Core\Public\Misc\IQueuedWork.h</code>.
Код из этого файла:
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Interface for queued work objects.</span>
<span class="cm"> *</span>
<span class="cm"> * This interface is a type of runnable object that requires no per thread</span>
<span class="cm"> * initialization. It is meant to be used with pools of threads in an</span>
<span class="cm"> * abstract way that prevents the pool from needing to know any details</span>
<span class="cm"> * about the object being run. This allows queuing of disparate tasks and</span>
<span class="cm"> * servicing those tasks with a generic thread pool.</span>
<span class="cm"> */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IQueuedWork</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * This is where the real thread work is done. All work that is done for</span>
<span class="cm">     * this queued object should be done from within the call to this function.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">DoThreadedWork</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Tells the queued work that it is being abandoned so that it can do</span>
<span class="cm">     * per object clean up as needed. This will only be called if it is being</span>
<span class="cm">     * abandoned before completion. NOTE: This requires the object to delete</span>
<span class="cm">     * itself using whatever heap it was allocated in.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Abandon</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Returns any special work flags.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">EQueuedWorkFlags</span><span class="w"> </span><span class="nf">GetQueuedWorkFlags</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">EQueuedWorkFlags</span><span class="o">::</span><span class="n">None</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Returns an approximation of the peak memory (in bytes) this task could require during it&#39;s execution.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">int64</span><span class="w"> </span><span class="nf">GetRequiredMemory</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="cm">/* Negative value means unknown */</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Virtual destructor so that child implementations are guaranteed a chance</span>
<span class="cm">     * to clean up any resources they allocated.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">IQueuedWork</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">    * Internal data can be used by the pool</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">IInternalDataType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRefCountPtr</span><span class="o">&lt;</span><span class="n">IQueuedWorkInternalData</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">IInternalDataType</span><span class="w"> </span><span class="n">InternalData</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
На основе этого кода можно сделать следующий шаблон:
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">AsyncPoolWorker</span><span class="o">:</span><span class="k">public</span><span class="w"> </span><span class="n">IQueuedWork</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">AsyncPoolWorker</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// destructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">AsyncPoolWorker</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// main calculations go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoThreadedWork</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// if task somehow not executed in pool and abandoned</span>
<span class="w">    </span><span class="c1">// (for example when engine is closed), we need to clear resources of the task here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Abandon</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// cleanup here</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
Обратите внимание, что шаблон <code>IQueuedWork</code> никак не управляет собственной памятью. А значит удалять задачу придется вручную.</p>
<p>Отдельно стоит коснуться метода <code>Abandon</code>. Он срабатывает, когда созданная задача была загруженна в пул, но не дождалась очереди на выполнение. В каком случае подобный сценарий может случиться? Если пользователь закрыл движок, в момент, когда задача была в очереди. Или случился сбой. Метод <code>Abandon</code> вызывается, в случае непредвиденной выгрузки пула потоков. В примитивных случаях там достаточно вызвать обычный деструктор.</p>
<p>Используем этот шаблон, для  создания простейшей задачи.
<div class="highlight"><pre><span></span><code><span class="c1">// basic ThreadPoolTask</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AsyncPoolWorker</span><span class="o">:</span><span class="k">public</span><span class="w"> </span><span class="n">IQueuedWork</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// For Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Arguments</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">SleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">TaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">AsyncPoolWorker</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">InSleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="w"> </span><span class="n">InTaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">SleepTime</span><span class="p">(</span><span class="n">InSleepTime</span><span class="p">),</span><span class="w"> </span><span class="n">TaskName</span><span class="p">(</span><span class="n">InTaskName</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Usually the constructor doesn&#39;t do anything except save the arguments for use in DoWork or GetDesiredThread.</span>
<span class="w">        </span><span class="c1">// In my case i&#39;l do time measuring for task</span>
<span class="w">        </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Constructed task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// destructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">AsyncPoolWorker</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// main calculations go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoThreadedWork</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Running task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Sleep</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="n">SleepTime</span><span class="p">);</span><span class="w"> </span><span class="c1">// instead of douing anything i&#39;l just let it sleep</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="c1">// since IQueuedWork can&#39;t desyroy itself, we need to do so manually</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// if task somehow task not executed in pool and abandoned</span>
<span class="w">    </span><span class="c1">// (for example when engine is closed), we need to clear resources of the task here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">Abandon</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// cleanup here</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">};</span>
</code></pre></div>
Я переписал <code>FSimpleTask</code> под <code>IQueuedWork</code>, то есть, все что делает задача - блокрует поток на <code>N</code> секунд.</p>
<p>Запуск задачи можно провести в <code>BeginPlay</code> так:
<div class="highlight"><pre><span></span><code><span class="c1">//.cpp</span>
<span class="c1">// BeginPlay</span>
<span class="c1">// Run Task in Local Pool</span>
<span class="n">LocalPool</span><span class="o">-&gt;</span><span class="n">AddQueuedWork</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">AsyncPoolWorker</span><span class="p">(</span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test IQueuedWork Task&quot;</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/4bcef0c2df9b0fdd4f1fdbe02a8ab939.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4bcef0c2df9b0fdd4f1fdbe02a8ab939.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4bcef0c2df9b0fdd4f1fdbe02a8ab939.png" /></a></p>
<p><a class="glightbox" href="../images/0e4426bf9271ba0fa2da88165fda8196.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0e4426bf9271ba0fa2da88165fda8196.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0e4426bf9271ba0fa2da88165fda8196.png" /></a></p>
<p>При этом, для запуска задач <code>IQueuedWork</code> не обязательно всякий раз создавать пулы потоков. Можно использовать один из тех, что встроены в движок. В частности - <code>GThreadPool</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Run Task in Local Pool</span>
<span class="n">GThreadPool</span><span class="o">-&gt;</span><span class="n">AddQueuedWork</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">AsyncPoolWorker</span><span class="p">(</span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test IQueuedWork Task&quot;</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b8a4d4b886e46a0653e335ed9522d709.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b8a4d4b886e46a0653e335ed9522d709.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b8a4d4b886e46a0653e335ed9522d709.png" /></a></p>
<p><a class="glightbox" href="../images/d41182a2939733cd90c6949bbfb019e8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="d41182a2939733cd90c6949bbfb019e8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/d41182a2939733cd90c6949bbfb019e8.png" /></a></p>
<h3 id="fnonabandonabletask"><code>FNonAbandonableTask</code></h3>
<p>Класс <code>FNonAbandonableTask</code> является чуть более развитым способом запускать задачи в выбранном пуле потоков.</p>
<p>Почему <code>NonAbandonable</code>? Как я уже писал по поводу метода <code>Abandon</code> в <code>IQueuedWork</code> - срабатывает он когда задача была загружена в пул, но еще не обработалась им. Происходит это, если движок закрывается пользователем или случается какой-либо сбой. В методе <code>Abandon</code> достаточно просто вызывать деструктор. Так вот <code>NonAbandonableTask</code>, в случае сбоя - сработает мгновенно. То есть этот тип задачи не может быть "не выполнен". Поэтому реализовывать в этой задаче метод <code>Abandon</code> не имеет никакого смысла.</p>
<p>Рассмотрим код задачи.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FReusableTask</span><span class="o">:</span><span class="k">public</span><span class="w"> </span><span class="n">FNonAbandonableTask</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// For Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Arguments</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">SleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">TaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">FAsyncTask</span><span class="o">&lt;</span><span class="n">FReusableTask</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will allow FAsyncTask to access private methods of current class</span>
<span class="w">                                            </span><span class="c1">// since our logic anyway goes in public section, this line can be removed</span>
<span class="w">                                            </span><span class="c1">// but let it be</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">FReusableTask</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">InSleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="w"> </span><span class="n">InTaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">SleepTime</span><span class="p">(</span><span class="n">InSleepTime</span><span class="p">),</span><span class="w"> </span><span class="n">TaskName</span><span class="p">(</span><span class="n">InTaskName</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Usually the constructor doesn&#39;t do anything except save the arguments for use in DoWork or GetDesiredThread.</span>
<span class="w">        </span><span class="c1">// In my case i&#39;l do time measuring for task</span>
<span class="w">        </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Constructed task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">FReusableTask</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Task calculations should go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoWork</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Running task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Sleep</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="n">SleepTime</span><span class="p">);</span><span class="w"> </span><span class="c1">// instead of douing anything i&#39;l just let it sleep</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="c1">// since FNonAbandonableTask can&#39;t desyroy itself, we need to do so manually</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Object Id</span>
<span class="w">    </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FReusableTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_ThreadPoolAsyncTasks</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Я переписал класс <code>FSimpleTask</code>, чтобы он работал как <code>FNonAbandonableTask</code>. В потоке тут не происходит никаких вычислений, просто ожидание в течении избранного времени.</p>
<p>Поскольку <code>FNonAbandonableTask</code> не умеет удалять сама себя - пришлось сделать вызов деструктора вручную, в методе <code>DoWork</code> - <code>delete this</code>. Если эту строчку убрать - задача так и будет висеть в памяти. При этом указатель на нее уже давно будет утерян, а следовательно - будет утечка памяти.</p>
<p>Запуск задачи:
<div class="highlight"><pre><span></span><code><span class="c1">//.h</span>
<span class="c1">// Async Tasks Library</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Tasks/AsyncTasks.h&quot;</span>
<span class="c1">//...</span>
<span class="c1">//.cpp</span>
<span class="c1">// BeginPlay</span>
<span class="c1">// Make instance of FNonAbandonableTask</span>
<span class="k">auto</span><span class="w"> </span><span class="n">ReusableTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FAsyncTask</span><span class="o">&lt;</span><span class="n">FReusableTask</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TaskTest&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// Pass Args</span>
<span class="n">ReusableTask</span><span class="o">-&gt;</span><span class="n">StartBackgroundTask</span><span class="p">(</span><span class="n">LocalPool</span><span class="p">);</span><span class="w"> </span><span class="c1">// Start task in LocalPool</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/03cbb71f9c9f13da7ea4deade14388c4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="03cbb71f9c9f13da7ea4deade14388c4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/03cbb71f9c9f13da7ea4deade14388c4.png" /></a></p>
<p><a class="glightbox" href="../images/cf3ebae01e0675379a96e69592336c64.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="cf3ebae01e0675379a96e69592336c64.png" auto_="auto;" display="block;" margin:="margin:" src="../images/cf3ebae01e0675379a96e69592336c64.png" /></a></p>
<p>Передача аргументов в задачу осуществляется в конструкторе <code>FAsyncTask</code>.
При этом саму задачу можно запустить как синхронно, так и асинхронно. Для этого есть два метода:
<code>StartBackgroundTask()</code> - запускает задачу асинхронно в выбранном пуле потоков. По умолчанию это <code>GThreadPool</code>, но мы можем выбрать и созданный ранее <code>LocalPool</code>.
<div class="highlight"><pre><span></span><code><span class="n">ReusableTask</span><span class="o">-&gt;</span><span class="n">StartBackgroundTask</span><span class="p">(</span><span class="n">LocalPool</span><span class="p">,</span><span class="w"> </span><span class="n">EQueuedWorkPriority</span><span class="o">::</span><span class="n">High</span><span class="p">,</span><span class="w"> </span><span class="n">EQueuedWorkFlags</span><span class="o">::</span><span class="n">DoNotRunInsideBusyWait</span><span class="p">);</span>
</code></pre></div>
<code>StartSynchronousTask()</code> - запускает задачу синхронно с выбранным приоритетом. Что значит "синхронно"? Это значит, что игра будет заморожена на время исполнения метода <code>DoWork</code> в классе потока. Этот метод игнорирует пул потоков.
<div class="highlight"><pre><span></span><code><span class="n">ReusableTask</span><span class="o">-&gt;</span><span class="n">StartSynchronousTask</span><span class="p">(</span><span class="n">EQueuedWorkPriority</span><span class="o">::</span><span class="n">High</span><span class="p">,</span><span class="n">EQueuedWorkFlags</span><span class="o">::</span><span class="n">Count</span><span class="p">);</span>
</code></pre></div>
Рассмотрим параметры:
<code>ThreadPool</code> - указатель на пул потоков. Создаете или сами, или используете <code>GThreadPool</code>.
<code>EQueuedWorkPriority</code> - приоритет задачи, добавленной в пул.</p>
<p><a class="glightbox" href="../images/42a335c4935d01f18769f580b87822ea.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="42a335c4935d01f18769f580b87822ea.png" auto_="auto;" display="block;" margin:="margin:" src="../images/42a335c4935d01f18769f580b87822ea.png" /></a></p>
<p>В пуле потоков одновременно работать может лишь <code>N</code> задач, как правило это число совпадает с количеством потоков вашего процессора. Пул автоматически выгружает одни задачи и загружает другие, чередуя их таким образом, чтобы потоки не перекрывали друг друга, а процессорное время расходовалось наиболее эффективным образом. Чем выше приоритет потока в пуле - тем раньше он будет запущен для каждой итерации пула.
<code>EQueuedWorkFlags</code> - параметр отвечает за то, будет ли задача в пуле ждать, пока другие задачи этого-же класса исполняются.</p>
<p><a class="glightbox" href="../images/07a35a78809d553f4b05deb1665c3112.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="07a35a78809d553f4b05deb1665c3112.png" auto_="auto;" display="block;" margin:="margin:" src="../images/07a35a78809d553f4b05deb1665c3112.png" /></a></p>
<h3 id="fautodeleteasynctask">Автоматически удаляемые задачи <code>FAutoDeleteAsyncTask</code></h3>
<p>В коде предыдущей задачи я принудительно вызвал деструктор, потому что ее память не очищается, после окончания работы. Это делать не обязательно. Можно запустить задачу через <code>FAutoDeleteAsyncTask</code> и тогда она автоматически будет удалена после обработки.
<div class="highlight"><pre><span></span><code><span class="c1">// Task for test FAutoDeleteAsyncTask</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FWaitAutoDeleteTask</span><span class="o">:</span><span class="k">public</span><span class="w"> </span><span class="n">FNonAbandonableTask</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// For Time Measuring</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Arguments</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">SleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">TaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">FAutoDeleteAsyncTask</span><span class="o">&lt;</span><span class="n">FWaitAutoDeleteTask</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will allow FAsyncTask to access private methods of current class</span>
<span class="w">                                                            </span><span class="c1">// since our logic anyway goes in public section, this line can be removed</span>
<span class="w">                                                            </span><span class="c1">// but let it be</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">FWaitAutoDeleteTask</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">InSleepTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="w"> </span><span class="n">InTaskName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">SleepTime</span><span class="p">(</span><span class="n">InSleepTime</span><span class="p">),</span><span class="w"> </span><span class="n">TaskName</span><span class="p">(</span><span class="n">InTaskName</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Usually the constructor doesn&#39;t do anything except save the arguments for use in DoWork or GetDesiredThread.</span>
<span class="w">        </span><span class="c1">// In my case i&#39;l do time measuring for task</span>
<span class="w">        </span><span class="n">StartTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Constructed task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">FWaitAutoDeleteTask</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Time Measuring</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTime</span><span class="o">::</span><span class="n">Seconds</span><span class="p">();</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> Executed in %f seconds.&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">,</span><span class="w"> </span><span class="n">EndTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">StartTime</span><span class="p">);</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;---------&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Task calculations should go here</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoWork</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Running task </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">TaskName</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Sleep</span>
<span class="w">        </span><span class="n">FPlatformProcess</span><span class="o">::</span><span class="n">Sleep</span><span class="p">(</span><span class="n">SleepTime</span><span class="p">);</span><span class="w"> </span><span class="c1">// instead of douing anything i&#39;l just let it sleep</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Object Id</span>
<span class="w">    </span><span class="n">FORCEINLINE</span><span class="w"> </span><span class="n">TStatId</span><span class="w"> </span><span class="n">GetStatId</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">RETURN_QUICK_DECLARE_CYCLE_STAT</span><span class="p">(</span><span class="n">FAutoDeleteTask</span><span class="p">,</span><span class="w"> </span><span class="n">STATGROUP_ThreadPoolAsyncTasks</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Запуск задачи:
<div class="highlight"><pre><span></span><code><span class="c1">//.h</span>
<span class="c1">// Async Tasks Library</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Tasks/AsyncTasks.h&quot;</span>
<span class="c1">//...</span>
<span class="c1">//.cpp</span>
<span class="c1">// BeginPlay</span>
<span class="k">auto</span><span class="w"> </span><span class="n">ADelTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FAutoDeleteAsyncTask</span><span class="o">&lt;</span><span class="n">FWaitAutoDeleteTask</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Auto Delete Task Test&quot;</span><span class="p">);</span>
<span class="n">ADelTask</span><span class="o">-&gt;</span><span class="n">StartBackgroundTask</span><span class="p">(</span><span class="n">LocalPool</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/0f5734de6dd76460709c8dbe386fa57e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0f5734de6dd76460709c8dbe386fa57e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0f5734de6dd76460709c8dbe386fa57e.png" /></a></p>
<p><a class="glightbox" href="../images/6f9f4a7be16c7a021c02ffdd486e6aed.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6f9f4a7be16c7a021c02ffdd486e6aed.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6f9f4a7be16c7a021c02ffdd486e6aed.png" /></a></p>
<p>Как вы видите - деструктор задачи вызвался автоматически. Именно в деструкторе я провожу замер времени исполнения задачи. Мне не пришлось очищать память оператором <code>delete</code>.</p>
<h2 id="runnable-threads">Runnable Threads</h2>
<p><code>FRunnable</code> - интерфейс для проведения вычислений в отдельном потоке. Это - самый базвый интерфейс многопоточности в Unreal. Именно на его основе построен и <code>TaskGraph</code> и <code>ThreadPool</code>.
Пример реализации <code>FRunnable</code> можно найти в самом движке, в файле <code>\Runtime\Core\Public\HAL\Runnable.h</code>.
Код из этого файла:
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Interface for &quot;runnable&quot; objects.</span>
<span class="cm"> *</span>
<span class="cm"> * A runnable object is an object that is &quot;run&quot; on an arbitrary thread. The call usage pattern is</span>
<span class="cm"> * Init(), Run(), Exit(). The thread that is going to &quot;run&quot; this object always uses those calling</span>
<span class="cm"> * semantics. It does this on the thread that is created so that any thread specific uses (TLS, etc.)</span>
<span class="cm"> * are available in the contexts of those calls. A &quot;runnable&quot; does all initialization in Init().</span>
<span class="cm"> *</span>
<span class="cm"> * If initialization fails, the thread stops execution and returns an error code. If it succeeds,</span>
<span class="cm"> * Run() is called where the real threaded work is done. Upon completion, Exit() is called to allow</span>
<span class="cm"> * correct clean up.</span>
<span class="cm"> */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CORE_API</span><span class="w"> </span><span class="n">FRunnable</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Initializes the runnable object.</span>
<span class="cm">     *</span>
<span class="cm">     * This method is called in the context of the thread object that aggregates this, not the</span>
<span class="cm">     * thread that passes this runnable to a new thread.</span>
<span class="cm">     *</span>
<span class="cm">     * @return True if initialization was successful, false otherwise</span>
<span class="cm">     * @see Run, Stop, Exit</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">Init</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Runs the runnable object.</span>
<span class="cm">     *</span>
<span class="cm">     * This is where all per object thread work is done. This is only called if the initialization was successful.</span>
<span class="cm">     *</span>
<span class="cm">     * @return The exit code of the runnable object</span>
<span class="cm">     * @see Init, Stop, Exit</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">uint32</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Stops the runnable object.</span>
<span class="cm">     *</span>
<span class="cm">     * This is called if a thread is requested to terminate early.</span>
<span class="cm">     * @see Init, Run, Exit</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Stop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Exits the runnable object.</span>
<span class="cm">     *</span>
<span class="cm">     * Called in the context of the aggregating thread to perform any cleanup.</span>
<span class="cm">     * @see Init, Run, Stop</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">Exit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Gets single thread interface pointer used for ticking this runnable when multi-threading is disabled.</span>
<span class="cm">     * If the interface is not implemented, this runnable will not be ticked when FPlatformProcess::SupportsMultithreading() is false.</span>
<span class="cm">     *</span>
<span class="cm">     * @return Pointer to the single thread interface or nullptr if not implemented.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">FSingleThreadRunnable</span><span class="o">*</span><span class="w"> </span><span class="n">GetSingleThreadInterface</span><span class="p">(</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/** Virtual destructor */</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">FRunnable</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Я написал класс асинхронного вычисления следующих N чисел Фиббоначчи используя интерфейсы <code>FRunnable</code> и <code>FSingleThreadRunnable</code> (для однопоточной работы)
<div class="highlight"><pre><span></span><code><span class="c1">// FRunnable class, that calculates N fibbonacci numbers in thread</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AsyncRunnable</span><span class="o">:</span><span class="k">public</span><span class="w"> </span><span class="n">FRunnable</span><span class="p">,</span><span class="w"> </span><span class="n">FSingleThreadRunnable</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Thread Object (points to self)</span>
<span class="w">    </span><span class="n">FRunnableThread</span><span class="o">*</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Fibbonacci numbers amount to generate</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">GenerationCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">bShouldStop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// to stop calculations</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">AsyncRunnable</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">inGenerationCount</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">GenerationCount</span><span class="p">(</span><span class="n">inGenerationCount</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">StackSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="w">        </span><span class="n">Thread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FRunnableThread</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;AsyncRunnable root&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">StackSize</span><span class="p">,</span><span class="w"> </span><span class="n">TPri_Normal</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//destructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">AsyncRunnable</span><span class="p">(){</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Thread</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Thread</span><span class="o">-&gt;</span><span class="n">Kill</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Recursive Fibbonacci</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// fibbonacci - each nex fib number is summ of n-1 and n-2 numbers</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1 and 1 is first fib numbers</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// custom DoWork function</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">DoWork</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">int32</span><span class="w"> </span><span class="n">ThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
<span class="w">        </span><span class="n">FString</span><span class="w"> </span><span class="n">ThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Print out fibonacci numbers until</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">GenerationCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bShouldStop</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="c1">// stop calculations immediately</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">Fibn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FibRec</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">            </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d], Next Fibbonacci Number:%d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">ThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">Fibn</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">    * FRunnable interface</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="c1">// Initializes the runnable object.</span>
<span class="w">    </span><span class="c1">// if returned false - thread won&#39;t be created, so use this as checking solution</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">Init</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;RunnableThread in: Init&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">GenerationCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Main calculations go here</span>
<span class="w">    </span><span class="c1">// should return exit code of runnable object, 0 = success</span>
<span class="w">    </span><span class="n">uint32</span><span class="w"> </span><span class="n">Run</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;RunnableThread in: Run&quot;</span><span class="p">));</span>
<span class="w">        </span><span class="n">DoWork</span><span class="p">();</span><span class="w"> </span><span class="c1">// call do work in thread</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// exit code is just 0</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Stops the runnable object.</span>
<span class="w">    </span><span class="c1">// user, at any moment, even in the middle of calculations, can stop the thread</span>
<span class="w">    </span><span class="c1">// use this function to control stop behaviour</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Stop</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">bShouldStop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;RunnableThread in: Stop&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Exits the runnable object.</span>
<span class="w">    </span><span class="c1">// activate destructor here</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Exit</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// extra cleanup can be done here, before destructor is called</span>
<span class="w">        </span><span class="n">bShouldStop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// stop any calculations if they are gouing</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;RunnableThread in: Exit&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">    * FSingleThreadRunnable interface</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * Gets single thread interface pointer used for ticking this runnable when multi-threading is disabled.</span>
<span class="cm">     * If the interface is not implemented, this runnable will not be ticked when FPlatformProcess::SupportsMultithreading() is false.</span>
<span class="cm">     *</span>
<span class="cm">     * @return Pointer to the single thread interface or nullptr if not implemented.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">FSingleThreadRunnable</span><span class="o">*</span><span class="w"> </span><span class="n">GetSingleThreadInterface</span><span class="p">()</span><span class="w"> </span><span class="k">override</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// SingleThreaded API</span>
<span class="w">    </span><span class="c1">// Run work single-threaded</span>
<span class="w">    </span><span class="c1">// *note: it&#39;s not actual tick, this object is not tickable</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">Tick</span><span class="p">()</span><span class="w"> </span><span class="k">override</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">DoWork</span><span class="p">();</span><span class="w"> </span><span class="c1">// call do work sync</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Я создаю указатель на поток прямо внутри класса, который отвечает за работу потока <code>FRunnableThread* Thread</code>. Таким образом можно создать сам поток прямо из конструктора.</p>
<p>Достаточно просто создать экземпляр этого класса, чтобы запустить асинхронные вычисления.</p>
<p>Я добавил в файл <code>ThreadsComponent.h</code> код:
<div class="highlight"><pre><span></span><code><span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="n">AsyncRunnable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ARunnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</code></pre></div>
<code>TUniquePtr</code> - если вы помните, то это шаблон умного указателя, который не поддерживает копирование.</p>
<p><a class="glightbox" href="../images/88f030e154932ad56837b96912cb8ee7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="88f030e154932ad56837b96912cb8ee7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/88f030e154932ad56837b96912cb8ee7.png" /></a></p>
<p>Далее в конструкторе <code>UThreadsComponent</code> просто пишем такой код:
<div class="highlight"><pre><span></span><code><span class="c1">//.cpp</span>
<span class="c1">// Construct runnable object</span>
<span class="n">ARunnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">AsyncRunnable</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">55</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will make thread, that prints out N fibbonacci numbers</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/dd3bd460c211af1058eb874bdab44417.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="dd3bd460c211af1058eb874bdab44417.png" auto_="auto;" display="block;" margin:="margin:" src="../images/dd3bd460c211af1058eb874bdab44417.png" /></a></p>
<p>Поток запускается автоматически, при создании экземпляра объекта.</p>
<p><a class="glightbox" href="../images/b32d965c6d2b9bc74929e62cd940661c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b32d965c6d2b9bc74929e62cd940661c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b32d965c6d2b9bc74929e62cd940661c.png" /></a></p>
<p><a class="glightbox" href="../images/c292e72a49cb158386bd6a7515a1831c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c292e72a49cb158386bd6a7515a1831c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c292e72a49cb158386bd6a7515a1831c.png" /></a></p>
<p>Поскольку мы запустили поток внутри умного указателя - беспокоиться о памяти необходимости нет. Когда компонент будет удален - удалится и объект потока.</p>
<h2 id="parallelfor"><code>ParallelFor</code></h2>
<p>Используя функцию <code>ParallelFor</code> можно запустить параллельные вычисления какого-либо значения.
<code>ParallelFor</code> - мощнейший инструмент в руках разработчика. При правильном применении, используя этот инструмент можно творить чудеса. При этом сама функция крайне легко создается и вызывается.</p>
<p>Базовый формат функции:
<div class="highlight"><pre><span></span><code><span class="n">ParallelFor</span><span class="p">([</span><span class="n">threads_count</span><span class="p">],</span><span class="w"> </span><span class="p">[](</span><span class="n">int32</span><span class="w"> </span><span class="n">Index</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">int32</span><span class="w"> </span><span class="n">ThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span><span class="w"> </span><span class="c1">// current calculation id</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">ThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Display</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d] Index:%d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">ThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>
Где <code>[threads_count]</code> - количество парралельных потоков, которые будут созданы для вычисления значений.
<code>ParallelFor</code> выполняется синхронно для текущего потока, причем время блокировки зависит от того, как долго самый нагруженный поток проводит вычисления.</p>
<p>То есть вам не нужно событие завершения потока.</p>
<p>Давайте рассмотрим пример использования этой функции для вычисления <code>10'000</code> простых чисел.</p>
<p>Я разделю задачу на 100 потоков, каждый из которых будет проверять 10 простых чисел.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">BiggestPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IterationsAmount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="c1">// loop thru IterationsAmount*10 numbers and get biggest found prime number between 0 and IterationsAmount*10</span>
<span class="c1">// 10 numberw will be processed per loop</span>
<span class="n">ParallelFor</span><span class="p">(</span><span class="n">IterationsAmount</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">BiggestPrime</span><span class="p">,</span><span class="w"> </span><span class="n">IterationsAmount</span><span class="p">](</span><span class="n">int32</span><span class="w"> </span><span class="n">Index</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; ==== &quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">int32</span><span class="w"> </span><span class="n">ThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FPlatformTLS</span><span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span><span class="w"> </span><span class="c1">// current calculation id</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">ThreadName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FThreadManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">GetThreadName</span><span class="p">(</span><span class="n">ThreadId</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// amount of primes</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="c1">// offset</span>
<span class="w">    </span><span class="c1">// Lambda checker for prime number</span>
<span class="w">    </span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IsPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">Num</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// since 0 and 1 is not prime return false.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// Run a loop from 2 to n-1</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Num</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// if the number is divisible by i, then n is not a</span>
<span class="w">            </span><span class="c1">// prime number.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">// otherwise, n is prime number.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Generate prime numbers until their amount less than 10000</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">PrimesFound</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Amount</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CurrentTestNumber</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPrime</span><span class="p">(</span><span class="n">CurrentTestNumber</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">PrimesFound</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">BiggestPrime</span><span class="p">.</span><span class="n">load</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// save biggest prime in atomic</span>
<span class="w">        </span><span class="n">BiggestPrime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CurrentTestNumber</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%s[%d] Index:%d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">ThreadName</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadId</span><span class="p">,</span><span class="w"> </span><span class="n">Index</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="n">EParallelForFlags</span><span class="o">::</span><span class="n">None</span><span class="p">);</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Error</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Max Found Prime Number = %i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">BiggestPrime</span><span class="p">.</span><span class="n">load</span><span class="p">());</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/c09b5d6738155e429dd249461d391ec3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c09b5d6738155e429dd249461d391ec3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c09b5d6738155e429dd249461d391ec3.png" /></a></p>
<p>Несмотря на то, что я применил <code>ParallelFor</code> для математики, наиболее правильным было бы использовать этот инструмент для массовой генерации прожектайлов или высчитывания логики поиска пути для большого количества объектов.</p>
<h2 id="links">Links</h2>
<p>https://zhuanlan.zhihu.com/p/394791310
https://github.com/david-pp/UESnippets/blob/main/SnippetAsync/Private/RNGThread.h</p>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            К началу
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      aftamat4ik
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.top", "toc.follow"], "search": "../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "\u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0432 \u0431\u0443\u0444\u0435\u0440", "clipboard.copy": "\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440", "search.result.more.one": "\u0415\u0449\u0451 1 \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.more.other": "\u0415\u0449\u0451 # \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.none": "\u0421\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e", "search.result.one": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e 1 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435", "search.result.other": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439: #", "search.result.placeholder": "\u041d\u0430\u0447\u043d\u0438\u0442\u0435 \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430", "search.result.term.missing": "\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442", "select.version": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0435\u0440\u0441\u0438\u044e"}}</script>
    
    
      <script src="../assets/javascripts/bundle.dff1b7c8.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>