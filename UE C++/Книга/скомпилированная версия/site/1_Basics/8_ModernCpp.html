
<!doctype html>
<html lang="ru" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Справочник Unreal Engine">
      
      
        <meta name="author" content="aftamat4ik">
      
      
      
        <link rel="prev" href="7_Pointers.html">
      
      
        <link rel="next" href="9_Working_With_Strings.html">
      
      
      <link rel="icon" href="../assets/icon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.3.2">
    
    
      
        <title>Возможности современного c++ - Справочник Unreal Engine</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.30068a00.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.85d0ee34.min.css">
      
      


    
    
      
        <script src="https://unpkg.com/iframe-worker/shim"></script>
      
    
    
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#c" class="md-skip">
          Перейти к содержанию
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Верхний колонтитул">
    <a href="../index.html" title="Справочник Unreal Engine" class="md-header__button md-logo" aria-label="Справочник Unreal Engine" data-md-component="logo">
      
  <img src="../assets/icon.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Справочник Unreal Engine
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Возможности современного c++
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Поиск" placeholder="Поиск" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Поиск">
        
        <button type="reset" class="md-search__icon md-icon" title="Очистить" aria-label="Очистить" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Инициализация поиска
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Вкладки" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../index.html" class="md-tabs__link">
        
  
    
  
  Главная

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="1_First_Project.html" class="md-tabs__link">
          
  
  Основы

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../2_Core/1_Delegates.html" class="md-tabs__link">
          
  
  Ключевые системы

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../3_Advanced/1_HUD.html" class="md-tabs__link">
          
  
  Продвинутая разработка

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../4_Resolving%20Issues/LiveCoding_Encoding_Issues.html" class="md-tabs__link">
          
  
  Решение проблем

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../5_Tips/Change_Asset_Icons.html" class="md-tabs__link">
          
  
  Советы

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Навигация" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="Справочник Unreal Engine" class="md-nav__button md-logo" aria-label="Справочник Unreal Engine" data-md-component="logo">
      
  <img src="../assets/icon.png" alt="logo">

    </a>
    Справочник Unreal Engine
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Главная
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Основы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Основы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="1_First_Project.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Создаем первый проект в Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="2_Engine_Introduction.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Знакомство с движком
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="3_CPP_Recommendations.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Рекомендации по написанию кода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="4_SimplePlugin.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Создание простейшего плагина для Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="5_Macroses_Reflection_System.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Макросы Reflection System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="6_Logging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Печать информации в лог
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="7_Pointers.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Указатели
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Возможности современного c++
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="8_ModernCpp.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Возможности современного c++
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Содержание">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Содержание
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Препроцессор
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Области действия внутри функций
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Пространства имен
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#using-namespace" class="md-nav__link">
    using namespace и пространства имен
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Шаблон для печати типа переменной
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#auto" class="md-nav__link">
    auto
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltype" class="md-nav__link">
    decltype
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltypeauto" class="md-nav__link">
    decltype(auto)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltype_1" class="md-nav__link">
    decltype и указатели на функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltype_2" class="md-nav__link">
    decltype для опеределения возвращаемого типа функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    Указание конечного возвращаемого типа -&gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#forward-declaration" class="md-nav__link">
    Forward Declaration
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constexpr" class="md-nav__link">
    constexpr
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lambda" class="md-nav__link">
    Автозапускаемая Lambda
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdinvoke" class="md-nav__link">
    std::invoke
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#singleton-pattern" class="md-nav__link">
    Singleton Pattern
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Шаблоны
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Зачем нужны шаблоны?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Синтаксис шаблонов
  </a>
  
    <nav class="md-nav" aria-label="Синтаксис шаблонов">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stdenable_if" class="md-nav__link">
    std::enable_if
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    Шаблон с переданным значением
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#auto_1" class="md-nav__link">
    auto в шаблонах
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typename-class" class="md-nav__link">
    Различия между typename и class в шаблоне
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    Вложенные шаблоны
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    Функции с неограниченным количеством параметров
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variadic" class="md-nav__link">
    Классические variadic функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variadic_1" class="md-nav__link">
    Variadic шаблоны
  </a>
  
    <nav class="md-nav" aria-label="Variadic шаблоны">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    Паки параметров
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    Рекурсивная распаковка аргументов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fold-expressions" class="md-nav__link">
    Свернутые выражения (Fold Expressions)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overloaded" class="md-nav__link">
    Распаковка аргументов через overloaded паттерн
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    Преобразования типов, встроенные в с++
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implicit-type-conversions" class="md-nav__link">
    Неявные преобразования типов implicit type conversions
  </a>
  
    <nav class="md-nav" aria-label="Неявные преобразования типов implicit type conversions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    Перегрузка неявного преобразования типов в классах
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explicit" class="md-nav__link">
    explicit
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#static_cast" class="md-nav__link">
    static_cast
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#const_cast" class="md-nav__link">
    const_cast
  </a>
  
    <nav class="md-nav" aria-label="const_cast">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mutable" class="md-nav__link">
    mutable
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dynamic_cast" class="md-nav__link">
    dynamic_cast
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reinterpret_cast" class="md-nav__link">
    reinterpret_cast
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    Классическое приведение типов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#type-punning" class="md-nav__link">
    Обман системы типизации / Каламбур Типизации / Type Punning
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#delete-default" class="md-nav__link">
    = delete и = default в конструкторах классов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#move-semantics" class="md-nav__link">
    Семантика перемещения, Move Semantics
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rvalue-lvalue" class="md-nav__link">
    rvalue, lvalue
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    Копирование и перемещение данных в классе
  </a>
  
    <nav class="md-nav" aria-label="Копирование и перемещение данных в классе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stdmove" class="md-nav__link">
    std::move
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdforward-perfect-forwarding" class="md-nav__link">
    std::forward и Perfect Forwarding
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#copy-and-swap-idiom-raii" class="md-nav__link">
    Copy and Swap idiom, RAII
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typedef" class="md-nav__link">
    Команда typedef и ее применение
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    Упрощение шаблонов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    Работа с указателями
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typedef-typename" class="md-nav__link">
    typedef typename
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typedef_1" class="md-nav__link">
    typedef и шаблонные аргументы
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#using-typedef" class="md-nav__link">
    using вместо typedef
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="9_Working_With_Strings.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа со строками
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="10_Timers_In_%D0%A1%2B%2B.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Таймеры
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="11_Instances_Access.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Доступ к различным сущностям
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_12" >
        
          <label class="md-nav__link" for="__nav_2_12" id="__nav_2_12_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Debug
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_12">
            <span class="md-nav__icon md-icon"></span>
            Debug
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="Debug/Debug_Asserts.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Asserts
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="Debug/Debug_Console_Commands.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Console Commands
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Ключевые системы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Ключевые системы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/1_Delegates.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    События и Делегаты
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/2_Components.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Компоненты в Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/3_SubObjects.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Суб Объекты
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/4_Multithreading.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Многопоточность
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/5_Function_Libraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Библиотеки Функций для Blueprint
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/6_Latent_And_Async_Actions.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Latent и Async Action
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/7_Gameplay_Tags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gameplay Tags
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/8_DataAssets_AssetManager.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа с ассетами и данными
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/9_FileSystem.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа с файловой системой
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/10_Anim_Instance.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Anim Instance
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/11_SubSystems.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Подсистемы
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/12.%20UObject%20Interface.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UObject Interface или UInterface
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Продвинутая разработка
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Продвинутая разработка
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/1_HUD.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HUD или Heads-up Display
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/2_UFUNCTION_Wildcard.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UFUNCTION Wildcard
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/3_Slate%20Runtime.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Slate Runtimе, введение в Slate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/4_UMG.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UMG
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/5_K2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    K2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/6_Registe_New_Asset_Type.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Регистрируем новый тип ассета
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/7_ACharacter_And_Enhanced%20Input.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ACharacter и Enhanced Input
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/8_Gameplay_Ability_System.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gameplay Ability System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/9_Global_Data_Access.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глобальнный доступ к данным
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/10_Global_Event_Bus.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глобальная шина событий
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Решение проблем
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Решение проблем
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/LiveCoding_Encoding_Issues.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Проблемы с кодировкой в LiveCoding
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/Reset_Project.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Сброс (Reset) проекта
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/generatedh_Problems.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Проблемы с файлом .generated.h
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Советы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Советы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Change_Asset_Icons.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Change Asset Icons
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Character_And_EnhancedInput.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Character Boilerplate with Enhanced Input Setup
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/DefaultToSelf_WorldContext.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DefaultToSelf WorldContext
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Different_UPROPERTY.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Переменные разных типов
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/GameInputMode.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Изменение GameInputMode
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Get_UScriptStruct_FromStruct.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ::UScriptStruct из встроенной структуры
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Input_Binding.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    События ввода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Iterate_TMap.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Iterate TMap
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Read_Blueprint_Properties.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Чтение параметров Blueprint класса
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Return_UObject.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Возвращение UObject по ссылке из функции
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Run_Console_Commands.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Запуск консольных команд
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Screen_Size.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Размер экрана
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Slate_Snippets.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Полезные сниппеты Slate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Spawn_Actors.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Spawn, призыв объектов
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Time_Measuring.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Замер времени исполнения кода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Trace.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Trace
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/UEnum_To_String.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UEnum to FString
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/UObject_Base_Class.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UObject Base Class
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Variable_Type_Print_Template.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Шаблон для печати типа переменной
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/struct_operator%3D%3D.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    struct и оператор ==
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Содержание">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Содержание
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    Препроцессор
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Области действия внутри функций
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Пространства имен
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#using-namespace" class="md-nav__link">
    using namespace и пространства имен
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Шаблон для печати типа переменной
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#auto" class="md-nav__link">
    auto
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltype" class="md-nav__link">
    decltype
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltypeauto" class="md-nav__link">
    decltype(auto)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltype_1" class="md-nav__link">
    decltype и указатели на функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#decltype_2" class="md-nav__link">
    decltype для опеределения возвращаемого типа функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    Указание конечного возвращаемого типа -&gt;
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#forward-declaration" class="md-nav__link">
    Forward Declaration
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constexpr" class="md-nav__link">
    constexpr
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lambda" class="md-nav__link">
    Автозапускаемая Lambda
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stdinvoke" class="md-nav__link">
    std::invoke
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#singleton-pattern" class="md-nav__link">
    Singleton Pattern
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Шаблоны
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Зачем нужны шаблоны?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Синтаксис шаблонов
  </a>
  
    <nav class="md-nav" aria-label="Синтаксис шаблонов">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stdenable_if" class="md-nav__link">
    std::enable_if
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    Шаблон с переданным значением
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#auto_1" class="md-nav__link">
    auto в шаблонах
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typename-class" class="md-nav__link">
    Различия между typename и class в шаблоне
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    Вложенные шаблоны
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    Функции с неограниченным количеством параметров
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variadic" class="md-nav__link">
    Классические variadic функции
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#variadic_1" class="md-nav__link">
    Variadic шаблоны
  </a>
  
    <nav class="md-nav" aria-label="Variadic шаблоны">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    Паки параметров
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    Рекурсивная распаковка аргументов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fold-expressions" class="md-nav__link">
    Свернутые выражения (Fold Expressions)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overloaded" class="md-nav__link">
    Распаковка аргументов через overloaded паттерн
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    Преобразования типов, встроенные в с++
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implicit-type-conversions" class="md-nav__link">
    Неявные преобразования типов implicit type conversions
  </a>
  
    <nav class="md-nav" aria-label="Неявные преобразования типов implicit type conversions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    Перегрузка неявного преобразования типов в классах
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#explicit" class="md-nav__link">
    explicit
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#static_cast" class="md-nav__link">
    static_cast
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#const_cast" class="md-nav__link">
    const_cast
  </a>
  
    <nav class="md-nav" aria-label="const_cast">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mutable" class="md-nav__link">
    mutable
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dynamic_cast" class="md-nav__link">
    dynamic_cast
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reinterpret_cast" class="md-nav__link">
    reinterpret_cast
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    Классическое приведение типов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#type-punning" class="md-nav__link">
    Обман системы типизации / Каламбур Типизации / Type Punning
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#delete-default" class="md-nav__link">
    = delete и = default в конструкторах классов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#move-semantics" class="md-nav__link">
    Семантика перемещения, Move Semantics
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rvalue-lvalue" class="md-nav__link">
    rvalue, lvalue
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    Копирование и перемещение данных в классе
  </a>
  
    <nav class="md-nav" aria-label="Копирование и перемещение данных в классе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#stdmove" class="md-nav__link">
    std::move
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stdforward-perfect-forwarding" class="md-nav__link">
    std::forward и Perfect Forwarding
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#copy-and-swap-idiom-raii" class="md-nav__link">
    Copy and Swap idiom, RAII
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typedef" class="md-nav__link">
    Команда typedef и ее применение
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    Упрощение шаблонов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    Работа с указателями
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typedef-typename" class="md-nav__link">
    typedef typename
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#typedef_1" class="md-nav__link">
    typedef и шаблонные аргументы
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#using-typedef" class="md-nav__link">
    using вместо typedef
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="c">Возможности современного c++</h1>
<p>Движок <code>Unreal Engine</code> разрабатывается профессиональными программистами очень высокого уровня. Они прекрасно владеют языком <code>с++</code> и его возможностями. Многие из них учились в лучших университетах мира и общались с лучшими специалистами в своем классе. Врятли то-же самое можно сказать о новичках, желающих программировать под <code>Unreal</code>. Для них эта статья может стать очень хорошим подспорьем в работе.</p>
<p>Когда я сам учился программировать под <code>Unreal Engine</code>, мне очень сильно помогли статьи с википедии, которые я рекомендую к ознакомлению каждому читателю.</p>
<p><a href="https://ru.wikipedia.org/wiki/C%2B%2B11">Википедия, возможности с++11.</a></p>
<p><a href="https://ru.wikipedia.org/wiki/C%2B%2B14">Википедия, возможности с++14.</a></p>
<p><a href="https://ru.wikipedia.org/wiki/C%2B%2B17">Википедия, возможности с++17.</a></p>
<p>На википедии приведены все возможности современного <code>с++</code> от версии к версии. К сожалению описаны они там крайне скупо и без подробностей, но это все еще крайне хороший источник информации.</p>
<p>Несмотря на то, что моя книга посвящена <code>Unreal</code>, в этой статье я буду работать в обычном <code>hello world</code> приложении, просто потому что так удобнее проводить тесты.</p>
<p>Большая часть тем, которые я рассматриваю в этой статье, относится к одной большой категории, под названием "метапрограммирование".</p>
<h2 id="_1">Препроцессор</h2>
<p>Компилятор <code>с++</code> поставляется вместе с препроцессором, который обрабатывает исходный код программы до того, как произойдет компиляция.</p>
<p>Директивы вида <code>#include</code>, <code>#define</code>, а так-же директивы шаблонов обрабатываются препроцессором. Некоторые операторы, например <code>sizeof</code> тоже обрабатываются препроцессором и заменяются на статичное  число. Об этом я знал всегда, но решил <a href="https://stackoverflow.com/a/2615205/2574125">проверить</a>.</p>
<p><a class="glightbox" href="../images/3f0fe91df25d47f6d768370fad8484f9.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3f0fe91df25d47f6d768370fad8484f9.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3f0fe91df25d47f6d768370fad8484f9.png" /></a></p>
<p>Таким образом <code>с++</code> код делится на две категории - <code>runtime</code> и <code>compile time</code>.
<code>runtime</code> код срабатывает в момент работы уже скомпилированного приложения, а код <code>compile time</code> срабатывает в момент компиляции.</p>
<p>Операторы вида <code>decltype, auto, constexpr</code> и многие другие, например шаблон <code>tuple</code>, появившиеся в современном <code>с++</code> - это операторы <code>compile time</code>.
Автоматическое определение типа через <code>auto</code> заменяется препроцессором на вполне конкретный тип. Так-же происходит и с <code>constexpr</code> переменными, шаблонными функциями и кортежами.</p>
<p>Очевидно, что шаблонная функция разделяется препроцессором на столько функций, сколько перегрузок требуется системе.</p>
<p>Почти все нововведения (а может и вообще все) современного с++ относятся к раширению возможностей препроцессора. Основное ядро языка <code>с++</code> практически не меняется с <code>98</code> года.</p>
<p>Зная этот простой факт, вы очень легко сможете понять операторы, с которыми мы столкнемся в этой статье. Потому что почти все они обрабатываются в <code>compile time</code>.</p>
<h2 id="_2">Области действия внутри функций</h2>
<p>В<code>c++</code>области действия переменных внутри функций и методов отделяются кавычками <code>{}</code>.
Объекты, созданные в одной области - не доступны из других. Это позволяет, в рамках одной и той-же функции, иметь несколько переменных с одним и тем-же названием.</p>
<p>Я довольно часто пользуюсь этим трюком, а потому не хотел бы, чтобы он вас смущал.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3109ce0397ba2f336cd74c4c775d0b9c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3109ce0397ba2f336cd74c4c775d0b9c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3109ce0397ba2f336cd74c4c775d0b9c.png" /></a></p>
<p>В приведенном фрагменте кода используется три переменные с названием <code>a</code>.</p>
<h2 id="_3">Пространства имен</h2>
<p>Пространства имен задаются ключевым словом <code>namespace</code> и являются блоками функций, переменных и классов, которые объединены общей областью действия<code>{}</code>
Формат:
<div class="highlight"><pre><span></span><code><span class="k">namespace</span><span class="w"> </span><span class="nn">NAME</span><span class="p">{}</span>
</code></pre></div>
Пространство имен может быть вложенным, но оно всегда должно задаваться в глобальной области действия. Пространства имен нельзя вкладывать в функции.</p>
<p>Для использование пространства имен используется тот-же оператор, который дает доступ к <code>static</code> методам - <code>::</code>.
<div class="highlight"><pre><span></span><code><span class="k">namespace</span><span class="w"> </span><span class="nn">DG</span><span class="p">{</span><span class="w"> </span><span class="c1">// Demo Namespace</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">int_summ</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">namespace</span><span class="w"> </span><span class="nn">NESTED</span><span class="p">{</span><span class="w"> </span><span class="c1">// Nested Namespace</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">mult</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DG::a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">DG</span><span class="o">::</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DG::int_summ(3, 5) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">DG</span><span class="o">::</span><span class="n">int_summ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DG::NESTED::a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">DG</span><span class="o">::</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DG::NESTED::mult(3, 5) = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">DG</span><span class="o">::</span><span class="n">NESTED</span><span class="o">::</span><span class="n">mult</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/49c05ca3f7bbb5aa793fea567a39c9dd.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="49c05ca3f7bbb5aa793fea567a39c9dd.png" auto_="auto;" display="block;" margin:="margin:" src="../images/49c05ca3f7bbb5aa793fea567a39c9dd.png" /></a></p>
<p>Пространства имен рекомендуют использовать вместо синглтонов.</p>
<p>Синглтон представляет из себя не более чем глобальный объект, объединяющий изменяющиеся тем или иным образом данные. Абсолютно ту-же самую задачу может выполнять и пространство имен, причем без необходимости создания отдельного объекта, а следовательно - без проблем, связанных с необходимостью его удалять, очищая память.
<div class="highlight"><pre><span></span><code><span class="k">namespace</span><span class="w"> </span><span class="nn">SGRepl</span><span class="p">{</span><span class="w"> </span><span class="c1">// namespace, used like singleton</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">add_summ</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="n">summ</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">summ</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_summ</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">summ</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">SGRepl</span><span class="o">::</span><span class="n">add_summ</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">SGRepl</span><span class="o">::</span><span class="n">add_summ</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">SGRepl</span><span class="o">::</span><span class="n">add_summ</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;SGRepl::get_summ() = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SGRepl</span><span class="o">::</span><span class="n">get_summ</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/6fd531f789ba131da803b9f1aa8f47a3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6fd531f789ba131da803b9f1aa8f47a3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6fd531f789ba131da803b9f1aa8f47a3.png" /></a></p>
<p>При таком подходе, данные находящиеся внутри пространства имен - остаются изолированными и не конфликтуют с другими участками кода.</p>
<p>Таким способом в Unreal Engine реализована <a href="https://docs.unrealengine.com/5.0/en-US/tasks-systems-in-unreal-engine/">система тасков</a>, которые объединены в  пространство <code>UE::Tasks</code>.</p>
<h2 id="using-namespace"><code>using namespace</code> и пространства имен</h2>
<p>Поскольку писать имя пространства всякий раз при обращении к его данным не всегда удобно - можно использовать <code>using namespace</code>:
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">NamespaceName</span><span class="p">;</span>
</code></pre></div>
Данная команда объединяет область действия переданного пространства имен и область действия, в которой был осуществлен ее вызов.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">SGRepl</span><span class="p">;</span>
<span class="w">        </span><span class="n">add_summ</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="w">        </span><span class="n">add_summ</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="n">add_summ</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;SGRepl::get_summ() = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get_summ</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/88ce60bf1ceb496f8524c18c2ca690f2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="88ce60bf1ceb496f8524c18c2ca690f2.png" auto_="auto;" display="block;" margin:="margin:" src="../images/88ce60bf1ceb496f8524c18c2ca690f2.png" /></a></p>
<p>Вне области действия ключевого слова <code>using</code> использование префикса пространства имен все так-же требуется.</p>
<p><a class="glightbox" href="../images/3984301514cf1081b67dbc11a01e632d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3984301514cf1081b67dbc11a01e632d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3984301514cf1081b67dbc11a01e632d.png" /></a></p>
<p>Наиболее популярным применением <code>using namespace</code> является <code>using namespace std</code>. Я крайне не рекомендую использовать <code>using namespace std</code> в <code>Unreal Engine</code>, потому что код стандартной библиотеки будет конфликтовать с кодом движка (названия некоторых функций, классов). Использование конструкции <code>using namespace std</code> является крайне дурным тоном.</p>
<h2 id="_4">Шаблон для печати типа переменной</h2>
<p>Иногда надо напечатать тип переменной. Для этого есть два способа, простой и чуть сложнее.</p>
<p>Простой способ печати типа переменной выглядит так:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ci</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">ci</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/9c5ca6f03156b1bea08d128bead1aaac.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9c5ca6f03156b1bea08d128bead1aaac.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9c5ca6f03156b1bea08d128bead1aaac.png" /></a></p>
<p>Главная проблема такого кода в том, что тип не печатается полностью. А это у нас - <code>const int</code>. Если вам нужен полный тип переменной, а иногда он бывает ОЧЕНЬ нужен, есть второй способ решения - использовать под эти задачи продвинутый шаблон, найденный мной на <a href="https://stackoverflow.com/a/20170989/2574125">stackoverflow</a>:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string_view&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">type_name</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">prefix</span><span class="p">,</span><span class="w"> </span><span class="n">suffix</span><span class="p">;</span>
<span class="cp">#ifdef __clang__</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__PRETTY_FUNCTION__</span><span class="p">;</span>
<span class="w">    </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;auto type_name() [T = &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">;</span>
<span class="cp">#elif defined(__GNUC__)</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__PRETTY_FUNCTION__</span><span class="p">;</span>
<span class="w">    </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;constexpr auto type_name() [with T = &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">;</span>
<span class="cp">#elif defined(_MSC_VER)</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__FUNCSIG__</span><span class="p">;</span>
<span class="w">    </span><span class="n">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;auto __cdecl type_name&lt;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&gt;(void)&quot;</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">name</span><span class="p">.</span><span class="n">remove_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">name</span><span class="p">.</span><span class="n">remove_suffix</span><span class="p">(</span><span class="n">suffix</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ci</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ci</span><span class="p">))</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/da09a46504c45a4be7752adf87883d37.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="da09a46504c45a4be7752adf87883d37.png" auto_="auto;" display="block;" margin:="margin:" src="../images/da09a46504c45a4be7752adf87883d37.png" /></a></p>
<p>Как вы видите, этот подход позволяет печатать даже <code>lvalue</code> и <code>rvalue</code> значения. Рекомендую добавить эту функцию в личную библиотеку для дальнейшего использования.</p>
<p>В последующих главах я буду использовать этот шаблон в коде.</p>
<h2 id="auto"><code>auto</code></h2>
<p>Ключевое слово <code>auto</code> означает, что препроцессор, на этапе компиляции, должен определить тип для выражения, а потом подставить его вместо <code>auto</code>.
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// will be int</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a type = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/a665c2ebb1f2844da9ecbe221be5fcfb.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a665c2ebb1f2844da9ecbe221be5fcfb.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a665c2ebb1f2844da9ecbe221be5fcfb.png" /></a></p>
<p>Данное ключевое слово добавляет удобства при разработке функций. Особенно если такие функции возвщащают что-то уж совершенно ужасное и разработчик не хочет это писать, к примеру: <code>TSoftObjectPtr&lt;UInputMappingContext&gt;</code> (бывают куда более тяжелые случаи, тот-же <code>TArray&lt;TPair&lt;FString, FMLAdapterDescription&gt;&gt;</code>).</p>
<p>Так-же ключевое слово <code>auto</code> может быть использовано для замещения шаблонов. Все таки создание шаблонов может создавать сложности для новичков. Можете использовать <code>auto</code> и все будет работать. Рассмотрим такой случай.
<div class="highlight"><pre><span></span><code><span class="c1">// auto function</span>
<span class="k">auto</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;summ = &quot;</span><span class="o">&lt;&lt;</span><span class="n">summ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">4.3f</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/192a97e7506ffda38923ea9b44c23917.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="192a97e7506ffda38923ea9b44c23917.png" auto_="auto;" display="block;" margin:="margin:" src="../images/192a97e7506ffda38923ea9b44c23917.png" /></a></p>
<p>Как вы видите, такой код вполне работоспособен.</p>
<p>Препороцессор, на этапе компиляции, сгенерирует для функции <code>summ</code> отдельную реализацию под каждый уникальный тип, с которым она была вызвана.</p>
<p>Ключевое слово <code>auto</code> обрасывает <code>change value</code> квалификаторы присвоенные выражению, а именно: <code>const</code>, <code>mutable</code> и <code>volatle</code>, <code>&amp;</code>, <code>&amp;&amp;</code>.
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c1">// no more const here, no need to dereference</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;b=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/6bbcd04bfd0254a1f04aafd0d70ccad0.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6bbcd04bfd0254a1f04aafd0d70ccad0.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6bbcd04bfd0254a1f04aafd0d70ccad0.png" /></a></p>
<h2 id="decltype"><code>decltype</code></h2>
<p>Оператор <code>decltype</code> превращается препроцессором в тот тип данных, который описывает переданное ему выражение. Его работа схожа с <code>auto</code>, хотя метод вызова и отличается.
<div class="highlight"><pre><span></span><code><span class="k">decltype</span><span class="p">(</span><span class="mi">3</span><span class="o">+</span><span class="mf">4.5f</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// will be replaced with: float a = 2.0f;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a type = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/45f46d6360c0acaf9d071d1855b1d575.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="45f46d6360c0acaf9d071d1855b1d575.png" auto_="auto;" display="block;" margin:="margin:" src="../images/45f46d6360c0acaf9d071d1855b1d575.png" /></a></p>
<p>Различие между <code>decltype</code> и <code>auto</code> сводится к форме возвращаемого значения: результат использования <code>auto</code> теряет <code>cv</code> квалификаторы типов: <code>const</code>, <code>volatile</code>, <code>mutable</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, а результат использования <code>decltype</code> сохраняет эти квалификаторы.</p>
<p><a class="glightbox" href="../images/163a129fe12c20843a8800041261141b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="163a129fe12c20843a8800041261141b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/163a129fe12c20843a8800041261141b.png" /></a></p>
<h2 id="decltypeauto"><code>decltype(auto)</code></h2>
<p>Иногда оба выражения сочетаются. Дело в том, что <code>decltype</code> всегда требует внутрь себя то или иное выражение, на основе которого будет определен тип и уже этот тип будет присвоен. Выражение, переданное в <code>decltype</code>, будет вычислено первым.
<div class="highlight"><pre><span></span><code><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="o">???</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can&#39;t write like this</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// but we can write like this!</span>
<span class="c1">// it will be replaced by: int a = 3;</span>
</code></pre></div>
При таком использовании оператора <code>decltype</code> сохраняются все его преимущества, то есть у присвоенного типа остаются все квалификаторы <code>const, rvalue, lvalue</code> и т.д.</p>
<p>Именно поэтоу такое сочетание операторов используется в функциях.
<div class="highlight"><pre><span></span><code><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// return rvalue</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/a9e9755783c8e94c44440a1dd5d8b31b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a9e9755783c8e94c44440a1dd5d8b31b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a9e9755783c8e94c44440a1dd5d8b31b.png" /></a></p>
<p>Как вы видите, <code>rvalue</code> квалификатор сохранен.</p>
<p>Та-же функция, но без <code>decltype(auto)</code> выдает просто <code>int</code> без квалификаторов.
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// return rvalue</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/9a2f2e3984a6d7c878d53a8826a6f4d5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9a2f2e3984a6d7c878d53a8826a6f4d5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9a2f2e3984a6d7c878d53a8826a6f4d5.png" /></a></p>
<h2 id="decltype_1"><code>decltype</code> и указатели на функции</h2>
<p>Если передать в <code>decltype</code> простую функцию, то вместо ее возвращаемого типа оператор возвратит нам указатель на эту функцию.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">decltype_n_func</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== decltype and functions ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">decltype_n_func</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/976e514e2df53fe4cbf10b87fc247c24.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="976e514e2df53fe4cbf10b87fc247c24.png" auto_="auto;" display="block;" margin:="margin:" src="../images/976e514e2df53fe4cbf10b87fc247c24.png" /></a></p>
<p>Если функция является шаблоном, то обрабатывать ее надо так:
<div class="highlight"><pre><span></span><code><span class="c1">// auto in template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">){</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== decltype and functions ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="o">&amp;</span><span class="n">summ</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/ce5826ccbe0dc93d18586876ff7614d8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ce5826ccbe0dc93d18586876ff7614d8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ce5826ccbe0dc93d18586876ff7614d8.png" /></a></p>
<h2 id="decltype_2"><code>decltype</code> для опеределения возвращаемого типа функции</h2>
<p>Иногда нам надо получить не указатель на функцию, а ее возвращаемый тип. Для этого, просто передайте вызов функции, вместе с ее аргументами, в лямбду. Не беспокойтесь, к запуску самой функции это не приведет. Хотя код и будет выглядеть странно для тех, кто не знает о таком трюке.
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;type_name.h&quot;</span><span class="c1"> // used to print type names</span>
<span class="c1">// auto in template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">){</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">decltype_n_func</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> Function is CALLED! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== decltype and functions ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;decltype_n_func return value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">decltype_n_func</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;summ return value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">4.5f</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/542b47fd52dd686f1a20871067bdbc40.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="542b47fd52dd686f1a20871067bdbc40.png" auto_="auto;" display="block;" margin:="margin:" src="../images/542b47fd52dd686f1a20871067bdbc40.png" /></a></p>
<p>Обратите внимание, что функция <code>decltype_n_func</code> имеет внутри себя вывод собщения:
<code>Function is CALLED!</code>. Которое, тем не менее, не появляется, после отправки этой функции в <code>decltype</code>. Вместо этого, <code>decltype</code>, выдает нам возвращаемый тип данной функции, а именно - <code>int</code>.
Так-же для определения возвращаемого типа указателя можно использовать <code>std::invoke_result</code>. Поскольку <code>decltype</code> как раз и возвращает указатель на функцию, в этом примере не обращайте на него внимания.
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;type_name.h&quot;</span><span class="c1"> // used to print type names</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">decltype_n_func</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> Function is CALLED! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">decltype_n_func_args</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> Function is CALLED! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a + b </span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== std::invoke_result ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// decltype(&amp;decltype_n_func_args) - generate function pointer</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">decltype_n_func</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">bfr</span><span class="p">;</span><span class="w"> </span><span class="c1">// basic function return type</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">invoke_result</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">decltype_n_func_args</span><span class="p">),</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">tfr</span><span class="p">;</span><span class="w"> </span><span class="c1">// template function return type</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;basic function return type is = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">tfr</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;template function return type is = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">tfr</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h2 id="-">Указание конечного возвращаемого типа <code>-&gt;</code></h2>
<p>В шаблонных функциях, использующих ключевое слово <code>auto</code>, разумно будет использовать указание возвращаемого значения через <code>-&gt;</code>.
Формат шаблона, с указанным возвращаемым значением выглядит так:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">FuncName</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">Arg1</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">Arg1</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// your code goes here</span>
<span class="p">}</span>
</code></pre></div>
Это нужно, чтобы показать системе, на основе каких именно значений будет получен результат.</p>
<p>В<code>c++</code>17 делать такие трюки не обязательно, указание конечного результата функции сохранено в языке для совместимости.</p>
<p>Пример использования:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">){</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;summ = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b262dce8619f3203a16ef9d5b3232d74.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b262dce8619f3203a16ef9d5b3232d74.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b262dce8619f3203a16ef9d5b3232d74.png" /></a></p>
<p>Вышеуказанный код будет работать и без <code>-&gt;decltype(a+b)</code>, в с++17 указание конечного типа не обязательно.
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;summ = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">summ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/dfd012531cd1a0d43156a87b457977ab.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="dfd012531cd1a0d43156a87b457977ab.png" auto_="auto;" display="block;" margin:="margin:" src="../images/dfd012531cd1a0d43156a87b457977ab.png" /></a></p>
<h2 id="forward-declaration"><code>Forward Declaration</code></h2>
<p>В заголовочных файлах некоторых классов <code>Unreal Engine</code> можно наткнуться на странные конструкции вида <code>class ClassName;</code>.
Эти конструкции называются <code>Forward Declaration</code>.</p>
<p><a class="glightbox" href="../images/d1052fcbaafac85cf6c09592213a0b33.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="d1052fcbaafac85cf6c09592213a0b33.png" auto_="auto;" display="block;" margin:="margin:" src="../images/d1052fcbaafac85cf6c09592213a0b33.png" /></a></p>
<p>Операторы <code>Forward Declaration</code> позволяют избежать проблемы с цикличной зависимостью … то есть с <code>cyclic dependancy</code>.
Как это выглядит.</p>
<p>Предположим есть два класса, зависимых друг от друга. Причем классы эти расположены в двух разных файлах.
<div class="highlight"><pre><span></span><code><span class="c1">//file Class1.h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Class2.h&quot;</span><span class="c1"> // include second class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassName1</span><span class="p">{</span>
<span class="w">    </span><span class="n">ClassName2</span><span class="w"> </span><span class="n">VariableC2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//file Class2.h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Class1.h&quot;</span><span class="c1"> // include first class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassName1</span><span class="p">{</span>
<span class="w">    </span><span class="n">ClassName1</span><span class="w"> </span><span class="n">VariableC1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Между такими классами имеется т.н. <code>Cyclic Dependancy</code>. Система сборки не сможет понять, какой из этих классов надо скомпилировать первым. Потому что <code>ClassName1</code> ссылается на <code>ClassName2</code>, а <code>ClassName2</code> ссылается на <code>ClassName1</code>. Стандартными способами эту  проблему физически решить Не ВОЗМОЖНО.</p>
<p>Эта проблема решается  с помощью <code>Forward Declaration</code>. Вот как выглядит код с применением этой техники.
<div class="highlight"><pre><span></span><code><span class="c1">//file Class1.h</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Class2.h&quot;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassName1</span><span class="p">{</span>
<span class="w">    </span><span class="n">ClassName2</span><span class="w"> </span><span class="n">VariableC2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//file Class2.h</span>
<span class="c1">//#include &quot;Class1.h&quot; - don&#39;t need to include</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassName1</span><span class="p">;</span><span class="w"> </span><span class="c1">// forward declaration</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassName1</span><span class="p">{</span>
<span class="w">    </span><span class="n">ClassName1</span><span class="w"> </span><span class="n">VariableC1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
В этом коде циклической зависимости не будет, потому что системе сразу понятно, какой файл компилировать первым.</p>
<h2 id="constexpr"><code>constexpr</code></h2>
<p><code>const</code> гарантирует, что переменную не получится изменить из кода. Однако компилятор с++ не предпринимает никаких дополнительных оптимизаций, связанных с постоянством функций и переменных, даже если это было бы желательно. Все потому, что <code>const</code> это не конечный спецификатор. Его можно убрать у переменной, при необходимости.</p>
<p>Если требуется обеспечить реальную <code>compile time</code> постоянность для данных - используйте спецификатор <code>constexpr</code>
Спецификатор <code>constexpr</code> просчитывается на этапе компиляции, позволяя дополнительно оптимизировать код, во всем остальном он работает точно так-же как и оператор <code>const</code>.
<code>constexpr</code> может быть использован с переменными, функциями и конструкциями типа <code>if</code>.
<div class="highlight"><pre><span></span><code><span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c1">// will be replaced with const int a = 7</span>
</code></pre></div>
<code>constexpr</code> функции просчитываются в <code>compile time</code>, если вызывающее их выражение имеет спецификатор <code>constexpr</code>:
<div class="highlight"><pre><span></span><code><span class="c1">// constexpr function results will be calculated in compile-time if calling expression is constexpr</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">summ_cexpr</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">cexpr_summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">summ_cexpr</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span><span class="w"> </span><span class="c1">// will be replaced with: const int cexpr_summ = 7; at compile time</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;summ_cexpr = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cexpr_summ</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/76112f73e7b1e2af6ff5d0b449685f43.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="76112f73e7b1e2af6ff5d0b449685f43.png" auto_="auto;" display="block;" margin:="margin:" src="../images/76112f73e7b1e2af6ff5d0b449685f43.png" /></a></p>
<p><code>constexpr</code> оператор <code>if</code> заменяется на прямой код, если выражение, которое находится в этом операторе, возвращает <code>true</code>:
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// will be replaced by: std::cout&lt;&lt; &quot;a &gt; 3\n&quot;;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a &gt; 3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Чаще всего данный оператор используется с шаблонами. Во всяком случае в этой статье я использовал его с шаблонами.
<div class="highlight"><pre><span></span><code><span class="c1">// constexpr in template</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T2</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">summ_numerics</span><span class="p">(</span><span class="n">T1</span><span class="w"> </span><span class="n">num1</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="n">num2</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">num1</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">num2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">T1</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;summ_numerics(2, 3) = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">summ_numerics</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;summ_numerics(</span><span class="se">\&quot;</span><span class="s">Test</span><span class="se">\&quot;</span><span class="s">, </span><span class="se">\&quot;</span><span class="s">Test1</span><span class="se">\&quot;</span><span class="s">) = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">summ_numerics</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test1&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/965ce02a6fc3ac65e6d71b11d1bb5b83.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="965ce02a6fc3ac65e6d71b11d1bb5b83.png" auto_="auto;" display="block;" margin:="margin:" src="../images/965ce02a6fc3ac65e6d71b11d1bb5b83.png" /></a></p>
<p>Вышеуказанный код не скомпилируется, выдав кучу ошибок, если из условия шаблона убрать <code>constexpr</code>.</p>
<p><a class="glightbox" href="../images/5e0671e5cebc020e6c6685bd77b4cd35.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5e0671e5cebc020e6c6685bd77b4cd35.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5e0671e5cebc020e6c6685bd77b4cd35.png" /></a></p>
<h2 id="lambda">Автозапускаемая <code>Lambda</code></h2>
<p>В <code>Unreal Engine</code> вы можете столкнуться с таким кодом лямбды:
<div class="highlight"><pre><span></span><code><span class="p">[]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}();</span>
</code></pre></div>
Что это? Откуда здесь <code>()</code> и неужели это скомпиируется?
Да, скомпилируется (в <code>с++17</code>). Это всего-лишь сокращенный синтаксис. Кавычки тут отвечают за автоматический запуск лямбды сразу после ее создания.</p>
<p>Используя автозапуск можно передавать аргументы в лямбду. При этом выносить ее определение в отдельную переменную - не обязательно.
<div class="highlight"><pre><span></span><code><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}(</span><span class="mi">5</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b7c56b7ea0e67ea63092b2006d9176c5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b7c56b7ea0e67ea63092b2006d9176c5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b7c56b7ea0e67ea63092b2006d9176c5.png" /></a></p>
<p>Из лямбд, запускаемых автоматически, можно даже получать значения.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will run lambda with 2 arguments: 3 and 5</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;summ = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">summ</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/f9fd84b6cc6981e15487fc32211f92a6.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f9fd84b6cc6981e15487fc32211f92a6.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f9fd84b6cc6981e15487fc32211f92a6.png" /></a></p>
<h2 id="stdinvoke"><code>std::invoke</code></h2>
<p>Эта функция позволяет унифицированно вызывать лямбды, методы классов и указатели на функции. Но главное ее преимущество состоит в возможности вызова методов класса по указателю, не мучаясь с написанием обертки.</p>
<p>В <code>Unreal</code> сходим образом работают делегаты, а точнее часть их методов - <code>AddUobject, AddSP</code>, подробнее - в соответствующей статье.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SimpleTest</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">TestMethod</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test Method Called with A = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w">    </span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">SimpleTest</span><span class="w"> </span><span class="n">invokeTarget</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// call function using pointer</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SimpleTest</span><span class="o">::</span><span class="n">TestMethod</span><span class="p">,</span><span class="w"> </span><span class="n">invokeTarget</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test Method Returned A = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/a1b5c9014e3e8c78a47d9e96af5505b0.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a1b5c9014e3e8c78a47d9e96af5505b0.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a1b5c9014e3e8c78a47d9e96af5505b0.png" /></a></p>
<p>Для запуска лямбды используется схожий синтаксис:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">invoke</span><span class="p">(</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test Lambda Returned A = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/2ca71f4835dffbf52f79cb68e48d5142.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2ca71f4835dffbf52f79cb68e48d5142.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2ca71f4835dffbf52f79cb68e48d5142.png" /></a></p>
<h2 id="singleton-pattern">Singleton Pattern</h2>
<p>Классы типа <code>Singleton</code> используют особенность <code>static</code> переменных в <code>с++</code> хранить свое значение на протяжении всего времени работы приложения. В <code>Unreal Engine</code>, иногда, приходится создавать синглтоны. Например - <code>StyleSet</code> для <code>Slate</code> создается как <code>Singleton</code>, мы еще дойдем до этого.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Singleton</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Singleton</span><span class="p">(</span><span class="n">Singleton</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// no assignment constructor</span>
<span class="w">    </span><span class="n">Singleton</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Singleton</span><span class="w"> </span><span class="k">const</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// no assignment operator</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Singleton</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">instance</span><span class="w"> </span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">INSTANCE</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">INSTANCE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></p>
<h2 id="_5">Шаблоны</h2>
<p>Шаблоны в коде <code>Unreal</code> встречаются достаточно часто, поэтому прогнорировать такую тему в своих статьях я не могу.</p>
<h2 id="_6">Зачем нужны шаблоны?</h2>
<p>Все мы знаем, что <code>с++</code> это строго типизированный язык. Это создает для разработчика определенные проблемы. Даже не знаю стоит ли тут упоминать такую базовую вещ, как перегрузка функций. По идее вы должны про нее знать и без примеров.</p>
<p>Давайте рассмотрим необходимость наличия шаблонов на примере класса.</p>
<p>Рассмотрим класс следующего вида:
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Data</span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="n">Data</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">inValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="n">inValue</span><span class="p">){};</span>
<span class="w">    </span><span class="c1">// overload operator `=` for float assignment</span>
<span class="w">    </span><span class="n">Data</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Val</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Val</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">getValue</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Это базовый контейнер для данных типа <code>float</code>.
Что если бы я хотел сделать аналогичный класс но для данных типа <code>int</code> или <code>std::string</code>? В языке с++ НЕТ перегрузки классов. То есть второй класс <code>Data</code> задать я не смогу (в отличие от функции).</p>
<p><a class="glightbox" href="../images/47b64a523e3045493ca528a3a446010e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="47b64a523e3045493ca528a3a446010e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/47b64a523e3045493ca528a3a446010e.png" /></a></p>
<p>(на самом деле класс с тем-же именем добавить можно через операторы препроцессора <code>#ifndef #define #endif</code>  или просто используя другой конструктор (с аргументом <code>std::string</code>, например), но дублировать этот класс всякий раз под отдельный тип данных - очень плохая идея)</p>
<p>Вернемся к нашей задаче. Требуется сделать из класса <code>Data</code> контейнер для любых типов данных. Как же быть? Использовать шаблоны.</p>
<p>Если вынести тип хранимого значения в ключевое слово <code>template</code>, то получится шаблон.
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">StoredType</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Data</span><span class="p">{</span>
<span class="w">    </span><span class="n">StoredType</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="c1">// if constructor value is template class and because of it - unknown - just use template class with ()</span>
<span class="w">    </span><span class="c1">// in my case it&#39;s StoredType() to create &quot;default&quot; value for variable</span>
<span class="w">    </span><span class="n">Data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StoredType</span><span class="w"> </span><span class="n">inValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StoredType</span><span class="p">())</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="n">inValue</span><span class="p">){};</span>
<span class="w">    </span><span class="c1">// overload operator `=` for float assignment</span>
<span class="w">    </span><span class="n">Data</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StoredType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Val</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Val</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//get_instance().Value = Val;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">StoredType</span><span class="w"> </span><span class="n">getValue</span><span class="p">(){</span>
<span class="w">        </span><span class="c1">//return get_instance().Value;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Data Value = %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/aabdee895c59276e30a1bca99a0e7c81.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="aabdee895c59276e30a1bca99a0e7c81.png" auto_="auto;" display="block;" margin:="margin:" src="../images/aabdee895c59276e30a1bca99a0e7c81.png" /></a></p>
<p>Обратите внимание, что для присваивания значения "по умолчанию" в конструкторе я использую конструкцию <code>StoredType()</code>, которая задается в шаблоне. Она работает и с встроенными типами, вроде <code>int, float</code>.
Более того, контейнер <code>Data</code> может запросто работать и с типом <code>std::string</code>.</p>
<p><a class="glightbox" href="../images/fdbbf0b91c115f9f6cb242645ef0cd7c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fdbbf0b91c115f9f6cb242645ef0cd7c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fdbbf0b91c115f9f6cb242645ef0cd7c.png" /></a></p>
<p><a class="glightbox" href="../images/5136bcc15cae814ed530035ae7c3880e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5136bcc15cae814ed530035ae7c3880e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5136bcc15cae814ed530035ae7c3880e.png" /></a></p>
<h2 id="_7">Синтаксис шаблонов</h2>
<p>Базовый вид шаблона задается следующим образом:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Name1</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Name2</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Name3</span><span class="o">&gt;</span>
</code></pre></div>
Однако, общая формула шаблона, которую я смог вывести, куда сложнее для восприятия.
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span>
<span class="w">    </span><span class="c1">// begin</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Name1</span><span class="p">,</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Name2</span><span class="p">,</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">Name3</span><span class="p">,</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Nested_AnyArgs</span><span class="p">,</span><span class="w"> </span><span class="c1">// Вложенный шаблон с любым кол-вом аргументов</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Nested_TwoArgs</span><span class="p">,</span><span class="w"> </span><span class="c1">// Вложенный шаблон с двумя аргументами, один из которых</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">TypeWithDefault</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="c1">// Шаблоны могут иметь тип, присвоенный &quot;по умолчанию&quot;. Все параметры, идущие после шаблона с типом &quot;по умолчанию&quot;, должны так-же иметь типы &quot;по умолчанию&quot;. Однако это правило не относится к параметрам у которых кол-во аргументов не ограничено.</span>
<span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="p">,</span><span class="w"> </span><span class="c1">// Параметры шаблонов могут принимать неопределенное кол-во аргументов (tuples), которые будут помещены в переменную Args. Параметр с бесконечным кол-вом аргументов должен идти последним в списке.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">Name3</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Name3</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// Параметр enable_if позволяет контролировать типы, которые допустимы для конкретного шаблона</span>
<span class="w">    </span><span class="c1">// end</span>
<span class="o">&gt;</span>
</code></pre></div>
<code>Name1</code>, <code>Name3</code>и так далее - это псевдонимы классов, которые пользователь передаст в шаблон.</p>
<p>Вложенные шаблоны задаются конструкцией <code>template&lt;typename, typename = int&gt; class Nested_TwoArgs</code>. Эта конструкция позволит обрабатывать форматы вроде <code>std::vector</code>. Однако этот подход не избавляет разработчика от необходимости запрашивать параметр типа элемента. Все дело в том, что такой код работать не будет:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TemplatedType</span><span class="o">&gt;</span>
</code></pre></div>
Дело в том, что получить доступ к вложенному типу, а это <code>ItemType</code> система не даст. Поэтому вложенные шаблоны всегда задаются такой конструкцией:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TemplatedType</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ItemType</span><span class="o">&gt;</span>
</code></pre></div>
Тут <code>ItemType</code> передается как последний аргумент шаблона, в то время как сам вложенный шаблон не имеет явно заданной типизации - <code>template&lt;typename&gt;</code>.
Если количество аргументов вложенного шаблона неизвестно - можете использовать такую вставку - <code>template&lt;typename...&gt;</code>.
Шаблон может задаваться как перед функцией так и перед классом, но работает он всегда одинаково - формирует временный псевдоним для типа в рамках области видмости класса или функции.</p>
<h3 id="stdenable_if"><code>std::enable_if</code></h3>
<p><code>std::enable_if</code> проверяет данные, переданные шаблону, на соответствие определенным условиям. Если условие, указанное в <code>std::enable_if</code> возвращает <code>true</code> то результат выполнения шаблона будет структурой, с полем <code>using type = void</code>, иначе - шаблон сгенерирует пустую структуру, в которой нет поля <code>::type</code>.
Формат выражения:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">boolean_check</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="c1">// returns void as type if boolean_check is true, otherwise - returns nothing</span>
<span class="c1">// there is exactly type version of template -</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">boolean_check</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// this can be used with function return value, but only in case if function returns void</span>
</code></pre></div>
Пример использования <code>std::enable_if</code> в шаблоне.
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;type_traits&gt;</span><span class="c1"> // std::is_same, std::is_arithmetic</span>
<span class="c1">// Enable If test in template</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ValueType</span><span class="p">,</span><span class="w"> </span><span class="c1">// type</span>
<span class="k">typename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">ValueType</span><span class="o">&gt;::</span><span class="n">type</span><span class="w">  </span><span class="c1">// check if type is arithmetic</span>
<span class="c1">// converts to: typename = typename void on success</span>
<span class="o">&gt;</span>
<span class="n">ValueType</span><span class="w"> </span><span class="n">SummValues</span><span class="p">(</span><span class="n">ValueType</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w">  </span><span class="n">ValueType</span><span class="w"> </span><span class="n">B</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// summ only int or float</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">){</span><span class="w"> </span><span class="c1">// different way to check if we working with Exact types</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ValueType</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SummValues</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SummValues = %d&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Summ</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
В этом примере я создал функцию <code>SummValues</code>, которая складывает два значения типа <code>ValueType</code>. Но мы знаем, что оператор сложения <code>+</code> не доступен для всех классов, например сложить две переменные типа <code>std::string</code> не получится. Поэтому я добавил в функцию, прямо в тело шаблона, проверку на то, является ли переданный шаблону тип - арифметическим. Для этого я использовал трейт <code>is_arithmetic</code> вместе с модификатором <code>std::enable_if</code>, который блокирует компиляцию, если переданные аргументы не возвращают <code>true</code>.
Давайте передадим в эту функцию какой-нибудь не арифметический тип. Например вышеупомянутый <code>std::string</code>.</p>
<p><a class="glightbox" href="../images/b4066706be02932b9a3e5e5e72959262.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b4066706be02932b9a3e5e5e72959262.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b4066706be02932b9a3e5e5e72959262.png" /></a></p>
<p>Сразу появилась ошибка и компиляция больше не проходит.</p>
<p><a class="glightbox" href="../images/b7161718ce8e55551cb793b2c44c398c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b7161718ce8e55551cb793b2c44c398c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b7161718ce8e55551cb793b2c44c398c.png" /></a></p>
<p>Именно так работает трейт <code>std::enable_if</code>.
Теперь перейдем в тело функции. Что если тип является арифметическим, например <code>double</code>, но мы бы не хотели, чтобы его можно было складывать внутри функции. Как его отфильтровать?
Для этого я применил проверку, вызвав сравнение типов <code>std::is_same&lt;ValueType, int&gt;::value</code>.
Отмечу, что проверку на соответствие типов можно провести и вот так:
<div class="highlight"><pre><span></span><code><span class="k">typeid</span><span class="p">(</span><span class="n">ValueType</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
</code></pre></div>
Давайте посмотрим, что случится, если передать в функцию тип <code>double</code>.
<div class="highlight"><pre><span></span><code><span class="kt">double</span><span class="w"> </span><span class="n">Summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SummValues</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">4.3</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;SummValues = %f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Summ</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/e93bd7cfcb386a6004108edd6da0138d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e93bd7cfcb386a6004108edd6da0138d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e93bd7cfcb386a6004108edd6da0138d.png" /></a></p>
<p>Компиляция этого кода выводит значение в <code>0</code>.</p>
<p><a class="glightbox" href="../images/7f9287673023f46b89a17dbadba999ab.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7f9287673023f46b89a17dbadba999ab.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7f9287673023f46b89a17dbadba999ab.png" /></a></p>
<p><code>std::enable_if</code> может работать не только как модификатор шаблона, но так-же и в качестве модификатора для методов или функций.
<div class="highlight"><pre><span></span><code><span class="c1">// Enable If with function</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">enable_if_t</span><span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="w"> </span><span class="n">en_func</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">en_func</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3a05cd2e84cc70f02ba7371f8a3a5601.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3a05cd2e84cc70f02ba7371f8a3a5601.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3a05cd2e84cc70f02ba7371f8a3a5601.png" /></a></p>
<p><a class="glightbox" href="../images/16a324d6ca885592ea9aae213af88ae2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="16a324d6ca885592ea9aae213af88ae2.png" auto_="auto;" display="block;" margin:="margin:" src="../images/16a324d6ca885592ea9aae213af88ae2.png" /></a></p>
<p>Обратите внимание, что я не использую <code>return</code> в функции <code>en_func</code>, потому что шаблон <code>std::enable_if_t</code> заменяется препроцессором.</p>
<h2 id="_8">Шаблон с переданным значением</h2>
<p>Шаблоны могут содержать в себе не только типы, но и значения. А так-же могут эти значения передавать. К примеру следующий код будет вполне работоспособен:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">MyType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">TypeSize</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DataArray</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">MyType</span><span class="w"> </span><span class="n">Items</span><span class="p">[</span><span class="n">TypeSize</span><span class="p">];</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="n">MyType</span><span class="o">*</span><span class="w"> </span><span class="n">getItems</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Items</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// get item by index</span>
<span class="w">    </span><span class="n">MyType</span><span class="w"> </span><span class="n">getItem</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">isOutOfRange</span><span class="p">(</span><span class="n">Index</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">MyType</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Items</span><span class="p">[</span><span class="n">Index</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// sets index value</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">SetItem</span><span class="p">(</span><span class="n">MyType</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">isOutOfRange</span><span class="p">(</span><span class="n">Index</span><span class="p">)){</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">[Error] Value Out Of Range! </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Items</span><span class="p">[</span><span class="n">Index</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// check if out of range</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isOutOfRange</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Index</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">TypeSize</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// сокращенный if. гуглите. Формат - std::string ab0 = (A&gt;0)? &quot;da&quot; : &quot;net&quot;;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">DataArray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">Strings</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DataArray</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">Strings</span><span class="o">-&gt;</span><span class="n">SetItem</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// print out array</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Strings</span><span class="o">-&gt;</span><span class="n">getItem</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">[%d] = %s&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">item</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">Strings</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/35fa1f6c931f349df476c6f42e9b30a1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="35fa1f6c931f349df476c6f42e9b30a1.png" auto_="auto;" display="block;" margin:="margin:" src="../images/35fa1f6c931f349df476c6f42e9b30a1.png" /></a></p>
<p>Тут я использовал параметр <code>TypeSize</code> как часть шаблона.</p>
<p>В чистом виде передача значений через шаблон выглядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// Passing args thru template</span>
<span class="c1">// call like this: SummFromTemplate&lt;1,3&gt;();</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">SummFromTemplate</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;summ is = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SummFromTemplate</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/4bdf284951d595ef527d47e2cb9638aa.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4bdf284951d595ef527d47e2cb9638aa.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4bdf284951d595ef527d47e2cb9638aa.png" /></a></p>
<p>Как вы видите, тут я передаю значения не в <code>()</code> функцию, а непосредственно в шаблон через <code>&lt;&gt;</code>.</p>
<h2 id="auto_1"><code>auto</code> в шаблонах</h2>
<p>В с++ 17 добавили возможность добавлять <code>auto</code> в шаблоны. Модификтор <code>auto</code> используется в шаблонах для предопределения типа переданного значения. Он не работает с типами, он работает со значениями.</p>
<p>Приведенный выеш код может быть переписан с учетом модификатора <code>auto</code>:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">SummFromTemplate</span><span class="p">()</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;summ = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SummFromTemplate</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3f</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/0bdfaef34386d93c90393165914f0491.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0bdfaef34386d93c90393165914f0491.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0bdfaef34386d93c90393165914f0491.png" /></a></p>
<p>Так-же допустимо использование <code>auto</code> в шаблонах классов и структур:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">auto</span><span class="w"> </span><span class="n">V</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AutoTest</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">decltype</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">AutoTest</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="w">    </span><span class="n">AutoTest</span><span class="o">&lt;</span><span class="mf">3.2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A1</span><span class="p">;</span>
<span class="w">    </span><span class="n">AutoTest</span><span class="o">&lt;</span><span class="sc">&#39;c&#39;</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A2</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A type = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A1 type = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">A1</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A2 type = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">type_name</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="w"> </span><span class="n">A2</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="p">)</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/8cb6206ce84b4b5e90052dea2f1781ac.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="8cb6206ce84b4b5e90052dea2f1781ac.png" auto_="auto;" display="block;" margin:="margin:" src="../images/8cb6206ce84b4b5e90052dea2f1781ac.png" /></a></p>
<h2 id="typename-class">Различия между <code>typename</code> и <code>class</code> в шаблоне</h2>
<p>В чем разница между следующими шаблонами?
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
</code></pre></div>
Ни в чем. В с++ стандарта 17 разницы нет. Раньше была. Ключевое слово <code>typename</code> следовало употреблять для вложенных шаблонов, например так:
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
</code></pre></div>
Сейчас тоже ничто не мешает следовать этому правилу, дабы избегать тавтологий.</p>
<p>Я использую то, что кажется мне наиболее логичным.</p>
<h2 id="_9">Вложенные шаблоны</h2>
<p>Что если в шаблон надо отправить не просто тип, а шаблонный тип, к примеру <code>std::vector</code>. Как в этом случае должен строиться формат шаблона?
<div class="highlight"><pre><span></span><code><span class="c1">// Nested Template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ItemType</span><span class="p">,</span><span class="w"> </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VectorType</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ExtraType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Args</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VectorData</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">VectorData</span><span class="p">(</span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="p">())</span><span class="o">:</span><span class="n">Data</span><span class="p">(</span><span class="n">inData</span><span class="p">){}</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getData</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">VectorData</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;</span><span class="w"> </span><span class="n">D</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span><span class="w"> </span><span class="c1">// put data into VectorData container</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LoadedData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">D</span><span class="p">.</span><span class="n">getData</span><span class="p">();</span><span class="w"> </span><span class="c1">// load data from VectorData container</span>
<span class="w">    </span><span class="c1">// Print data</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadedData</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="c1">// *note std::vector size is index[0] - index[max] so it alvays in range and not need to do -1 from it</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadedData</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Value = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/cf9e1f1b2d79352415c24dc824736165.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="cf9e1f1b2d79352415c24dc824736165.png" auto_="auto;" display="block;" margin:="margin:" src="../images/cf9e1f1b2d79352415c24dc824736165.png" /></a></p>
<p>Обратите внимание, для вложенного шаблона я применил значение "по умолчанию" - <code>template&lt;typename, typename = std::allocator&lt;ItemType&gt;&gt;</code>.
Дело в том, что тип <code>std::vector</code> принимает два аргумента, второй аргумент описывается конструкцией <code>std::allocator&lt;ItemType&gt;</code>, которую я и подставил в качестве значения "по умолчанию".</p>
<p>Однако, очевидно, что так делать не совсем удобно.</p>
<p>Если вы не знаете точный список аргументов для вложенного в шаблон класса или не хотите задавать значения "по умолчанию" для этих аргументов, как сделал я, можете использовать множественную подстановку такого вида - <code>typename ...</code>.
Давайте применим этот подход в нашем коде:
<div class="highlight"><pre><span></span><code><span class="c1">// Nested Template</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ItemType</span><span class="p">,</span><span class="w"> </span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">VectorType</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VectorData</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Data</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">VectorData</span><span class="p">(</span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="p">())</span><span class="o">:</span><span class="n">Data</span><span class="p">(</span><span class="n">inData</span><span class="p">){}</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">VectorType</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">getData</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
К стати класс можно упростить еще сильнее использовав такую подстановку - <code>template&lt;typename ... &gt; class VectorType</code>.</p>
<h2 id="_10">Функции с неограниченным количеством параметров</h2>
<p>Язык с++ позволяет создавать функции с неограниченным количеством параметров (<code>variadic functions</code>). Примером такой функции выступает <code>printf</code>. В этой главе я коснусь вопросов работы с такими функциями.</p>
<h2 id="variadic">Классические <code>variadic</code> функции</h2>
<p>Рассмотрим классический подход.</p>
<p>В библиотеке с++ имеется набор макросов, помогающий работать со списком аргументов, переданных в функцию. В частности это: <code>va_start, va_end, va_arg</code>. Однако, используя эти макросы не получится определить тип конкретного аргумента, а так-же их количество. Потому что переданный в функцию набор аргументов будет указателем на объект в куче.</p>
<p>Рассмотрим пример:
<div class="highlight"><pre><span></span><code><span class="c1">// Pure Variadic summ of floats</span>
<span class="kt">double</span><span class="w"> </span><span class="nf">float_summ</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vars_count</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">va_list</span><span class="w"> </span><span class="n">arg_cont</span><span class="p">;</span><span class="w"> </span><span class="c1">// container for variadinc arguments</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span><span class="w"> </span><span class="c1">// float arguments get promoted to double automatically. Who knows why, but is you use float type instead - results might be unpredictable.</span>
<span class="w">    </span><span class="n">va_start</span><span class="p">(</span><span class="n">arg_cont</span><span class="p">,</span><span class="w"> </span><span class="n">vars_count</span><span class="p">);</span><span class="w"> </span><span class="c1">// this variable requires total count of given args</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vars_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">arg_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va_arg</span><span class="p">(</span><span class="n">arg_cont</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">);</span><span class="w"> </span><span class="c1">// arg_cont increments itself automatically</span>
<span class="w">        </span><span class="c1">//printf(&quot;[%d] = %i\n&quot;, i, arg_value);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;]&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arg_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// since i experiment with argument type - it&#39;s better to use cout, that is type independant</span>
<span class="w">        </span><span class="n">summ</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arg_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">va_end</span><span class="p">(</span><span class="n">arg_cont</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">summ</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float_summ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.2f</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;summ = %f&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">summ</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/f0f093ea8b33853435c4bab7f053e807.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f0f093ea8b33853435c4bab7f053e807.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f0f093ea8b33853435c4bab7f053e807.png" /></a></p>
<p>Тут всплывает целая масса проблем сразу.</p>
<p>Во первых в данную функцию нельзя просто так взять и отправить тип <code>float</code>, потому что он конвертируется в <code>double</code>  автоматически.</p>
<p>Если я заменю тип <code>double</code> на <code>float</code> в коде, смотрите что случится с результатом:</p>
<p><a class="glightbox" href="../images/0682570d5f9c2712236e2c10c948518d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0682570d5f9c2712236e2c10c948518d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0682570d5f9c2712236e2c10c948518d.png" /></a></p>
<p>Во вторых - что если пользователь отправил в функцию не только <code>float</code> числа, но и, например, строки, а так-же числа типа <code>int</code>? Если так сделать - все сломается.</p>
<p><a class="glightbox" href="../images/825631d80b855c930f1761049825896b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="825631d80b855c930f1761049825896b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/825631d80b855c930f1761049825896b.png" /></a></p>
<p>В третьих, поскольку система понятия не имеет о числе переданных в функцию аргументов, всегда должен быть способ определения их количества. В моем примере за количество аргументов ответственен параметр <code>vars_count</code>.
Но что  если мы укажем в значении этого параметра куда большее число, чем количество аргументов, которое было передано?</p>
<p><a class="glightbox" href="../images/1649609a6d1da934f32e1a35ff1fb2c5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1649609a6d1da934f32e1a35ff1fb2c5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1649609a6d1da934f32e1a35ff1fb2c5.png" /></a></p>
<p>Снова вылезают непредсказуемые значения среди аргументов, которые не заданы.</p>
<p>Отличить заданные аргументы от не заданных разработчик, при этом, никак не может.</p>
<p>Как встроенные в язык <code>c</code> функции, вроде <code>printf</code>, работают с <code>vairadic</code> данными, обходя озвученные выше проблемы? Они распознают в переданной строке параметры вида <code>%s, %i, %f</code> и  так далее. Которые потом считаются и обрабатываются. Поэтому неопределенного поведения не возникает.</p>
<p>Итоговая функция суммы у меня  получилась такой:
<div class="highlight"><pre><span></span><code><span class="c1">// Pure Variadic summ of floats</span>
<span class="k">auto</span><span class="w"> </span><span class="n">args_summ</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vars_count</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">va_list</span><span class="w"> </span><span class="n">arg_cont</span><span class="p">;</span><span class="w"> </span><span class="c1">// container for variadinc arguments</span>
<span class="w">    </span><span class="c1">//std::cout&lt;&lt; &quot;----&quot; &lt;&lt; sizeof...(...) &lt;&lt; &quot;\n&quot;; - dosen&#39;t work - variadic arg should have name</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">ArgsType</span><span class="p">;</span><span class="w"> </span><span class="c1">//  now ArgsType is alias of double. if we need to summ ints, change it to int. Can&#39;t be &lt;template&gt; parameter since our variadic data not in the template.</span>
<span class="w">    </span><span class="n">ArgsType</span><span class="w"> </span><span class="n">summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ArgsType</span><span class="p">();</span><span class="w"> </span><span class="c1">// float arguments get promoted to double automatically. Who knows why, but is you use float type instead - results might be unpredictable.</span>
<span class="w">    </span><span class="n">va_start</span><span class="p">(</span><span class="n">arg_cont</span><span class="p">,</span><span class="w"> </span><span class="n">vars_count</span><span class="p">);</span><span class="w"> </span><span class="c1">// this variable requires total count of given args</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vars_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">arg_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va_arg</span><span class="p">(</span><span class="n">arg_cont</span><span class="p">,</span><span class="w"> </span><span class="n">ArgsType</span><span class="p">);</span><span class="w"> </span><span class="c1">// arg_cont increments itself automatically</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;]&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arg_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// since i experiment with argument type - it&#39;s better to use cout, that is type independant</span>
<span class="w">        </span><span class="n">summ</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">arg_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">va_end</span><span class="p">(</span><span class="n">arg_cont</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">summ</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h2 id="variadic_1"><code>Variadic</code> шаблоны</h2>
<p>Теперь рассмотрим <code>variadic</code> шаблоны.</p>
<p>Главный недостаток классических <code>variadic</code> функций состоит в жесткой привязке к типам. Макрос <code>va_arg</code>, который мы использовали выше, обязательно требует наличия готового типа, как второго аргумента - <code>va_arg(arg_cont, double)</code>.
Если типа нет - макрос не работает.</p>
<p>В <code>variadic</code> шаблонах наличие определенного типа не обязательно, но их использование накладывает на разработчика целый ряд сложностей, поскольку все шаблоны обрабатываются препроцессором, то есть работают в <code>compile time</code>.
Сокращенный формат <code>variadic</code> шаблона выгядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// Variadic Function Demo</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">variadic_function</span><span class="w"> </span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">elements_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">inputs</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elements_count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">variadic_function</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;t&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.2</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/29d2454402cd0b9fd3b6f14496c90922.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="29d2454402cd0b9fd3b6f14496c90922.png" auto_="auto;" display="block;" margin:="margin:" src="../images/29d2454402cd0b9fd3b6f14496c90922.png" /></a></p>
<p>Так-же возможны <code>variadic</code> шаблоны для классов и структур.
<div class="highlight"><pre><span></span><code><span class="c1">// Variadic Class Demo</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VariadicClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">VariadicClass</span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">elements_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">inputs</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elements_count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">Vc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">VariadicClass</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">4.3</span><span class="p">);</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">Vc</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/5067d9395c80b832805f5c603197957e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5067d9395c80b832805f5c603197957e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5067d9395c80b832805f5c603197957e.png" /></a></p>
<p>Из <code>variadic</code> классов создают кортежи, про которые я напишу чуть ниже (а может и не напишу, в Unreal их не используют и правильно делают). Пока же сфокусируемся на аргументах.</p>
<h3 id="_11">Паки параметров</h3>
<p><code>variadic</code> параметры функций и методов по другому еще называют <code>Parameter Packs</code>.
Причем паков в нашей тестовой функции будет два. Пак типов <code>Ts...</code> и пак значений <code>inputs...</code>.
При работе с паками параметров надо указывать <code>...</code>.
Паки параметров обладают следующими свойствами:
1)паки могут содержать любое количество любых данных любого типа
2)паку параметров нельзя присвоить значение "по умолчанию"</p>
<p><a class="glightbox" href="../images/fa6c8f14fe366b6f7524ab9d30dd04b2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fa6c8f14fe366b6f7524ab9d30dd04b2.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fa6c8f14fe366b6f7524ab9d30dd04b2.png" /></a></p>
<p>3)пак параметров должен идти последним в списке аргументов функции</p>
<p><a class="glightbox" href="../images/8bc6ffb348ae584fec1bdc02323b9d44.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="8bc6ffb348ae584fec1bdc02323b9d44.png" auto_="auto;" display="block;" margin:="margin:" src="../images/8bc6ffb348ae584fec1bdc02323b9d44.png" /></a></p>
<p>4)невозможно изменить значение параметров в паке (это <code>compile-time</code> параметр)
5)невозможно добавить параметры в пак
Паки параметров обрабатываются препроцессором перед компиляцией. На основе функции с паком параметров, препроцессор генерирует обычную функцию с обычными аргументами.</p>
<p>В итоговом, обработанном препроцессором, коде приложения нет никаких паков параметров и нет никаких шаблонов. Это значит что параметры в паке нельзя изменять в рунтайме, их нельзя передавать в циклы (потому что циклы работают в реальном времени), а само использование упакованных параметров возможно лишь с другими функциями или с шаблонами. При этом паки параметров можно передавать другим функциям, копировать или использовать рекурсию.</p>
<p><a class="glightbox" href="../images/2934149fbe65dc9d7dc7286390daf941.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2934149fbe65dc9d7dc7286390daf941.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2934149fbe65dc9d7dc7286390daf941.png" /></a></p>
<p>Чтобы работать с упакованными аргументами, для начала их надо распаковать.</p>
<p>Для этого в стандартной библиотеке есть шаблон <code>std::get</code>, который можно применить к паку значений, и функтор (на основе структуры) <code>std::tuple_element</code>, который может быть применен к паку типов.</p>
<p>Пак параметров это подвид кортежа, поэтому функции для работы с кортежами - работают и с паками параметров.
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;variant&gt;</span><span class="c1"> // std::get</span>
<span class="c1">// Variadic Function Demo</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">variadic_function</span><span class="w"> </span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">elements_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">inputs</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// we will get second arg in variadic</span>
<span class="w">    </span><span class="c1">// getting type by id</span>
<span class="w">    </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">tuple_element</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="n">NType</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// getting value by id</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">tulpe_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward_as_tuple</span><span class="p">(</span><span class="n">inputs</span><span class="p">...);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Arg&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; Type Name = [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">NType</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Arg&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; Value = [&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tulpe_values</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Args Count = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">elements_count</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/9297ea5356497046180ece07a543f904.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9297ea5356497046180ece07a543f904.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9297ea5356497046180ece07a543f904.png" /></a></p>
<p>Однако у такого подхода есть один серьезный недостаток. Номер элемента, который мы получаем через <code>std::get</code> обязан быть <code>static const</code>. Иначе код не сработает.</p>
<p><a class="glightbox" href="../images/0063c20a2761e1d9e2bcf8ad636775a9.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0063c20a2761e1d9e2bcf8ad636775a9.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0063c20a2761e1d9e2bcf8ad636775a9.png" /></a></p>
<p>Почему так? Потому что код шаблонов и упакованных параметров заменяется в момент компиляции. Из-за такой особенности языка любая попытка пройтись по элементам пака в цикле - не сработает. Циклы работают в реальном времени, то есть в запущенном приложении. А шаблоны и их параметры заменяются в момент компиляции и в реальном времени они не существуют.</p>
<p><a class="glightbox" href="../images/4e522194adc895ddd801c7fc9713c210.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4e522194adc895ddd801c7fc9713c210.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4e522194adc895ddd801c7fc9713c210.png" /></a></p>
<p>У распаковки параметров из пака есть только два действительно работающих решения.</p>
<h3 id="_12">Рекурсивная распаковка аргументов</h3>
<p>Старое решение, применявшееся до <code>с++ 17</code> заключалось в рекурсивной обработке параметров.</p>
<p>Выглядит это так:
<div class="highlight"><pre><span></span><code><span class="c1">// recursive variadic unpack</span>
<span class="c1">// one arg version of recursive unpack will be called last</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ArgType</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">variadic_recursive</span><span class="p">(</span><span class="n">ArgType</span><span class="w"> </span><span class="n">Arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Final Arg &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">Arg</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// main process of recursive unpack</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">Head</span><span class="p">,</span><span class="w"> </span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Tail</span><span class="o">&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">variadic_recursive</span><span class="p">(</span><span class="n">Head</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; current head = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; elements left = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">tail</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">variadic_recursive</span><span class="p">(</span><span class="n">tail</span><span class="p">...);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">variadic_recursive</span><span class="p">(</span><span class="s">&quot;h&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/9f8b94dfd347dc678bc085097c32dcf3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9f8b94dfd347dc678bc085097c32dcf3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9f8b94dfd347dc678bc085097c32dcf3.png" /></a></p>
<p>Здесь я использовал перегрузку функции <code>variadic_recursive</code>, первый параметр которой постоянно убавлял стек, переданный в <code>tail</code>.
Поскольку значение "по умолчанию" для <code>variadic</code> переменных невозможно, такой подход подразумевает наличие второй - "завершающей" функции, которая вызывается благодаря <code>function overloading</code>. Если завершающую функцию убрать - код прекратит компилироваться.</p>
<h3 id="fold-expressions">Свернутые выражения (<code>Fold Expressions</code>)</h3>
<p>Второй  способ распаковки <code>variadic</code> шаблонов заключается в использовании использовании "свернутых выражений" (<code>fold expressions</code>).
Выглядит этот способ  следующим образом:
<div class="highlight"><pre><span></span><code><span class="c1">// fold expression based parameter pack unpack</span>
<span class="c1">//https://stackoverflow.com/a/60136761/2574125</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">fold_ex_unpack</span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// fold expression &quot;loop&quot;</span>
<span class="w">    </span><span class="c1">// this loop happens in compile time, not in runtime!</span>
<span class="w">    </span><span class="p">([</span><span class="o">&amp;</span><span class="p">]{</span>
<span class="w">        </span><span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;input &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; type &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">Ts</span><span class="p">).</span><span class="n">name</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="p">(),</span><span class="w"> </span><span class="p">...);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">fold_ex_unpack</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;t&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3.2</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Обратите внимание на формат лямбды тут - <code>[](){}()</code>. Выше я уже писал, что лямбды, закрывающиеся кавычками <code>()</code> - это автозапускаемые лямбды. Приведенное выше свернутое выражение расшифровывается примерно так - для каждого элемента в <code>...</code> провести запуск лямбды. Из лямбды, ради интереса, я увеличиваю счетчик <code>i++</code> и  вывожу количество итераций.</p>
<p>Внутри свернутого выражения доступ к значению <code>variadic</code> аргумента выполняется по его имени, в нашем случае это <code>inputs</code> для значений и  <code>Ts</code> для типов.</p>
<p>Таким образом <code>fold expressions</code> - это конструкции, которые разворачиваются препроцессором в результирующий код для каждого из аргументов.</p>
<p>Формат выражения:
<div class="highlight"><pre><span></span><code><span class="p">(</span><span class="o">&amp;</span><span class="n">callable</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
</code></pre></div>
При этом, поскольку свернутые выражения подразумевают использование оператора <code>...</code>, то применять их можно только внутри <code>variadic</code> лямбд, функций или классов.</p>
<p>К примеру <code>fold expression</code> для кортежа <code>std::tuple</code> выполняется так:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">([</span><span class="n">xs</span><span class="p">](){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Arg Value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}(),</span><span class="w"> </span><span class="p">...);</span>
<span class="p">},</span>
<span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/c5dbe56da0490b94e75cc77ccb0139e3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c5dbe56da0490b94e75cc77ccb0139e3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c5dbe56da0490b94e75cc77ccb0139e3.png" /></a></p>
<p>В сокращенном виде будет так:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">...);</span>
<span class="p">},</span>
<span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/ff5dd395b4f2b39dffd2d8cf7cd92fb6.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ff5dd395b4f2b39dffd2d8cf7cd92fb6.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ff5dd395b4f2b39dffd2d8cf7cd92fb6.png" /></a></p>
<p>Тут я обернул <code>fold expression</code> в <code>variadic</code> лямбду, чтобы данный код сработал в <code>std::apply</code>.  Без такой обертки код не сработает. Сами по себе свернутые выражения не могут быть использованы вне <code>variadic</code> сущностей.</p>
<p>Зная все вышеописанное, можно написать, например, функцию суммирования аргументов функции.
<div class="highlight"><pre><span></span><code><span class="c1">// Variadic arithmetic summ</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">variadic_arithmetic_summ</span><span class="w"> </span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">([</span><span class="o">&amp;</span><span class="p">]()</span><span class="o">-&gt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">inputs</span><span class="p">){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">inputs</span><span class="p">;</span><span class="w"> </span><span class="p">}()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">variadic_arithmetic_summ</span><span class="p">(</span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mf">2.1f</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/fb0c58f10c2bd352f1804bba8d9b5113.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fb0c58f10c2bd352f1804bba8d9b5113.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fb0c58f10c2bd352f1804bba8d9b5113.png" /></a></p>
<p>Это развернутый формат, который отлично читается и может быть понят даже теми, кто о <code>fold expressions</code> знает мало. Тут сразу видно, что идет запуск лямбды, которая возвращает <code>decltype(inputs)</code>.
Но код можно сильно упростить. Поскольку в теле лямбды нам нужно лишь сделать <code>return inputs;</code> код сокращается до:
<div class="highlight"><pre><span></span><code><span class="c1">// Variadic arithmetic summ, simplified</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">variadic_arithmetic_summ1</span><span class="w"> </span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="w"> </span><span class="n">inputs</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...);</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/51863594cff7576927cabcb7dde19d54.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="51863594cff7576927cabcb7dde19d54.png" auto_="auto;" display="block;" margin:="margin:" src="../images/51863594cff7576927cabcb7dde19d54.png" /></a></p>
<p>Кавычки, запускающие лямбду, можно убрать и тогда мы получим пример, который можно найти в гугле, если вбить запрос про <code>fold expressions</code>. Этот, сокращенный, вариант выражения - наиболее непонятен и плохо читается.
<div class="highlight"><pre><span></span><code><span class="c1">// Variadic arithmetic summ, simplified</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">variadic_arithmetic_summ_simple</span><span class="w"> </span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">inputs</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">inputs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...);</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/e2314d4f5a5e10474846b459ee94e0e7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e2314d4f5a5e10474846b459ee94e0e7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e2314d4f5a5e10474846b459ee94e0e7.png" /></a></p>
<p>Как вы видите, свернутые выражения поддерживают математические операции в своем контексте. Выше я использовал <code>+</code>. Булевы операции тоже поддерживаются.</p>
<h3 id="overloaded">Распаковка аргументов через <code>overloaded</code> паттерн</h3>
<p>Данный подход позволяет задать уникальную логику для каждого из переданных в шаблон типов. Взято из <a href="https://stackoverflow.com/a/54641400/2574125">stackowerflow</a>.
Реализация подхода выглядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// overloaded pattern</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">overloaded</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Ts</span><span class="p">...</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">Ts</span><span class="o">::</span><span class="k">operator</span><span class="p">()...;</span><span class="w"> </span><span class="p">};</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span><span class="w"> </span><span class="n">overloaded</span><span class="p">(</span><span class="n">Ts</span><span class="p">...)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">overloaded</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span><span class="c1">// this will move args from () to &lt;&gt;</span>
<span class="c1">// main calls this</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">overloaded</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="p">[](</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;double = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;int = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">            </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;string = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// apply struct above to each of tuple params</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">apply</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">e</span><span class="p">){</span>
<span class="w">            </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="w"> </span><span class="p">...);</span><span class="w"> </span><span class="c1">// fold expression to run</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.3f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/6a4a9462717c2fc4ba35d47b64ecf7e4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6a4a9462717c2fc4ba35d47b64ecf7e4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6a4a9462717c2fc4ba35d47b64ecf7e4.png" /></a></p>
<p>Есть упрощенный и более читабельный вариант шаблона, позволяющий обрабатывать наборы данных, основанные на <code>std::variant</code>:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- simple overloaded ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">OverloadedSimple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;double = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;int = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">operator</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;string = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// make short alias for std::variant</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">type_variants</span><span class="p">;</span><span class="w"> </span><span class="c1">// each std::variant variable can contain one of provided types from the list</span>
<span class="c1">// variant size</span>
<span class="kt">size_t</span><span class="w"> </span><span class="n">vsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">variant_size</span><span class="o">&lt;</span><span class="n">type_variants</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;types in variant = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">vsize</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="c1">// make array (vector) of variants with provided data</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">type_variants</span><span class="o">&gt;</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">3.3f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;test&quot;</span><span class="p">};</span>
<span class="c1">// pass every variant in array thru struct</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">variant</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">OverloadedSimple</span><span class="p">{},</span><span class="w"> </span><span class="n">variant</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/44000b6d86d06b60e26b88e0a2d48938.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="44000b6d86d06b60e26b88e0a2d48938.png" auto_="auto;" display="block;" margin:="margin:" src="../images/44000b6d86d06b60e26b88e0a2d48938.png" /></a></p>
<h2 id="_13">Преобразования типов, встроенные в с++</h2>
<p>В Unreal Engine уже есть свой метод приведения типов - это <code>Cast&lt;тип&gt;(приводимое значение)</code>, который опускает тот или иной элемент по иерархии наследования. В дополнение к этому методу в с++ есть еще несколько операций приведения типа. Давайте ознакомимся с ними.</p>
<h2 id="implicit-type-conversions">Неявные преобразования типов <code>implicit type conversions</code></h2>
<p>Язык с++ способен неявно преобразовывать типы. Например, так можно преобразовать <code>float</code> в <code>int</code>:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- type conversions ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// implicit conversion int -&gt; float</span>
<span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="c1">// implicit conversion float -&gt; int during calculation</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/c7c3233f946f9505cb0bd564a14f1fad.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c7c3233f946f9505cb0bd564a14f1fad.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c7c3233f946f9505cb0bd564a14f1fad.png" /></a></p>
<h3 id="_14">Перегрузка неявного преобразования типов в классах</h3>
<p>Неявное преобразование типов не работает с пользовательскими классами. Но можно перегрузить оператор преобразования, чтобы это исправить.</p>
<p>Формат перегрузки:
<div class="highlight"><pre><span></span><code>operator conversion_type() { return conversion_type; }
</code></pre></div>
Где <code>conversion_type</code> это тип, в который предполагается конверсия.</p>
<p>Лучше будет записать в формате шаблона:
<div class="highlight"><pre><span></span><code><span class="c1">// conversion to type by assignment</span>
<span class="c1">// usage: int pv = CTest();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="p">(){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ResultingType</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// pointer conversion</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="o">*</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ResultingType</span><span class="w"> </span><span class="o">*</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ResultingType</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// conversion to refrence type by assignment</span>
<span class="c1">// usage: int pv = CTest();</span>
<span class="c1">// *note use this or &quot;conversion to type by assignment&quot;(1) do not use both, they are ambigous</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="o">&amp;</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ResultingType</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ResultingType</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Рассмотрим на примере:
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test converstions</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CTest</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">int_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">string_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Default contructor</span>
<span class="w">    </span><span class="n">CTest</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// copy assignment overload CTest = int;</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">FromType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">CTest</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">FromType</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//std::cout&lt;&lt; typeid(FromType).name() &lt;&lt; &quot;\n&quot;; // print passed type</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="n">FromType</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">){</span><span class="w"> </span><span class="c1">// if value is int. one way of chek if typeas are the same</span>
<span class="w">            </span><span class="c1">// pay attention to constexpr in the IF statement</span>
<span class="w">            </span><span class="c1">// we will not be able to make `int_data = value` without constexpr if since template type - `FromType` not convertable to int</span>
<span class="w">            </span><span class="n">int_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;int assigned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">FromType</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">FromType</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="p">){</span><span class="w"> </span><span class="c1">// if value is string</span>
<span class="w">            </span><span class="n">string_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;std::string assigned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// conversion to type by assignment</span>
<span class="w">    </span><span class="c1">// usage: int pv = CTest();</span>
<span class="w">    </span><span class="cm">/*template&lt;class ResultingType&gt;</span>
<span class="cm">    operator ResultingType(){ //use this or &quot;conversion to refrence type by assignment&quot;(3), not both since will throw error</span>
<span class="cm">        if constexpr (std::is_same&lt;ResultingType, int&gt;()){</span>
<span class="cm">            return int_data;</span>
<span class="cm">        }else</span>
<span class="cm">        if constexpr (std::is_same&lt;ResultingType, std::string&gt;()){</span>
<span class="cm">            return string_data;</span>
<span class="cm">        }</span>
<span class="cm">        return ResultingType();</span>
<span class="cm">    }*/</span>
<span class="w">    </span><span class="c1">// conversion to pointer type by assignment</span>
<span class="w">    </span><span class="c1">// usage: int *pv = CTest();</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="o">*</span><span class="p">(){</span>
<span class="w">        </span><span class="c1">//std::cout&lt;&lt; typeid(ResultingType).name() &lt;&lt; &quot;\n&quot;; // print passed type</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">            </span><span class="c1">//static int *result = new int(7);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">int_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="k">else</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">string_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// conversion to refrence type by assignment</span>
<span class="w">    </span><span class="c1">// usage: int pv = CTest();</span>
<span class="w">    </span><span class="c1">// *note use this or &quot;conversion to type by assignment&quot;(1) do not use both, they are ambigous</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="o">&amp;</span><span class="p">(){</span>
<span class="w">        </span><span class="c1">//std::cout&lt;&lt; typeid(ResultingType).name() &lt;&lt; &quot;\n&quot;; // print passed type</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">int_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="k">else</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">string_data</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">ResultingType</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ResultingType</span><span class="p">();</span><span class="w"> </span><span class="c1">// we have to use static or internal variable, because temporary is created otherwise</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">CTest</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CTest</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- data assign overload ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// copy-assingn overload tests</span>
<span class="w">    </span><span class="o">*</span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;some_data value assigned to = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">int_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">some_string value assigned to = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">string_data</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- type conversions ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// implicit conversion overload tests</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">stored_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">stored_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;stored number = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">stored_num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;stored string = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">stored_string</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// pointer conversion</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pointer_stored_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">pointer_stored_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="c1">// change pointer memory value (this will affect class data and value below)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">*</span><span class="n">pointer_stored_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;pointer stored number = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pointer_stored_num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;pointer stored string = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pointer_stored_string</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// refrence conversion</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref_stored_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref_stored_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="n">ref_stored_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;OverridenText&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// change refrence memory value (this will affect class data and value below)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;refrence stored number = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ref_stored_num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;refrence stored string = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ref_stored_string</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Object stored string = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">string_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">conv_obj</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--------------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/32c36994ac774fcf79cdeac3cc799f29.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="32c36994ac774fcf79cdeac3cc799f29.png" auto_="auto;" display="block;" margin:="margin:" src="../images/32c36994ac774fcf79cdeac3cc799f29.png" /></a></p>
<p>Тут я шаблонно перегрузил оператор <code>()</code> в разных вариациях - ссылки, указателя и просто переменной. Это позволяет напрямую, используя неявную конверсию, обращаться к полям класса и даже менять их через ссылки.</p>
<p>Реализованные таким образом операторы конверсии будут работать с классом даже если применить к нему прямое преобразование типа через метод <code>static_cast</code> (его я рассмотрю чуть ниже):
<div class="highlight"><pre><span></span><code><span class="c1">// direct conversion</span>
<span class="kt">int</span><span class="w"> </span><span class="n">direct_cast_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">conv_obj</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;direct casted number = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">direct_cast_num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3574239dc58f97a94cffc6761744b201.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3574239dc58f97a94cffc6761744b201.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3574239dc58f97a94cffc6761744b201.png" /></a></p>
<p>Помимо конверсии, я перегрузил и операцию присвоения данных - <code>CTest&amp; operator = (FromType value)</code>, что позволяет присваивать данные полям класса, не обращаясь к ним напрямую.
<div class="highlight"><pre><span></span><code><span class="c1">// copy-assingn overload tests</span>
<span class="o">*</span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="o">*</span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;some_data value assigned to = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">int_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">some_string value assigned to = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">string_data</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<h3 id="explicit"><code>explicit</code></h3>
<p>Есть такое ключевое слово как <code>explicit</code>. Оно запрещает неявную конверсию типов при работе с методами класса.</p>
<p>Компилятор с++ может использовать конструктор с одним параметром для автоматической инициализации класса (со сбросом его полей и данных). В ряде случаев это еще может привести к утечке памяти. Ключевое слово <code>explicit</code> позволяет блокировать подобные явления.</p>
<p>Добавим в наш класс пару конструкторов - один с полем типа <code>int</code> и второй с полем типа <code>std::string</code>. Так-же, на время, закомментируем перегрузку присвоения <code>CTest&amp; operator = (FromType value)</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test converstions</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CTest</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">int_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">string_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Default contructor</span>
<span class="w">    </span><span class="n">CTest</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Constructor for int initialisation</span>
<span class="w">    </span><span class="n">CTest</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in_int_data</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int_data</span><span class="p">(</span><span class="n">in_int_data</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;int constructor is called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Constructor for string initialisation</span>
<span class="w">    </span><span class="n">CTest</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">in_string</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">string_data</span><span class="p">(</span><span class="n">in_string</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;string constructor is called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Constructor for string initialisation</span>
<span class="w">    </span><span class="n">CTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in_ch</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">string_data</span><span class="p">(</span><span class="n">in_ch</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;const char constructor is called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// copy assignment overload CTest = int;</span>
<span class="w">    </span><span class="cm">/*template&lt;class FromType&gt;</span>
<span class="cm">    CTest&amp; operator = (FromType value) {</span>
<span class="cm">        //std::cout&lt;&lt; typeid(FromType).name() &lt;&lt; &quot;\n&quot;; // print passed type</span>
<span class="cm">        if constexpr ( typeid(FromType) == typeid(int) ){ // if value is int. one way of chek if typeas are the same</span>
<span class="cm">            // pay attention to constexpr in the IF statement</span>
<span class="cm">            // we will not be able to make `int_data = value` without constexpr if since template type - `FromType` not convertable to int</span>
<span class="cm">            int_data = value;</span>
<span class="cm">            std::cout&lt;&lt;&quot;int assigned\n&quot;;</span>
<span class="cm">        } else</span>
<span class="cm">        if constexpr ( std::is_same&lt;FromType, const char*&gt;() || std::is_same&lt;FromType,std::string&gt;() ){ // if value is string</span>
<span class="cm">            string_data = value;</span>
<span class="cm">            std::cout&lt;&lt;&quot;std::string assigned\n&quot;;</span>
<span class="cm">        }</span>
<span class="cm">        return *this;</span>
<span class="cm">    }*/</span>
<span class="w">    </span><span class="c1">// ... rest of the code</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">CTest</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CTest</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- data assign overload ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// copy-assingn overload tests</span>
<span class="w">    </span><span class="o">*</span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">conv_obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;some_data value assigned to = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">int_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">some_string value assigned to = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">conv_obj</span><span class="o">-&gt;</span><span class="n">string_data</span><span class="p">.</span><span class="n">c_str</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Если запустить такой код, то результат будет немного не логичным:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">called</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">called</span><span class="w">   </span>
<span class="n">some_data</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span>
<span class="n">some_string</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/7e98f88cf2329589a0be17cd550b1d29.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7e98f88cf2329589a0be17cd550b1d29.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7e98f88cf2329589a0be17cd550b1d29.png" /></a></p>
<p>Обратите внимание, в коде мы отправили значение <code>5</code> в класс строчкой <code>*conv_obj = 5</code>. Однако в результате указано, что <code>some_data value assigned to = 0</code>. То есть значение целочисленного поля равно <code>0</code>.
Почему такое происходит?
Поскольку я закомментировал перегрузку оператора присвоения, команды <code>*conv_obj = 5;</code> и <code>*conv_obj = "Test"</code> будут неявно вызывать соответствующие конструкторы.</p>
<p>Поэтому класс в нашем примере инициализируется аж целых три раза, тремя разными конструктоами. И каждая инициализация создает новый экземпляр класса с пустыми значениями полей. При этом старые экземпляры класса не удаляются из памяти, потому что никто не вызывает их деструктор. Указатель просто перзаписывается. При этом память в куче как была выделена под объекты (на которые теперь ничто не указывает) так и остается выделенной. Это и есть утечка памяти.</p>
<p>Дабы избежать такого поведения - надо использовать ключевое слово <code>explicit</code>. Оно не позволит инициализировать класс через присвоение значения.</p>
<p>Изменим конструкторы таким образом:
<div class="highlight"><pre><span></span><code><span class="c1">// Constructor for int initialisation</span>
<span class="k">explicit</span><span class="w"> </span><span class="n">CTest</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">in_int_data</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int_data</span><span class="p">(</span><span class="n">in_int_data</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;int constructor is called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Constructor for string initialisation</span>
<span class="k">explicit</span><span class="w"> </span><span class="n">CTest</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">in_string</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">string_data</span><span class="p">(</span><span class="n">in_string</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;string constructor is called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Constructor for string initialisation</span>
<span class="k">explicit</span><span class="w"> </span><span class="n">CTest</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">in_ch</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">string_data</span><span class="p">(</span><span class="n">in_ch</span><span class="p">){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;const char constructor is called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
После добавления ключевого слова <code>explicit</code> присвоение больше не работает для конструкторов.</p>
<p><a class="glightbox" href="../images/dbcf005d263d21da2cb7cdc2861499af.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="dbcf005d263d21da2cb7cdc2861499af.png" auto_="auto;" display="block;" margin:="margin:" src="../images/dbcf005d263d21da2cb7cdc2861499af.png" /></a></p>
<p>Как итог - мы можем раскомментировать перегрузку оператора присвоения, что гарантирует его использование.</p>
<p>Так-же ключевое слово <code>explicit</code> можно использовать с операторами конвертации типа.
<div class="highlight"><pre><span></span><code><span class="c1">// conversion to pointer type by assignment</span>
<span class="c1">// usage: int *pv = CTest();</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="k">explicit</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="o">*</span><span class="p">(){</span>
<span class="w">    </span><span class="c1">//std::cout&lt;&lt; typeid(ResultingType).name() &lt;&lt; &quot;\n&quot;; // print passed type</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">        </span><span class="c1">//static int *result = new int(7);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">int_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="k">else</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">string_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// conversion to refrence type by assignment</span>
<span class="c1">// usage: int pv = CTest();</span>
<span class="c1">// *note use this or &quot;conversion to type by assignment&quot;(1) do not use both, they are ambigous</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">ResultingType</span><span class="o">&gt;</span>
<span class="k">explicit</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="n">ResultingType</span><span class="o">&amp;</span><span class="p">(){</span>
<span class="w">    </span><span class="c1">//std::cout&lt;&lt; typeid(ResultingType).name() &lt;&lt; &quot;\n&quot;; // print passed type</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">int_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="k">else</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">ResultingType</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">()){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">string_data</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">ResultingType</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ResultingType</span><span class="p">();</span><span class="w"> </span><span class="c1">// we have to use static or internal variable, because temporary is created otherwise</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Такое изменение кода вынудит нас явно указывать конвертируемый тип для каждой переменной.
<div class="highlight"><pre><span></span><code><span class="c1">// refrence conversion</span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref_stored_num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">)</span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ref_stored_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">*</span><span class="n">conv_obj</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/39decd9ad98c3862c0580c556725a433.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="39decd9ad98c3862c0580c556725a433.png" auto_="auto;" display="block;" margin:="margin:" src="../images/39decd9ad98c3862c0580c556725a433.png" /></a></p>
<p>Неявная конверсия будет запрещена.</p>
<h2 id="static_cast"><code>static_cast</code></h2>
<p>Формат оператора:
<div class="highlight"><pre><span></span><code><span class="n">type</span><span class="w"> </span><span class="n">var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">soruce_var</span><span class="p">);</span>
</code></pre></div>
Данный оператор работает так-же как и классическое приведение типов. В c/c++ уже есть оператор приведения типа - <code>()</code>, вот <code>static_cast</code> работает в соответствии с этим оператором, но с одной оговоркой - <code>static_cast</code> это <code>compile-tile</code> приведение типа. А классический оператор <code>()</code> может работать и  в <code>runtime</code>.
Примеры:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- static_cast ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="c1">// static cast</span>
<span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.2f</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">3.2f</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;float to int = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ac</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;t&#39;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">cc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;char to int = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cc</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/c84c79a884b6f2c43641d65f5f73b876.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c84c79a884b6f2c43641d65f5f73b876.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c84c79a884b6f2c43641d65f5f73b876.png" /></a></p>
<h2 id="const_cast"><code>const_cast</code></h2>
<p>Этот оператор не имеет прямого отношения к приведению типа. Более того, если тип, который вы передадите в <code>const_cast</code> не будет соответствовать типу передаваемой переменной - выскочет ошибка.</p>
<p>Данный оператор позволяет убирать модификатор <code>const</code> у указателей на память, разрешая, таким образом, их изменение.</p>
<p>Этот оператор может работать только с указателями. Применить его к переменным не получится.</p>
<p><a class="glightbox" href="../images/a269d9a4aa3c2b9c82055b3a3a2c79eb.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a269d9a4aa3c2b9c82055b3a3a2c79eb.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a269d9a4aa3c2b9c82055b3a3a2c79eb.png" /></a></p>
<p>Пример использования:
<div class="highlight"><pre><span></span><code><span class="c1">// const cast</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">anum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">bnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">anum</span><span class="p">);</span>
<span class="c1">// classic converstion works as well if you interested</span>
<span class="c1">// int *bnum = (int*)(anum);</span>
<span class="c1">// bnum here will point at the same location as anum</span>
<span class="c1">// but, since anum is const, we can&#39;t change anums&#39;s memory value directly</span>
<span class="c1">//*anum = 4; // - this won&#39;t work</span>
<span class="o">*</span><span class="n">bnum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// but using bnum we can change memory value passing thru const modifier</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;const anum = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">anum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">bnum = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">bnum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// anum == bnum here because they are pointing at the same place</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;anum memory address = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">anum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">bnum memory address = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bnum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b4d13b344c801d7d707a1b89c3394c55.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b4d13b344c801d7d707a1b89c3394c55.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b4d13b344c801d7d707a1b89c3394c55.png" /></a></p>
<p>В результате <code>anum</code> и <code>bnum</code> будут иметь одинаковое значение в <code>5</code>. Несмотря на то, что я изменял только указатель <code>bnum</code>. Так произошло, потому что оба указателя ссылаются на одну и ту-же память.</p>
<p>Так-же <code>const_cast</code> можно использовать в <code>const</code> методах классов, что позволяет изменять параметры класса игнорируя <code>const</code>. Это может быть полезно при работе с мутексами (рассмотрим в статье про многопоточность).
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test different type casts</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// value to store</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_data_value_increment</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">{</span><span class="w"> </span><span class="c1">// we can&#39;t modofy data_value from const function</span>
<span class="w">        </span><span class="c1">//data_value += 1; // - this won&#39;t work, function is const</span>
<span class="w">        </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">CData</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// but if we use const cast - we can modify value!</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">data_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- const_cast in class ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">CData</span><span class="w"> </span><span class="o">*</span><span class="n">cd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CData</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">get_data_value_increment</span><span class="p">();</span><span class="w"> </span><span class="c1">// increment value every time</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CData value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3dcdbceb1af2ecb622498265f658f9a8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3dcdbceb1af2ecb622498265f658f9a8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3dcdbceb1af2ecb622498265f658f9a8.png" /></a></p>
<p>Другим полезным примером использования <code>const_cast</code> будет передача <code>const</code> значения в функцию по не <code>const</code> аргументу.</p>
<p>Если я реализую в классе <code>CData</code> функцию, принимающую не <code>const</code> указатель, например такую:
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">){</span>
<span class="w">    </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Я не смогу отправить в нее значение таким образом:
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">new_data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">cd</span><span class="o">-&gt;</span><span class="n">set_data_value</span><span class="p">(</span><span class="o">*</span><span class="n">new_data_value</span><span class="p">);</span>
</code></pre></div>
Потому что <code>const</code> указатели нельзя передавать как не изменяемые параметры.</p>
<p><a class="glightbox" href="../images/5fb5bc15a44377fa4e520531edc934d1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5fb5bc15a44377fa4e520531edc934d1.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5fb5bc15a44377fa4e520531edc934d1.png" /></a></p>
<p>Поэтому придется использовать <code>const_cast</code> таким образом:
<div class="highlight"><pre><span></span><code><span class="n">cd</span><span class="o">-&gt;</span><span class="n">set_data_value</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">new_data_value</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/2b2075f5a0d6ce5959e7e25c912ac610.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2b2075f5a0d6ce5959e7e25c912ac610.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2b2075f5a0d6ce5959e7e25c912ac610.png" /></a></p>
<p>Этот код сработает и значение в классе изменится на 100.</p>
<p>Полный код:
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test different type casts</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// value to store</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_data_value_increment</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">{</span><span class="w"> </span><span class="c1">// we can&#39;t modofy data_value from const function</span>
<span class="w">        </span><span class="c1">//data_value += 1; // - this won&#39;t work, function is const</span>
<span class="w">        </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">CData</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// but if we use const cast - we can modify value!</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">data_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- const_cast in class ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- increment CData value thru const function call ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">CData</span><span class="w"> </span><span class="o">*</span><span class="n">cd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CData</span><span class="p">();</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">get_data_value_increment</span><span class="p">();</span><span class="w"> </span><span class="c1">// increment value every time</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CData value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- set CData value thru function arg ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">new_data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//cd-&gt;set_data_value(new_data_value); // - this won&#39;t work because we can&#39;t pass const pointer as non const arg</span>
<span class="w">    </span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">set_data_value</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">new_data_value</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CData value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cd</span><span class="o">-&gt;</span><span class="n">data_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/014a9569ca470d711c8711956c20a164.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="014a9569ca470d711c8711956c20a164.png" auto_="auto;" display="block;" margin:="margin:" src="../images/014a9569ca470d711c8711956c20a164.png" /></a></p>
<p>Будьте крайне осторожны используя <code>const_cast</code>, потому что измененные объекты, особенно это относится к <code>const static</code> могут очень сильно навредить работе проекта.
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">constvalptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">valptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
<span class="o">*</span><span class="n">valptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;constvalptr = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">constvalptr</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;valptr = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">valptr</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/f8aafee3aa3966e6e84f710a5f66b521.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f8aafee3aa3966e6e84f710a5f66b521.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f8aafee3aa3966e6e84f710a5f66b521.png" /></a></p>
<p>В приведенном выше примере значение изменилось в обоих указателях и в <code>constvalptr</code> и в <code>valptr</code>, хотя <code>const_cast</code> был применен лишь к одному из них. Это крайне опасная ситуация. Используйте <code>const_cast</code> с крайне высокой осторожностью. По возможности избегайте ситуаций, в которых допускается изменение данных в <code>const</code> переменных.</p>
<h3 id="mutable"><code>mutable</code></h3>
<p>Модификатор <code>mutable</code> является полной противоположностью <code>const</code>.
Если <code>const</code> блокирует изменение переменной, то <code>mutable</code> позволяет изменять переменную даже там, где это запрещено, например в <code>const</code> методах. На первый взгляд <code>mutable</code> делает то-же самое, что и <code>const_cast</code>. Однако различия между этими двумя операторами есть.</p>
<p>Рассмотрим их.</p>
<p>Суть проблемы - мы не можем менять значения параметров класса внутри <code>const</code> функций. То есть вот такой код не сработает:
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test different type casts</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// value to store</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_data_value_increment</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">{</span><span class="w"> </span><span class="c1">// we can&#39;t modify data_value from const function</span>
<span class="w">        </span><span class="n">data_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// - this won&#39;t work, function is const</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">data_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3b4e10f1c5a41f466b6d7f9442b0a564.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3b4e10f1c5a41f466b6d7f9442b0a564.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3b4e10f1c5a41f466b6d7f9442b0a564.png" /></a></p>
<p>Но если добавить переменной <code>data_value</code> модификатор <code>mutable</code> - ошибка пропадет.
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test different type casts</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">mutable</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// value to store</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_data_value_increment</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">{</span><span class="w"> </span><span class="c1">// we can&#39;t modofy data_value from const function</span>
<span class="w">        </span><span class="n">data_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// - this won&#39;t work, function is const</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">data_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/bd4075adfb30c8d88c232bfa8e289b35.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="bd4075adfb30c8d88c232bfa8e289b35.png" auto_="auto;" display="block;" margin:="margin:" src="../images/bd4075adfb30c8d88c232bfa8e289b35.png" /></a></p>
<p>Несмотря на то, что <code>mutable</code> и <code>const_cast</code> работают схожим образом, отменяя эффекты <code>const</code>, разница между ними все-же есть и она существенна.</p>
<p>Модификатор <code>mutable</code> можно применить к обычной переменной, в то время как <code>const_cast</code> работает лишь с указателями.
<code>const_cast</code> может работать вне области класса, в то время как <code>mutable</code> переменную определить в глобальном пространстве не получится.</p>
<p><a class="glightbox" href="../images/c8fcc1d68cdfa2a1a7474970d85a89f8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c8fcc1d68cdfa2a1a7474970d85a89f8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c8fcc1d68cdfa2a1a7474970d85a89f8.png" /></a></p>
<p>Модификатор <code>mutable</code> часто используют с т.н. мутексами, что будет рассмотрено мной отдельно, в статье про многопоточность.</p>
<h2 id="dynamic_cast"><code>dynamic_cast</code></h2>
<p>Позволяет перемещать указатель по иерархии наследования его класса, если такая имеется. Если перемещение невозможно - возвращает <code>nullptr</code>.
Важно понимать, что с++ не выстраивает иерархию наследования, если в классе нет виртуальных методов. Многие языки выстраивают иерархию наследования автоматически, например c# или паскаль, но с++ так не делает. Поэтому использовать метод <code>dynamic_cast</code> в классе без виртуальных методов - не получится.</p>
<p>В <code>c#</code> есть такой оператор как <code>as</code>, который делает то-же самое, что и <code>dynamic_cast</code>.
Важно понимать, что использовать <code>dynamic_cast</code> не обязательно (но желательно), язык с++ сам способен неявно преобразовывать типы при их передаче в функции.</p>
<p>Оператор <code>dynamic_cast</code> работает в реальном времени.</p>
<p>Используя <code>dynamic_cast</code> можно двигаться вниз по иерархии наследования и, если указатель ранее был более высокой категории - вверх до этой категории.
<div class="highlight"><pre><span></span><code><span class="c1">// inheritance hierarhy to demonstate dynamic_cast</span>
<span class="c1">// inheritance hierarhy to demonstate dynamic_cast</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"> </span><span class="c1">// no args constructor</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span><span class="w"> </span><span class="c1">// virtual destructor, dynamic_cast won&#39;t work without virtual method in base class</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">BaseValueIncrement</span><span class="p">(){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">++</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InheritedA_Base</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">BaseValueIncrement</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">++</span><span class="n">A</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InheritedB_Base</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Base</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">BaseValueIncrement</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">++</span><span class="n">B</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// this inherits InheritedB_Base</span>
<span class="k">class</span><span class="w"> </span><span class="nc">InheritedBA_Base</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">InheritedB_Base</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">BA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">BaseValueIncrement</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">++</span><span class="n">BA</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="c1">// dynamic cast</span>
<span class="w">    </span><span class="n">InheritedB_Base</span><span class="w"> </span><span class="o">*</span><span class="n">CurrentInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">InheritedB_Base</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// casting Down</span>
<span class="w">    </span><span class="n">Base</span><span class="w"> </span><span class="o">*</span><span class="n">BaseInstance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">CurrentInstance</span><span class="p">);</span>
<span class="w">    </span><span class="n">Base</span><span class="w"> </span><span class="o">*</span><span class="n">BaseInstanceImplicit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CurrentInstance</span><span class="p">;</span><span class="w"> </span><span class="c1">// this can be done implicitly</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">BaseInstance</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Current Instance is child of Base Instance!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">BaseInstance</span><span class="o">-&gt;</span><span class="n">BaseValueIncrement</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// casting back</span>
<span class="w">    </span><span class="c1">// since our BaseInstance was `InheritedB_Base` before we casted it down - we can cast it back and check if it is actually instance of `InheritedB_Base`</span>
<span class="w">    </span><span class="n">InheritedB_Base</span><span class="w"> </span><span class="o">*</span><span class="n">CastedInstanceB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">InheritedB_Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">BaseInstance</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">CastedInstanceB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CurrentInstanceB is InheritedB_Base!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">CastedInstanceB</span><span class="o">-&gt;</span><span class="n">BaseValueIncrement</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// trying to shift our instance vertically in hierarhy</span>
<span class="w">    </span><span class="n">InheritedA_Base</span><span class="w"> </span><span class="o">*</span><span class="n">CastedInstanceA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">InheritedA_Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">BaseInstance</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">CastedInstanceA</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;CurrentInstanceA Not instance of initialised pointer, try another class!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// trying to shift our instance upper in hierarhy</span>
<span class="w">    </span><span class="n">InheritedBA_Base</span><span class="w"> </span><span class="o">*</span><span class="n">CastedInstanceBA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">InheritedBA_Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">CastedInstanceB</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">CastedInstanceBA</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;We can&#39;t shift upper.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">InheritedBA_Base</span><span class="w"> </span><span class="o">*</span><span class="n">InstanceBA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">InheritedBA_Base</span><span class="p">();</span>
<span class="w">    </span><span class="n">Base</span><span class="w"> </span><span class="o">*</span><span class="n">LowestBImplicit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InstanceBA</span><span class="p">;</span><span class="w"> </span><span class="c1">// we can use implicit in this case as well</span>
<span class="w">    </span><span class="n">Base</span><span class="w"> </span><span class="o">*</span><span class="n">LowestB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">InstanceBA</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">LowestB</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;We can go down in inheritance hierarhy for many levels</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">CurrentInstance</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">InstanceBA</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/7e98e7aa166fec3ac7fc48fc1d159f1c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7e98e7aa166fec3ac7fc48fc1d159f1c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7e98e7aa166fec3ac7fc48fc1d159f1c.png" /></a></p>
<h2 id="reinterpret_cast"><code>reinterpret_cast</code></h2>
<p>Этот тип конверсии работает только с указателями, позволяя полностью менять их тип.</p>
<p><a class="glightbox" href="../images/be995ae334ff559a80deaed7d3877240.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="be995ae334ff559a80deaed7d3877240.png" auto_="auto;" display="block;" margin:="margin:" src="../images/be995ae334ff559a80deaed7d3877240.png" /></a></p>
<p>Переинтерпретирует тип указателя. В отличие от <code>static_cast</code> - не влияет на память указателя. Крайне не безопасный тип конверсии, с помощью которого можно указатель на любой класс конвертировать, например, в массив, пропуская явное присваивание и копирование.</p>
<p>Базовый пример использования выглядит так:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">renum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;value to convert = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">renum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">renumf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">renum</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;reinterpret_cast int to float result = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">renumf</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">renumi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">renumf</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;reinterpret_cast back float to int result = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">renumi</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b872cbb50f23a3a1bbbe4b8bc8bbe306.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b872cbb50f23a3a1bbbe4b8bc8bbe306.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b872cbb50f23a3a1bbbe4b8bc8bbe306.png" /></a></p>
<p>Поскольку <code>reinterpret_cast</code> не меняет память, а  просто заставляет систему воспринимать ту-же самую память как другой тип, при конвертации <code>int</code> в <code>float</code> таким образом, получается странное значение. Это связано с тем, что рамзерность типа <code>int</code> и типа <code>float</code> разная. Однако, если реинтерпретировать эту память назад, как <code>int</code> мы увидим, что значение не изменилось.</p>
<p>Данный трюк сработает и с классом.
<div class="highlight"><pre><span></span><code><span class="c1">// Class to test different type casts</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// value to store</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_data_value_increment</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">{</span><span class="w"> </span><span class="c1">// we can&#39;t modofy data_value from const function</span>
<span class="w">        </span><span class="c1">//data_value += 1; // - this won&#39;t work, function is const</span>
<span class="w">        </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">CData</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">data_value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// but if we use const cast - we can modify value!</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">data_value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_data_value</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="n">data_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- reinterpret_cast on custom class ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">CData</span><span class="w"> </span><span class="o">*</span><span class="n">cdr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CData</span><span class="p">();</span>
<span class="w">    </span><span class="n">cdr</span><span class="o">-&gt;</span><span class="n">set_data_value</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// convert custom class pointer to void*</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">stored_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cdr</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// convert void* back to class pointer</span>
<span class="w">    </span><span class="n">CData</span><span class="w"> </span><span class="o">*</span><span class="n">cdr_restored</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CData</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">stored_class</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;converted class data = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cdr_restored</span><span class="o">-&gt;</span><span class="n">data_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// now convert it to int</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">int_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cdr_restored</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;class converted to int value = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">int_class</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// restore back</span>
<span class="w">    </span><span class="n">CData</span><span class="w"> </span><span class="o">*</span><span class="n">cdr_restored2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CData</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">int_class</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;class restored from int data value = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">cdr_restored2</span><span class="o">-&gt;</span><span class="n">data_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">cdr</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/6cab8dd0ddaa4dfca00f09ed986a7015.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6cab8dd0ddaa4dfca00f09ed986a7015.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6cab8dd0ddaa4dfca00f09ed986a7015.png" /></a></p>
<p>Тут я конвертирую указатель на класс сначала в <code>void*</code> и обратно, потом в <code>int*</code> и обратно.</p>
<p>Тут есть интересный момент.</p>
<p>Почему при печати данных класса, преобразованного в целое число <code>int</code> у нас получается результат в <code>5</code>?
Дело в том, что при компиляции в машинный код с++ не создает никаких дополнительных данных для идентификации класса. Класс - это исключительно виртуальная языковая конструкция. В реальном коде есть лишь значения. Причем все поля класса идут в памяти в том самом порядке, который вы задаете в самом классе. Очевидно, что адрес первого поля класса будет совпадать с адресом самого экземпляра класса. А у нас первое поле это число <code>data_value</code>, значение которого <code>5</code>. К которому мы и получаем доступ, преобразовывая класс в <code>int</code>.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">int_class</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cdr_restored</span><span class="p">);</span>
</code></pre></div>
Есть куда более эффектные трюки, связанные с особенностями организации памяти в<code>c++</code></p>
<h2 id="_15">Классическое приведение типов</h2>
<p>В дополнение к приведенным выше способам конвертации данных, в <code>с++</code> есть унаследованный от языка <code>с</code> оператор конвертации - <code>()</code>.
Работает он элементарно:
<code>int a = (int)3.5f</code>;
При этом данный оператр может работать вместо <code>static_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code> и <code>dynamic_cast</code>.
Зачем же они нужны?
Для конкретизации преобразования.</p>
<p>Поскольку <code>()</code> никак не конкретизирует какое именно преобразование будет выполнено, было бы логичнее использовать при переинтерпретации - <code>reinterpret_cast</code>, при работе с наследованием - <code>dynamic_cast</code>, при убирании <code>const</code> - <code>const_cast</code>, при простом преобразовании - <code>static_cast</code>.
К тому-же использование конкретных операторов приведения типа - быстрее. Например <code>static_cast</code>, являясь <code>compile time</code> преобразованием, позволяет ускорить работу кода.</p>
<p>Однако с++ не диктуте вам, как надописать код. Вы можете спокойно использовать классическое приведение типов вместо всех приведенных выше методов. Чем я и буду заниматься далее. Потому что это короче.</p>
<p>Сравните две строки:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="w"> </span><span class="n">string_field_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data_fields</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="c1">// и</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="w"> </span><span class="n">string_field_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">)((</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">data_fields</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
</code></pre></div>
Вторая короче.</p>
<p>С другой стороны, использование <code>()</code> создает путаный код и не всегда ясно, для чего приведение типов было использовано. Вы поймете о чем речь в следующей главе.</p>
<h2 id="type-punning">Обман системы типизации / Каламбур Типизации / Type Punning</h2>
<p>В с++ одну и ту-же память или последовательность байт можно интерпретировать разным образом.</p>
<p>Например для преобразования класса в массив или наборот преобразования массива в класс напрямую.</p>
<p>Поскольку данные массива и данные класса идут упакованными в порядке своих значений, мы  можем использовать это для прямой конверсии данных, без их присвоения. Так-же можно с легкостью переключаться между схожими типами классов или структур, без прямого присвоения их полей.</p>
<p>Я уже немного касался вопросов работы с памятью в статье про указатели. Самое время продолжить.</p>
<p>Рассмотрим на примере (читайте комментарии в коде):
<div class="highlight"><pre><span></span><code><span class="c1">// Type Punning Tests</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DifferentDataFields</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">IntField</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">FloatField</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.3f</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">StringField</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Test&quot;</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">PrivateIntField</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AnotherDataFields</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- casts ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- type punning ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">DifferentDataFields</span><span class="w"> </span><span class="o">*</span><span class="n">data_fields</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DifferentDataFields</span><span class="p">();</span><span class="w"> </span><span class="c1">// main class</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- acessing class fields from memory ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">int_field_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">data_fields</span><span class="p">;</span><span class="w"> </span><span class="c1">// first class field is int and has value of 1</span>
<span class="w">    </span><span class="c1">//since class address = flass first field, we just reinterpret class pointer type</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;int_field_data = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">int_field_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;int_field_data, classic way of access = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_fields</span><span class="o">-&gt;</span><span class="n">IntField</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// second class field will be, obviously, after first + it&#39;s size</span>
<span class="w">    </span><span class="c1">// first field size is sizeof(int)</span>
<span class="w">    </span><span class="c1">// if we add it to the pointer, c++ will move our pointer to sizeof bits left, allowing us to read memory value of second variable</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">float_field_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="o">*</span><span class="p">)((</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">data_fields</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// classic way:</span>
<span class="w">    </span><span class="c1">// float* float_field_data = (float*)((char*)data_fields + sizeof(int))</span>
<span class="w">    </span><span class="c1">// many devs use char* to convert pointer to bytes, since char* has size of 1 byte in c and c++</span>
<span class="w">    </span><span class="c1">// but in c++&#39;s std we have std::byte which is exactly 1 byte in size, it&#39;s new type added in c++17</span>
<span class="w">    </span><span class="c1">// also we can use uint8_t to move bytes since it&#39;s 1 byte in size as well</span>
<span class="w">    </span><span class="c1">// float* float_field_data = (float*)((uint8_t*)data_fields + sizeof(int));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;float_field_data = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">float_field_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;float_field_data, classic way of access = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_fields</span><span class="o">-&gt;</span><span class="n">FloatField</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// rest fields can be acessed by the same order</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="w"> </span><span class="n">string_field_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span><span class="p">)((</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">data_fields</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;string_field_data = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">string_field_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;string_field_data, classic way of access = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_fields</span><span class="o">-&gt;</span><span class="n">StringField</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// and ! even private ones )</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">private_int_field_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">data_fields</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;private_int_field_data = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">private_int_field_data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// btw you can&#39;t access private fields traditianally</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- direct moving data to another class ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// we even can cast this data to another class instance with same fields order (but different amount of them)</span>
<span class="w">    </span><span class="n">AnotherDataFields</span><span class="w"> </span><span class="o">*</span><span class="n">data_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">AnotherDataFields</span><span class="o">*</span><span class="p">)(</span><span class="n">std</span><span class="o">::</span><span class="n">byte</span><span class="o">*</span><span class="p">)</span><span class="n">data_fields</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;AnotherDataFields.A = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_f</span><span class="o">-&gt;</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;AnotherDataFields.B = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_f</span><span class="o">-&gt;</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;AnotherDataFields.C = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_f</span><span class="o">-&gt;</span><span class="n">C</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// and all that without copy operations and assignments, just thru reinterpretation of same memory data</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">    // classic way of douing the same woild be like this:</span>
<span class="cm">    data_f-&gt;A = data_fields-&gt;IntField;</span>
<span class="cm">    data_f-&gt;B = data_fields-&gt;FloatField;</span>
<span class="cm">    data_f-&gt;C = data_fields-&gt;StringField;</span>
<span class="cm">    */</span>
<span class="w">    </span><span class="c1">// or we can copy the memory!</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- copying data to another class using memcpy ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">AnotherDataFields</span><span class="w"> </span><span class="o">*</span><span class="n">data_f_copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnotherDataFields</span><span class="p">();</span><span class="w"> </span><span class="c1">// make sure to allocate memory first, c++ can&#39;t copy to null pointer</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">data_f_copy</span><span class="p">,</span><span class="w"> </span><span class="n">data_fields</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;AnotherDataFields.A copy = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_f_copy</span><span class="o">-&gt;</span><span class="n">A</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;AnotherDataFields.B copy = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_f_copy</span><span class="o">-&gt;</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;AnotherDataFields.C copy = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">data_f_copy</span><span class="o">-&gt;</span><span class="n">C</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3528e3f84cab059589911b389d9b7f65.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3528e3f84cab059589911b389d9b7f65.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3528e3f84cab059589911b389d9b7f65.png" /></a></p>
<p>Следующим образом можно конвертировать массив в структуру:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- array initialized struct data ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="c1">// now let&#39;s do crazy things - let&#39;s make struct out of array.</span>
<span class="c1">// But, since arrays all of one type, we can&#39;t do this trick with different data types</span>
<span class="c1">// so all fields of struct should be same</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SingleDataStruct</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">PrintFields</span><span class="p">(){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;b = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;c = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="n">SingleDataStruct</span><span class="w"> </span><span class="n">target_struct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="n">source_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">};</span><span class="w"> </span><span class="c1">// this walues will go to the struct fields</span>
<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target_struct</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">source_array</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">source_array</span><span class="p">));</span><span class="w"> </span><span class="c1">// copy memory from source_array to target_struct</span>
<span class="n">target_struct</span><span class="p">.</span><span class="n">PrintFields</span><span class="p">();</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/4d7112bd9dac1acf928bdcfc1a864579.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4d7112bd9dac1acf928bdcfc1a864579.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4d7112bd9dac1acf928bdcfc1a864579.png" /></a></p>
<p>Я решил  проверить, получится ли этот трюк с массивом из разных данных.</p>
<p>Поскольку с++ не позволяет создавать массивы с разными типами элементов, я использовал массив типа <code>std::any</code>.
К сожалению, инициализировать обычный класс таким образом у меня не получилось, потому что поля типа <code>std::any</code>, вероятно, имеют большую размерность, чем типы, которые им передаются.</p>
<p>Зато инициализировать класс с полями типа <code>std::any</code> - получилось.
<div class="highlight"><pre><span></span><code><span class="c1">// ----</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- std::any to struct ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="c1">// since memory in array comes in pack, together</span>
<span class="c1">// i can try to initialize custom class with different field types using std::any array[]</span>
<span class="c1">// and cast it to struct</span>
<span class="c1">// unfortunately this method works only with struct with fields of std::any</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AnyDataFields</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">any</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// we MUST set Exact types</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">any</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mf">0.f</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">any</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">AnyDataFields</span><span class="w"> </span><span class="o">*</span><span class="n">AND</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AnyDataFields</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">any</span><span class="w"> </span><span class="n">any_array</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{(</span><span class="kt">int</span><span class="p">)</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="mf">3.5f</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;this is string&quot;</span><span class="p">)};</span><span class="w"> </span><span class="c1">// make sure to directly initialize string to std::string or assignment won&#39;t work</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">AND</span><span class="p">,</span><span class="w"> </span><span class="n">any_array</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">any_array</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;std::any array set to class fields = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AND</span><span class="o">-&gt;</span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;std::any array set to class fields = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AND</span><span class="o">-&gt;</span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;std::any array set to class fields = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">any_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">AND</span><span class="o">-&gt;</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/5f9000b503037e1692f68e7436b6cdd8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5f9000b503037e1692f68e7436b6cdd8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5f9000b503037e1692f68e7436b6cdd8.png" /></a></p>
<p>Так-же я провел эксперимент с распаковкой <code>std::tuple</code> в структуру, правда он не имеет  отношения к работе с памятью, но все равно пусть будет.
<div class="highlight"><pre><span></span><code><span class="c1">// ----</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--- Tuple to struct ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="c1">// tuples can be cast to struct this way:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">DifferentFieldStruct</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">FNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.f</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">Str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">PrintFields</span><span class="p">(){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Num = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;FNum = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">FNum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Str = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Str</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// initialise struct</span>
<span class="n">DifferentFieldStruct</span><span class="w"> </span><span class="n">struct_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.5f</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test String&quot;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Print Struct init data:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">struct_data</span><span class="p">.</span><span class="n">PrintFields</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">3.2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test Override&quot;</span><span class="p">);</span>
<span class="c1">// put tuple data to struct</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">struct_data</span><span class="p">.</span><span class="n">Num</span><span class="p">,</span><span class="w"> </span><span class="n">struct_data</span><span class="p">.</span><span class="n">FNum</span><span class="p">,</span><span class="w"> </span><span class="n">struct_data</span><span class="p">.</span><span class="n">Str</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mf">3.2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Test Override&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Print Struct by tuple override data:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">struct_data</span><span class="p">.</span><span class="n">PrintFields</span><span class="p">();</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/eaa6e3cd204e9861657e0f984df4d57e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="eaa6e3cd204e9861657e0f984df4d57e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/eaa6e3cd204e9861657e0f984df4d57e.png" /></a></p>
<h2 id="delete-default"><code>= delete</code> и <code>= default</code> в конструкторах классов</h2>
<p>Если посмотреть на реализацию, например, <code>TUniquieFunction</code>, то можно обнаружить такой код:</p>
<p><a class="glightbox" href="../images/aa6cb7505d5a9d6e0e10dfe0c7324625.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="aa6cb7505d5a9d6e0e10dfe0c7324625.png" auto_="auto;" display="block;" margin:="margin:" src="../images/aa6cb7505d5a9d6e0e10dfe0c7324625.png" /></a></p>
<p>Что делает этот код? Откуда в классе <code>= default и = delete</code>?
Давайте разбираться.</p>
<p>В с++ компилятор предоставляет для всех классов следующие методы: конструктор по умолчанию, конструктор копирования, оператор присваивания копирования (operator=) и деструктор.</p>
<p>Программист может переопределить заданные по умолчанию методы, определив пользовательские версии. Однако, при переопределении некоторых встроенных методов, отключается генерация для других методов.
- Если в классе задан хоть один конструктор, с любым количеством параметров, система не генерирует конструктор "по умолчанию" и поэтому его необходимо задавать вручную. Если же мы бы хотели иметь конструктор копирования и конструктор "по умолчанию" - придется явно задавать их обоих.
- Если виртуальный деструктор объявлен явно, деструктор по умолчанию не создается автоматически и его тоже надо задавать вручную, если он нужен.
- Если явно объявлен конструктор перемещения или оператор присваивания перемещения, то:
      a. Конструктор копирования не создается автоматически.
      b. Конструктор копирования не создается автоматически.
      c. Оператор копирования-присваивания не генерируется автоматически.
- Если явно объявлен конструктор копирования, оператор присваивания копирования, конструктор перемещения, оператор присваивания перемещения или деструктор, то:
- Конструктор перемещения не создается автоматически.
- Оператор перемещения-присваивания не генерируется автоматически.</p>
<p>Дабы упростить работу программиста, в язык с++ встроен спецификатор явной реализации "по умолчанию" - <code>default</code>.
Его можно поместить в:
- конструктор по-умолчанию (без параметров)
- конструктор копирования
- конструктор перемещения
- оператор копирования через присвоение
- оператор перемещения через присвоение
- деструктор
Рассмотрим следующий класс:
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">S</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">S</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Copy Constructor</span>
<span class="w">    </span><span class="c1">//S(S&amp; source) = default;</span>
<span class="w">    </span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//s = source.s;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;copy constructur</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Move Constructor</span>
<span class="w">    </span><span class="c1">//S(S&amp;&amp; source) = default;</span>
<span class="w">    </span><span class="n">S</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">s</span><span class="p">)){</span><span class="w"> </span><span class="c1">// we setting string variable s from rvalue source.s</span>
<span class="w">        </span><span class="c1">// move constructor should be noexcept</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;move constructor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Copy Assignment Operator</span>
<span class="w">    </span><span class="c1">//S&amp; operator=(const S&amp; target) = default;</span>
<span class="w">    </span><span class="n">S</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">S</span><span class="o">&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">         </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
<span class="w">         </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;copy assigned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Move Assignment Operator</span>
<span class="w">    </span><span class="c1">//S&amp; operator=(S&amp;&amp; target) = default;</span>
<span class="w">    </span><span class="n">S</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">s</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;move assigned</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// destructor</span>
<span class="w">    </span><span class="o">~</span><span class="n">S</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">();</span><span class="w"> </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy constructor call</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">));</span><span class="w"> </span><span class="c1">// move constructor call</span>
<span class="w">    </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span><span class="w"> </span><span class="c1">// copy assignment;</span>
<span class="w">    </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span><span class="w"> </span><span class="c1">// move assignment;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- pointer constructors ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">S</span><span class="p">();</span><span class="w"> </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="o">*</span><span class="n">sp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">);</span><span class="w"> </span><span class="c1">// copy constructor call</span>
<span class="w">    </span><span class="n">S</span><span class="w"> </span><span class="o">*</span><span class="n">sp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">sp</span><span class="p">));</span><span class="w"> </span><span class="c1">// move constructor call</span>
<span class="w">    </span><span class="o">*</span><span class="n">sp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">sp2</span><span class="p">;</span><span class="w"> </span><span class="c1">// copy assignment;</span>
<span class="w">    </span><span class="o">*</span><span class="n">sp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">sp2</span><span class="p">);</span><span class="w"> </span><span class="c1">// move assignment;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Если в этом классе закомментировать строчку <code>S() = default;</code> это отключит конструктор "по умолчанию". Поскольку в классе есть еще 2 конструктора (копирования и перемещения), компилятор будет считать их главными в классе. Поэтому мы не сможем инициализировать класс таким образом - <code>S *sp = new S();</code>.</p>
<p><a class="glightbox" href="../images/b57a9b1fcb7eca3df56479ae45b36489.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b57a9b1fcb7eca3df56479ae45b36489.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b57a9b1fcb7eca3df56479ae45b36489.png" /></a></p>
<p>Именно для того, чтобы сочетать в одном классе несколько методов инициализации и используется ключевое слово <code>default</code>.
Спецификатор <code>delete</code> - полная противоположность <code>default</code>. Им помечают те методы, работать с которыми нельзя. Чаще всего этот спецификатор используют, чтобы отключить возможность копирования для экземпляров класса.</p>
<p>Давайте реализуем класс, который не получится скопировать.
<div class="highlight"><pre><span></span><code><span class="c1">// inherited non-copyable class</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SNC</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">SNC</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="n">SNC</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SNC</span><span class="o">&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// disable copy constructor</span>
<span class="w">    </span><span class="n">SNC</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SNC</span><span class="o">&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// disable copy assignment</span>
<span class="w">    </span><span class="c1">// Move Constructor</span>
<span class="w">    </span><span class="c1">//S(S&amp;&amp; source) = default;</span>
<span class="w">    </span><span class="n">SNC</span><span class="p">(</span><span class="n">SNC</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">s</span><span class="p">)){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;move constructor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">};</span>
<span class="c1">// this function gets S class as arg</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">SNCArg</span><span class="p">(</span><span class="n">SNC</span><span class="w"> </span><span class="n">arg</span><span class="p">){}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">--- delete specifier ---</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">SNC</span><span class="w"> </span><span class="n">snc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SNC</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//SNCArg(snc);</span>
<span class="w">    </span><span class="n">SNCArg</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">snc</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Я отключил конструктор копирования и оператор копирования через присвоение использовав <code>delete</code>. Поэтому экземпляр класса <code>SNC</code> не получится передать в функцию <code>SNCArg</code> напрямую, то есть вот так - <code>SNCArg(snc)</code>. Если все-же попытаться так сделать, компилятор выдаст ошибку - <code>attemption to refrence a deleted function</code>.</p>
<p><a class="glightbox" href="../images/7affea15ffa039a6116e46a3c4d6ec37.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7affea15ffa039a6116e46a3c4d6ec37.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7affea15ffa039a6116e46a3c4d6ec37.png" /></a></p>
<p>Чтобы передать экземпляр класса <code>SNC</code> в функцию, придется использовать <code>std::move</code>. Данная функция является частью обширной темы, под названием "семантика перемещения".
<div class="highlight"><pre><span></span><code><span class="n">SNCArg</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">snc</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/9c80510429c720ea55477c29af807faa.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9c80510429c720ea55477c29af807faa.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9c80510429c720ea55477c29af807faa.png" /></a></p>
<h2 id="move-semantics">Семантика перемещения, <code>Move Semantics</code></h2>
<p>Под <code>move semantics</code> подразумевается спектр приемов, подразумевающий обмен данными между объектами и функциями без их копирования.</p>
<p>Семантика перемещения позволяет обойти нежелательное копирование данных при их передаче между функциями и объектами.</p>
<p>В коде <code>Unreal</code> довольно много классов используют <code>move</code> семантику, поэтому в этой статье мы ее и рассмотрим.</p>
<h2 id="rvalue-lvalue"><code>rvalue</code>, <code>lvalue</code></h2>
<p><code>rvalue</code> и <code>lvalue</code> являются логическими абстракциями, которые описывают временные и постоянные объекты, соответственно.</p>
<p>На самом деле абстракций там куда больше, вы можете прочитать про <code>move</code>  семантику, например, на сайте <a href="https://learn.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">microsoft</a>.</p>
<p><a class="glightbox" href="../images/2fea67061278d4bf7a2f28cf72279110.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2fea67061278d4bf7a2f28cf72279110.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2fea67061278d4bf7a2f28cf72279110.png" /></a></p>
<p>Рассматривать все это по отдельности я не буду, потому что это вас запутает. В этой главе мы будем говорить только об <code>rvalue</code> и <code>lvalue</code>.
Прежде чем приступать к объяснению этих терминов, давайте вспомним про обычные ссылки.</p>
<p>Ссылка <code>refrence</code> определяется символом <code>&amp;</code>.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="c1">// - a refrence</span>
</code></pre></div>
Что делают ссылки? Они позволяют получить адрес пременной.</p>
<p>Адрес переменной можно присвоить указателю, если это требуется.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a address = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;pa pointer value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pa</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/2642df1650654d91c48a4de7ad89f40c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2642df1650654d91c48a4de7ad89f40c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2642df1650654d91c48a4de7ad89f40c.png" /></a></p>
<p>Если запустить приведенный выше код, в результатах можно увидеть какой конкретно адрес получила переменная <code>a</code>.
Теперь остается задаться вопросом - по какому адресу находится цифра <code>5</code>?
Следуя вышеуказанной логике, мы бы могли применить оператор ссылки <code>&amp;</code> к числу, после чего напечатать результат. Давайте попробуем.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;&amp;</span><span class="mi">5</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/1f46876f806f4cff9c9af4e69c676310.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1f46876f806f4cff9c9af4e69c676310.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1f46876f806f4cff9c9af4e69c676310.png" /></a></p>
<p>Система сразу покажет ошибку - <code>cannot take the address of an rvalue of type 'int'</code>, что интерпретируется как: невозможно получить адрес от не присвоенного значения типа <code>int</code>.
Подобная интерпретация ошибки сразу приведет вас к мысли о том, что есть "присвоенные" и "не присвоенные" значения.</p>
<p>В нашем случае "не присвоенным" значением является цифра <code>5</code>, адрес которой мы и попытались напечатать.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// try to print address of not assigned value of 5 and fail</span>
</code></pre></div>
"Не присвоенные" значения загружаются в память, когда обрабатывается та или иная область видимости, но с оговоркой: адрес таких значений является временным, а потому с ним нельзя работать.</p>
<p>Чтобы получить адрес временных  переменных - надо выполнить "присваивание", в нашем случае это делается так: <code>int a = 5</code>.
После присваивания, адрес значения становится "постоянным" и загружается в переменную.
"Присвоенные" значения это - <code>lvalue</code> значения.
"Не присвоенные" значения это <code>rvalue</code> значения.</p>
<p>Свое название данные категории получили от своего расположения внутри оператора присваивания <code>=</code>, слева и справа соответственно.</p>
<p>В нашем примере:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
</code></pre></div>
Переменная <code>a</code>, которая получает число <code>5</code>, является <code>lvalue</code>, она слева от оператора присваивания. Число <code>5</code> находится справа, а еще оно, до присваивания, находится во временной памяти, поэтому это <code>rvalue</code>.
Стоит заметить, что правило левый - правый работает не всегда.</p>
<p>Существуют примеры, например, чистых <code>lvalue</code> - <code>lvalue</code> операций:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// a - lvalue</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// b - lvalue</span>
<span class="c1">// a and b both has address that can be print out</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"> </span><span class="c1">// who is lvalue and rvalue here? Both of them stay as lvalues.</span>
</code></pre></div>
Именно поэтому я вывел свое собственные определения для <code>lvalue</code> и <code>rvalue</code>.
<code>lvalue</code> - <code>location value</code>, это абстракция, описывающая переменную, чей адрес может быть получен оператором <code>&amp;</code>, а потом напечатан.</p>
<p>Оператор <code>&amp;</code>, примененный к объекту, называется <code>lvalue</code> ссылкой. Такую ссылку можно напечатать, но нельзя изменить.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="c1">// &amp;a - lvalue ссылка на переменную a</span>
</code></pre></div>
<code>rvalue</code> - <code>relocable value</code>, это абстракция, описывающая "перемещаемое значение". Данная абстракция позволяет использовать <code>move</code> конструктор и оператор присвоения класса, к которому передается переменная.</p>
<p>Оператор <code>&amp;&amp;</code>, примененный к объекту, называется - <code>rvalue</code> ссылкой. Такую ссылку напечатать нельзя, потому что печать подразумевает наличие постоянного адреса у значения, а применение <code>rvalue</code> ссылки преобразовывает постоянный объект во временный.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// rvalue ссылка на перменную &#39;а&#39; (на самом деле это xvalue, но это еще сильнее вас запутает)</span>
</code></pre></div>
При попытке прямой печати <code>rvalue</code> ссылки вы получите ошибку - <code>syntax error:&amp;&amp;</code>:</p>
<p><a class="glightbox" href="../images/46d09a69c6768680283fa4a786c17afc.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="46d09a69c6768680283fa4a786c17afc.png" auto_="auto;" display="block;" margin:="margin:" src="../images/46d09a69c6768680283fa4a786c17afc.png" /></a></p>
<p>При попытке печати <code>rvalue</code> с приведением типа - вы просто получите значение переменной. Никакого адреса вы не увидите.</p>
<p><a class="glightbox" href="../images/7aeee8dbdc1ccb43e07f5cdbf5d40cf1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7aeee8dbdc1ccb43e07f5cdbf5d40cf1.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7aeee8dbdc1ccb43e07f5cdbf5d40cf1.png" /></a></p>
<p>На самом деле <code>rvalue</code> ссылка ничего не приобразовывает, потому что ее вообще нет. <code>&amp;&amp;</code> - это чистейшая абстракция, в которой вообще никакого адреса или данных нет, она лишь показывает, какой именно конструктор у класса должен быть вызван - перемещающий или копирующий.</p>
<h2 id="_16">Копирование и перемещение данных в классе</h2>
<p>Каждый пользовательский класс в современном <code>с++</code> имеет возможность переопределить <code>4</code> операции, а так-же один конструктор "по умолчанию". <code>4+1</code>. Я уже рассматривал  список этих операций, но упомяну еще раз:
- обычный конструктор <code>()</code>
- конструктор копирования <code>(class_name &amp; var)</code>
- перегрузка оператора <code>=</code> с копированием <code>operator =(class_name &amp;var)</code>
- конструктор перемещения  <code>(class_name &amp;&amp; var)</code>
- перегрузка оператора <code>=</code> с перемещением <code>operator =(class_name &amp;&amp;var)</code>
Для <code>lvalue</code> параметров (<code>&amp;</code>) вызываются копирующий конструктор и копирующая перегрузка присвоения.</p>
<p>Для <code>rvalue</code> параметров (<code>&amp;&amp;</code>) вызываются перемещающий коснтруктор и перегрузка присвоения.</p>
<p>Такое разделение логики работы класса - единственная причина, по которой в <code>с++</code> ввели <code>move</code> семантику.</p>
<p>Если вы, как и я, наивно полагали, что "перемещение" переменных влечет за собой так-же перемещение в памяти - вы ошибались. Встроенные типы, вроде <code>int</code>, <code>float</code> или <code>char</code> не имеют логики перемещения, а потому всегда копируются. В пользовательских же классах логику перемещения необходимо писать самостоятельно, применяя, например оператор <code>Swap</code>.
Рассмотрим код:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c1">// a is lvalue, 4 is rvalue</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;initial a address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// print initial a address</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;initial b address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// print initial b address</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="n">a</span><span class="p">;</span><span class="w"> </span><span class="c1">// move &#39;a&#39; value to &#39;b&#39; using rvalue cast</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a value = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;b address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;b value = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="c1">// Run the code and you&#39;l see.</span>
<span class="c1">// Adderesses of &#39;a&#39; and &#39;b&#39; are different, even if i actually Moved &#39;a&#39; to &#39;b&#39;.</span>
<span class="c1">// Does &#39;Movement&#39; imply reassigning memory address of &#39;a&#39; to &#39;b&#39;? NOT.</span>
<span class="c1">// Why?</span>
<span class="c1">// Because there is no difference between move semantics and copy semantics for the memory AT ALL.</span>
<span class="c1">// It&#39;s not possible to describe reason of existance of move semantics using integrated types, like &#39;int&#39; here.</span>
<span class="c1">// Thing is: move semantics just enhance possibilities of c++ classes by &quot;move constructor&quot;, and &quot;move assignment operation&quot;</span>
<span class="c1">// they don&#39;t do anything else, they not work with the memory, not move anything</span>
<span class="c1">// technically this: &#39;int b = (int&amp;&amp;)a&#39; equals to this: &#39;int b = a&#39; and works the Same way</span>
<span class="c1">// move semantics don&#39;t move anything, don&#39;t move addresses, dont move memory</span>
<span class="c1">// all what they do - allow developer to overload, assign and work with two new things in classes - &quot;move constructor&quot;, and &quot;move assignment operation&quot;</span>
<span class="c1">// that&#39;s ALL about move semantics</span>
<span class="c1">// lvalue and rvalue are just Abstractions. They don&#39;t exist in assembler code.</span>
<span class="c1">// You can think of rvalue like &quot;something that need to be assigned&quot;, and &quot;lvalue&quot; - &quot;something that already assigned&quot;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/fa092ac0c26eefd2cde54829c7ad8ad5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fa092ac0c26eefd2cde54829c7ad8ad5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fa092ac0c26eefd2cde54829c7ad8ad5.png" /></a></p>
<p>Несмотря на то, что я "переместил" <code>a</code> в <code>b</code>, адреса обоих переменных - вообще не изменились и никуда не переместились. Операция перемещения тут повела себя так, будто я просто присвоил значения друг другу. Хотя, казалось бы, "перемещение" должно подразумевать обмен адресами, разве нет? Нет.</p>
<p>Таким образом.</p>
<p>Подразумевает ли <code>move</code> семантика - реальное перемещение адресов в памяти? Нет, не подразумевает.</p>
<p>Это самое большое заблуждение разработчиков, которые натыкаются на статьи про <code>move</code> семантику, в том числе на хабре.
"Перемещение" в с++ классах - это просто абстракция. Как и <code>lvalue</code>, <code>rvalue</code>. Не позволяйте себя запутать. Если вам нужо действительно обменять память местами - используйтей указатели и метод <code>std::swap</code>.
Технически выражение <code>int b = (int&amp;&amp;)a</code> полностью эквивалентно <code>int b = a</code>, что мы и видим по памяти, которая у обоих переменных остается той-же самой.</p>
<blockquote>
<p>Вводя <code>move</code> семантику в <code>с++</code>, авторы стандарта просто расширили возможности классов внутри языка, позволив разделять логику в этих классах на копирующую и перемещающую, соответственно.</p>
</blockquote>
<p>Введение <code>move</code> семантики открыло разработчикам <code>с++</code> доступ к конструктору перемещения <code>move constructor</code> и перегрузке оператора присваивания  с перемещением <code>move assignment operation overload</code>. Больше ничего с собой <code>move</code> семантика не  принесла.</p>
<p>Введение конструктора и оператора перемещения для пользовательских классов, позволяет разделять логику копирования и перемещения при помощи техники, под названием <code>perfect forwarding</code>.
Так-же, есть техника фактического обмена данными между вдумя  классами используя подход <code>copy and swap</code>. Оба этих подхода используются разработчиками Unreal Engine, поэтому я рассмотрю их реализацию в этой статье.</p>
<p>Давайте рассмотрим обычный класс, реализующий <code>move</code> семантику.
<div class="highlight"><pre><span></span><code><span class="c1">// classic class that implemetns move semantics</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MoveData</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Default Constructor used to assign value</span>
<span class="w">    </span><span class="c1">// should be explicit to allow copy assignment operator = overload</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">inValue</span><span class="p">)</span><span class="o">:</span><span class="n">value</span><span class="p">(</span><span class="n">inValue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;default constructor called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Copy Constructor</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="n">MoveData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">value</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;copy constructor called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Move Constructor</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="n">MoveData</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// initialize current object with default constructor, so *this will actually have value</span>
<span class="w">        </span><span class="c1">// move constructor should be noexcept</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;move constructor called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">);</span><span class="w"> </span><span class="c1">// activate Move Assignment operator</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Move Assignment Operator</span>
<span class="w">    </span><span class="n">MoveData</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MoveData</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;move assignment called with value = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">        </span><span class="c1">//value = target.value; // since target is rvalue we can reassign it</span>
<span class="w">        </span><span class="c1">//target.value = 0; // and then clear it&#39;s value</span>
<span class="w">        </span><span class="c1">// in c++ 14 and above we can do this:</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will excange memory directly, by casting both targets to rvalue</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// Copy Assignment Operator</span>
<span class="w">    </span><span class="n">MoveData</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">MoveData</span><span class="o">&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">){</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;copy assignment called with value = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// int Assignment Overload for value</span>
<span class="w">    </span><span class="n">MoveData</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">new_value</span><span class="p">){</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_value</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;value assigned = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">new_value</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_value</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// main calls this</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Move Semantics Test ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Variable Based Move Semantics Test ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// variable based tests</span>
<span class="w">        </span><span class="n">MoveData</span><span class="w"> </span><span class="n">MD_Base</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// default constructor vith value 3</span>
<span class="w">        </span><span class="n">MD_Base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// copy-assignment of int number</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Copy Assignment Test ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// test copy assignment</span>
<span class="w">        </span><span class="n">MoveData</span><span class="w"> </span><span class="n">MD_CopyAssign</span><span class="p">(</span><span class="n">MD_Base</span><span class="p">);</span><span class="w"> </span><span class="c1">// will call copy constructor</span>
<span class="w">        </span><span class="n">MD_CopyAssign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MD_Base</span><span class="p">;</span><span class="w"> </span><span class="c1">// will call copy assignment, since MD_Base is lvalue</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Move Assignment Test ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">MoveData</span><span class="w"> </span><span class="n">MD_MoveAssign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">MD_Base</span><span class="p">));</span><span class="w"> </span><span class="c1">// will call move constructor, since MD_Base converted to rvalue</span>
<span class="w">        </span><span class="n">MD_MoveAssign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// will call move assignment since MoveData(5) is rvalue</span>
<span class="w">        </span><span class="n">MD_MoveAssign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">MD_Base</span><span class="p">);</span><span class="w"> </span><span class="c1">// will call move assignment as well, since MD_Base converted to rvalue</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Pointer Based Move Semantics Test ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">MoveData</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// default constructor with value 5</span>
<span class="w">        </span><span class="o">*</span><span class="n">MD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span><span class="w"> </span><span class="c1">// will call move assignment since MoveData(7) makes rvalue</span>
<span class="w">        </span><span class="o">*</span><span class="n">MD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w"> </span><span class="c1">// copy-assignment of int number</span>

<span class="w">        </span><span class="n">MoveData</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">MD_MI</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MoveData</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">MD</span><span class="p">));</span><span class="w"> </span><span class="c1">// will call move constructor</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="n">MD</span><span class="p">;</span>
<span class="w">        </span><span class="k">delete</span><span class="w"> </span><span class="n">MD_MI</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/2bdd1481ef0b4808f54f19a3ba8c2fcf.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2bdd1481ef0b4808f54f19a3ba8c2fcf.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2bdd1481ef0b4808f54f19a3ba8c2fcf.png" /></a></p>
<p>В классе <code>MoveData</code> вы  можете увидеть, как делается логика перемещения.
<div class="highlight"><pre><span></span><code><span class="c1">//value = target.value; // since target is rvalue we can reassign it</span>
<span class="c1">//target.value = 0; // and then clear it&#39;s value</span>
<span class="c1">// in c++ 14 and above we can do this:</span>
<span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
Для перемещения можно использовать прямой обмен значений и  обнуление основного значения или воспользоваться <code>std::exchange</code>. Здесь не применятся <code>swap</code>, то есть значения обмениваются "как есть".</p>
<p>Вы можете видеть, что в коде я использовал <code>std::move</code>, это функция приведения переменной к <code>rvalue</code>, а точнее - способ заставить систему обработать переменную через <code>move</code> семантику.</p>
<p>Давайте рассмотрим основные способы активации <code>move</code> семантики: функцию <code>std::move</code> и шаблон <code>std::forward</code>.</p>
<h3 id="stdmove"><code>std::move</code></h3>
<p><code>std::move</code> - данная функция приводит любую переменную, переданную в нее, в <code>rvalue</code> ссылку, что позволяет, при ее передаче в классы и шаблоны, активировать логику перемещения.
<code>std::move</code> работает точно так-же как и оператор приведения типа к <code>(тип&amp;&amp;)переменная</code>, который я использовал ранее.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">move_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">mt_res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">move_test</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">// two nested std::move&#39;s</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;mt_res = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">mt_res</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/4f6a654fbca990d533932bb7902294c3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4f6a654fbca990d533932bb7902294c3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4f6a654fbca990d533932bb7902294c3.png" /></a></p>
<p>Для чего, в реальной практике, приходится использовать <code>std::move</code>?
Для передачи некопируемых объектов, например экземпляров класса <code>std::unique_ptr</code>.
Рассмотрим код:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="c1"> // std::function</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> // printf</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">unique_ptr_reciver</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">non_copyable_pointer</span><span class="p">){</span>
<span class="w">    </span><span class="o">++*</span><span class="n">non_copyable_pointer</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;ptr value is = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">non_copyable_pointer</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uptr</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="w">    </span><span class="n">unique_ptr_reciver</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">uptr</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/0b52ba4e032deb1cd966f1be570e2dbf.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0b52ba4e032deb1cd966f1be570e2dbf.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0b52ba4e032deb1cd966f1be570e2dbf.png" /></a></p>
<p>Тут я передаю не копируемый умный указатель типа <code>std::unique_ptr</code> в функцию, используя <code>std::move</code>. По другому этот указатель в функцию передать не получится, будет ошибка - <code>call deleted constructor</code>.</p>
<p><a class="glightbox" href="../images/a8de673a57e8114a82a20655310b6966.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a8de673a57e8114a82a20655310b6966.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a8de673a57e8114a82a20655310b6966.png" /></a></p>
<p>Давайте рассмотрим данный пример в применении к Unreal Engine.
Вместо <code>std::unique_ptr</code> в Unreal используется <code>TUniquePtr</code>, а вместо <code>std::move</code> используется <code>MoveTemp</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// Recives TUniquePtr as argument</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">PrintUniquePtrVal</span><span class="p">(</span><span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntPointer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Pointer Value = %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">IntPointer</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="p">}</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// BeginPlay</span>
<span class="c1">// Pass UniquePtr to function as arg</span>
<span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">IntPointer</span><span class="w"> </span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">PrintUniquePtrVal</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">IntPointer</span><span class="p">));</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/319852ad369964abd9015b53b73ec5d8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="319852ad369964abd9015b53b73ec5d8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/319852ad369964abd9015b53b73ec5d8.png" /></a></p>
<p><a class="glightbox" href="../images/014a51ea7612587c573de0814b4e1ab0.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="014a51ea7612587c573de0814b4e1ab0.png" auto_="auto;" display="block;" margin:="margin:" src="../images/014a51ea7612587c573de0814b4e1ab0.png" /></a></p>
<p><a class="glightbox" href="../images/18b12fa1d0290d114118de183ada5afc.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="18b12fa1d0290d114118de183ada5afc.png" auto_="auto;" display="block;" margin:="margin:" src="../images/18b12fa1d0290d114118de183ada5afc.png" /></a></p>
<p>Как вы видите, указатель отлично передается.</p>
<p>Аналогичным способом можно передать и экземпляр <code>TUniqueFunction</code>, который тоже является не копируемым.
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// This function is used to test function pointers</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">TestSummFunc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// This will test TUniqueFunction as arg</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TFunctionAsArgTest</span><span class="p">(</span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Value = %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// BeginPlay</span>
<span class="c1">// Create pointer</span>
<span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FuncPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">TestSummFunc</span><span class="p">;</span>
<span class="c1">//FuncPointer(5,3, TEXT(&quot;TEST&quot;)); // Call pointer directly</span>
<span class="n">TFunctionAsArgTest</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">FuncPointer</span><span class="p">));</span><span class="w"> </span><span class="c1">// Pass pointer as arg</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/d193416c9d00f672977ba2406dc4417f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="d193416c9d00f672977ba2406dc4417f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/d193416c9d00f672977ba2406dc4417f.png" /></a></p>
<p><a class="glightbox" href="../images/6420f9a0b1bcd79b0b1c5349dcc3b9a7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6420f9a0b1bcd79b0b1c5349dcc3b9a7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6420f9a0b1bcd79b0b1c5349dcc3b9a7.png" /></a></p>
<p><a class="glightbox" href="../images/c61f453844ce27c1649460b565a76f30.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c61f453844ce27c1649460b565a76f30.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c61f453844ce27c1649460b565a76f30.png" /></a></p>
<h3 id="stdforward-perfect-forwarding"><code>std::forward</code> и <code>Perfect Forwarding</code></h3>
<p><code>std::forward</code> - это шаблон, который приводит переданное значение к <code>rvalue</code> только в том случае, если оно уже не является <code>rvalue</code>.</p>
<p><a class="glightbox" href="../images/e0c45aa76ed0d3c59211e64d889063b9.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e0c45aa76ed0d3c59211e64d889063b9.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e0c45aa76ed0d3c59211e64d889063b9.png" /></a></p>
<p>Такое избирательное поведение позволяет перенаправлять <code>lvalue</code> логику в копирующий конструктор, а <code>rvalue</code> логику в перемещающий конструктор.</p>
<p>Концепт этот называется <code>prfect forwarding</code>.
Его суть описывается следующим тезисом:</p>
<blockquote>
<p>копируемые объекты должны копироваться, перемещаемые объекты должны перемещаться.</p>
</blockquote>
<p>Таким образом, если в шаблон передается <code>lvalue</code>, то есть постоянное значение с адресом, то оно будет скопировано при передаче. Если в шаблон передается <code>rvalue</code>, то есть временное значение, то оно будет перемещено.</p>
<p>Шаблон <code>std::forward</code> целесообразно применять лишь внутри других шаблонов. Применение его "само по себе" бессмысленно, ведь это не дает никаких дополнительных преимуществ. Чтобы понять это, давайте рассмотрим код:
<div class="highlight"><pre><span></span><code><span class="c1">// Perfect Forwarding demo</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PerfectForwarding</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">inValue</span><span class="p">)</span><span class="o">:</span><span class="n">value</span><span class="p">(</span><span class="n">inValue</span><span class="p">){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;default constructur</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// copy constructor</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="p">(</span><span class="n">PerfectForwarding</span><span class="o">&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">value</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;copy constructur</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="c1">// move constructor</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="p">(</span><span class="n">PerfectForwarding</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">source</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="p">{</span>
<span class="w">        </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">source</span><span class="p">.</span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// call default constructor with new value</span>
<span class="w">        </span><span class="c1">// move constructor should be noexcept</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;move constructor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PerfectForwarding</span><span class="o">&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PerfectForwarding</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_value</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// this template runs perfect forwarding logics</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="p">(</span><span class="n">Type</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ForwardedVar</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ForwardedVar</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="w"> </span><span class="nf">first</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// default constructor</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot; --- </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="p">(</span><span class="n">first</span><span class="p">);</span><span class="w"> </span><span class="c1">// first is lvalue, it has address so this will call copy constructor</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot; --- </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">PerfectForwarding</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="p">(</span><span class="n">PerfectForwarding</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"> </span><span class="c1">// PerfectForwarding(3) is rvalue so this will call move constructor</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/150f3d83ae72609f8009bf4f316fecc3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="150f3d83ae72609f8009bf4f316fecc3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/150f3d83ae72609f8009bf4f316fecc3.png" /></a></p>
<p>Обратите внимание на шаблон <code>run_perfect_forwarding</code>, который принимает тип <code>typename Type</code>. Дело в том, что при передаче шаблону той или иной переменной, без явного указания типа, язык с++ способен автоматически определить этот тип.</p>
<p>Когда мы передаем <code>rvalue</code> переменную в шаблон, туда подставляется <code>rvalue</code> тип, а когда передаем <code>lvalue</code> переменную - в шаблон подставляется <code>lvalue</code> тип.</p>
<p>Давайте я расшифрую поведение шаблона при каждом из вызовов, чтобы было понятнее.
<div class="highlight"><pre><span></span><code><span class="n">PerfectForwarding</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
<span class="c1">// будет заменено на:</span>
<span class="n">PerfectForwarding</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="o">&lt;</span><span class="n">PerfectForwarding</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
<span class="c1">// потому что автоматически определяемый для first тип это PerfectForwarding&amp;</span>
<span class="c1">// почему так? first это переменная с постоянным адресом в памяти, она - lvalue, а тип lvalue ссылки задается &amp; одинарным амперсандом</span>
<span class="c1">// следовательно std::forward передаст временное значение в копирующий `copy` конструктор</span>
<span class="c1">//..</span>
<span class="n">PerfectForwarding</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="p">(</span><span class="n">PerfectForwarding</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">// будет заменено на</span>
<span class="n">PerfectForwarding</span><span class="w"> </span><span class="n">third</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">run_perfect_forwarding</span><span class="o">&lt;</span><span class="n">PerfectForwarding</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">PerfectForwarding</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="c1">// потому что автоматически определяемый для PerfectForwarding(3) тип это PerfectForwarding&amp;&amp;</span>
<span class="c1">// почему так? при образотке PerfectForwarding(3) компилятор создает временное значение с результатом работы конструктора, это временное значение помещается впамять и передается в шаблон. Данное значение - `rvalue`, то есть временное. А тип `rvalue` ссылки задается двойным амперсандом &amp;&amp;</span>
<span class="c1">// следовательно std::forward передаст временное значение в перемещающий `move` конструктор</span>
</code></pre></div>
В Unreal Engine вместо шаблона <code>std::forward</code> используется <code>Forward</code>. Найти его можно в файле: <code>\Runtime\Core\Public\Templates\UnrealTemplate.h</code>.</p>
<p><a class="glightbox" href="../images/e48a1f9ad5e930c68c4dac8d68cf4b71.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e48a1f9ad5e930c68c4dac8d68cf4b71.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e48a1f9ad5e930c68c4dac8d68cf4b71.png" /></a></p>
<h2 id="copy-and-swap-idiom-raii"><code>Copy and Swap</code> idiom, <code>RAII</code></h2>
<p>Идиома копирования и обмена основана на принципе: получение ресурса есть инициализация. На английском это звучит следующим образом: <code>Resource Acquisition Is Initialization (RAII))</code>.
Определение весьма запутанное. На практике реализация <code>copy and swap</code> в объекте позволяет добиться передачи экземпляров этого объекта в функции без копирования. Что бывает очень важно, если работа ведется с объетами, размеры которых достигают гигабайта.
<code>RAII</code> строится вокруг использования <code>move</code> семантики с оператором <code>swap</code>, который обменивает память. Всякий раз, как экземпляру класса, следующего этой идиоме, передается ресурс через <code>move constructor</code> - происходит обмен данных, то есть <code>swap</code>. Это приводит к тому, что присвоенный ресурс и текущий ресурс  просто обмениваются местами.</p>
<p>Лучше всего данный подход описан в статье на <a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">stackoverflow</a>.
Я приведу пример своей реализации.
<div class="highlight"><pre><span></span><code><span class="c1">// this class implements copy and swap idiom - https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CSData</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">CSData</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">inValue</span><span class="p">)</span><span class="o">:</span><span class="n">value</span><span class="p">(</span><span class="n">inValue</span><span class="p">){};</span><span class="w"> </span><span class="c1">// default constructor, will be used in move constructor to initialize object with value</span>
<span class="w">    </span><span class="n">CSData</span><span class="p">(</span><span class="n">CSData</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span><span class="w"> </span><span class="c1">// remove copy constructor</span>
<span class="w">    </span><span class="n">CSData</span><span class="p">(</span><span class="n">CSData</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="k">noexcept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// move constructor</span>
<span class="w">        </span><span class="cm">/**</span>
<span class="cm">         * &gt;The move constructor should generally be noexcept, otherwise some code</span>
<span class="cm">         * (e.g. std::vector resizing logic) will use the copy constructor even when a move constructor would make sense.</span>
<span class="cm">         * Of course, only mark it noexcept if the code inside doesn&#39;t throw exceptions.</span>
<span class="cm">        **/</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;move constructor called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">CSData</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="c1">// initialize current object with default constructor, so *this will actually have value</span>
<span class="w">        </span><span class="n">Swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"> </span><span class="c1">// give this value back to data as rvalue</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Move Assignment Operator</span>
<span class="w">    </span><span class="n">CSData</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">CSData</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">target</span><span class="p">){</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;move assignment called</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">Swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// why this method is friend?</span>
<span class="w">    </span><span class="c1">// frined functions can work with private fields of passed class instances outside of class itself</span>
<span class="w">    </span><span class="c1">// since .value parameter is private, i marked Swap function as friend to access it</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Swap</span><span class="p">(</span><span class="n">CSData</span><span class="w"> </span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">CSData</span><span class="w"> </span><span class="o">&amp;</span><span class="n">second</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_value</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// friend functions can work with private fields of friend class instances</span>
<span class="c1">// CSData class is friend to this function</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Swap</span><span class="p">(</span><span class="n">CSData</span><span class="w"> </span><span class="o">&amp;</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">CSData</span><span class="w"> </span><span class="o">&amp;</span><span class="n">second</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// by swapping the members of two objects,</span>
<span class="w">    </span><span class="c1">// the two objects are effectively swapped</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">first</span><span class="p">.</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;=== Copy and Swap Idiom Test ===</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">CSData</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">5</span><span class="p">};</span>
<span class="w">    </span><span class="n">CSData</span><span class="w"> </span><span class="n">Data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Data</span><span class="p">);</span><span class="w"> </span><span class="c1">// move value = 5 to Data 1</span>
<span class="w">    </span><span class="n">CSData</span><span class="w"> </span><span class="n">Data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">3</span><span class="p">};</span><span class="w"> </span><span class="c1">// make Data 2 with value of 3</span>
<span class="w">    </span><span class="n">Data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">Data1</span><span class="p">);</span><span class="w"> </span><span class="c1">// move value = 5 to Data 2, value 3 will be swapped to Data 1</span>
<span class="w">    </span><span class="c1">// now Data 2 has value of 5, Data 1 and Data has value of 0</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;data address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Data</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, data value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Data</span><span class="p">.</span><span class="n">get_value</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;data address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Data1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, data value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Data1</span><span class="p">.</span><span class="n">get_value</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;data address = &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Data2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, data value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Data2</span><span class="p">.</span><span class="n">get_value</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/7ed0e8ac4ddd5ba25678bfd38de4b86a.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7ed0e8ac4ddd5ba25678bfd38de4b86a.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7ed0e8ac4ddd5ba25678bfd38de4b86a.png" /></a></p>
<p>В этом коде я создал класс <code>CSData</code>, который обменивает переданные ему объекты друг с другом. Для тестирования  я создал <code>3</code> объекта - <code>Data</code>, <code>Data1</code> и  <code>Data2</code>. Причем у объекта <code>Data</code> было значение <code>5</code>, которое, в процессе обмена с <code>Data1</code>  и <code>Data2</code>, перебирается в объект <code>Data2</code>.
Классы, реализующие <code>copy and swap idiom</code> есть в <code>Unreal Engine</code>. Это, в частности, <code>TFunction</code> и <code>TUniqueFunction</code>.</p>
<p><a class="glightbox" href="../images/2f46a02a714bdd47c87e63851a6b35a7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2f46a02a714bdd47c87e63851a6b35a7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2f46a02a714bdd47c87e63851a6b35a7.png" /></a></p>
<h2 id="typedef">Команда <code>typedef</code> и ее применение</h2>
<p>Данная команда создает псевдоним для типа.
<code>typedef</code> встречается в коде <code>Unreal</code> довольно часто, поэтому освежим память и рассмотрим ее использование.</p>
<p>Формат команды:
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="n">type_name</span><span class="w"> </span><span class="n">type_name_alias</span><span class="p">;</span><span class="w"> </span><span class="c1">// создает псевдоним для типа</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">имя_типа</span><span class="w"> </span><span class="n">псевдоним_типа</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">MyCustomIntAlias</span><span class="p">;</span>
</code></pre></div></p>
<h2 id="_17">Упрощение шаблонов</h2>
<p>Самое очевидное применение <code>typedef</code> относится к упрощению шаблонов.</p>
<p>Рассмотрим следующую конструкцию:
<div class="highlight"><pre><span></span><code><span class="n">Data</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">D1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>
<span class="n">Data</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">D2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">);</span>
<span class="n">Data</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">D3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;3&quot;</span><span class="p">);</span>
</code></pre></div>
Писать такое всякий раз может быть не очень удобно. К тому-же шаблоны бывают крайне сложные и с длинным набором рагументов.</p>
<p>Выносим <code>Data&lt;std::string&gt;</code> в <code>typedef</code>:
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StrData</span><span class="p">;</span>
<span class="n">StrData</span><span class="w"> </span><span class="o">*</span><span class="n">D1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StrData</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">);</span>
<span class="n">StrData</span><span class="w"> </span><span class="o">*</span><span class="n">D2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StrData</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">);</span>
<span class="n">StrData</span><span class="w"> </span><span class="o">*</span><span class="n">D3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">StrData</span><span class="p">(</span><span class="s">&quot;3&quot;</span><span class="p">);</span>
</code></pre></div>
Рассмотрим еще один пример, на более длинном шаблоне, например <code>std::shared_ptr</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Typedef Examples</span>
<span class="k">auto</span><span class="w"> </span><span class="n">function_for_alias</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Value</span><span class="p">){</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">DataIntPtr</span><span class="p">;</span>
<span class="w">    </span><span class="n">DataIntPtr</span><span class="w"> </span><span class="nf">D</span><span class="p">(</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">//= std::make_shared&lt;Data&lt;int&gt;&gt;(0);</span>
<span class="w">    </span><span class="o">*</span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;D is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function_for_alias</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;D is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Обратите внимание, что функция возвращает <code>auto</code>, в <code>main</code> мы так-же используем <code>auto</code>, что не мешает работе кода. Хотя <code>typedef</code> находится вообще в другом пространстве.</p>
<p><a class="glightbox" href="../images/446cf63f439515871f68cc61343ea387.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="446cf63f439515871f68cc61343ea387.png" auto_="auto;" display="block;" margin:="margin:" src="../images/446cf63f439515871f68cc61343ea387.png" /></a></p>
<p>Так-же, вполне можно создавать вполне осознанные типы. К примеру сделать из <code>std::pair&lt;double, double&gt;</code> тип точки - <code>Point</code>. Хотя я бы рекомендовал использовать собственную структуру.
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Point</span><span class="p">;</span>
<span class="n">Point</span><span class="w"> </span><span class="nf">CombinePoints</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="n">B</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="p">({</span><span class="n">A</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">.</span><span class="n">second</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="p">.</span><span class="n">second</span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div></p>
<h2 id="_18">Работа с указателями</h2>
<p>В <code>typedef</code> можно размещать указатели. Причем как обычных переменных, так и функций.</p>
<p>В случае с обычными переменнами - ничего особенного, выглядит это так:
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">IntDataRaw</span><span class="p">;</span>
<span class="n">IntDataRaw</span><span class="w"> </span><span class="n">TestPointerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
Куда интереснее код выглядит, если через <code>typedef</code> надо задать указатель на функцию.</p>
<p>В этом случае вам помогут два шаблона:
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="n">return_val</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">PointerName</span><span class="p">)(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">ArgN</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function_name</span><span class="p">)</span><span class="w"> </span><span class="n">PointerName</span><span class="p">;</span>
</code></pre></div>
где:
<code>return_val</code> - возвращаемое значение функции.
<code>PointerName</code> - название указателя
<code>Arg1, Arg2 ... ArgN</code> - аргументы функции
Второй подход использует метод <code>decltype</code>, который возвращает тип функции. Поскольку мы скармливаем в <code>decltype</code> адрес функции (&amp;) метод <code>decltype</code> возвращает указатель на этот адрес, обернутый в тип. Далее <code>typedef</code> задает псевдоним для данного типа.</p>
<p>Примеры использования:
<div class="highlight"><pre><span></span><code><span class="c1">// Data container i used in examples</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">StoredType</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Data</span><span class="p">{</span>
<span class="w">    </span><span class="n">StoredType</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// constructor</span>
<span class="w">    </span><span class="c1">// if constructor value is template class and because of it - unknown - just use template class with () in my case it&#39;s StoredType()</span>
<span class="w">    </span><span class="n">Data</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StoredType</span><span class="w"> </span><span class="n">inValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StoredType</span><span class="p">())</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Value</span><span class="p">(</span><span class="n">inValue</span><span class="p">){};</span>
<span class="w">    </span><span class="c1">// overload operator `=` for float assignment</span>
<span class="w">    </span><span class="n">Data</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StoredType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Val</span><span class="p">){</span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Val</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//get_instance().Value = Val;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// very short singleton experiment</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="n">StoredType</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">get_instance</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="n">StoredType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">INSTANCE</span><span class="p">;</span><span class="w"> </span><span class="c1">// statics are stored in separate stack and initialized only once, so we can always get access to one global object instance</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">INSTANCE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// getter</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">StoredType</span><span class="w"> </span><span class="n">getValue</span><span class="p">(){</span>
<span class="w">        </span><span class="c1">//return get_instance().Value;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// class for function pointer in typedef experiments</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FPClass</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">InFunction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Text</span><span class="p">){</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">IncrementalStatic</span><span class="p">;</span>
<span class="w">        </span><span class="o">++</span><span class="n">IncrementalStatic</span><span class="p">;</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;In Method Got Text = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">Text</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">IncrementalStatic</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="c1">// function for typedef function pointer experiments</span>
<span class="k">auto</span><span class="w"> </span><span class="n">function_for_alias</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Value</span><span class="p">){</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">DataIntPtr</span><span class="p">;</span>
<span class="w">    </span><span class="n">DataIntPtr</span><span class="w"> </span><span class="nf">D</span><span class="p">(</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="c1">//= std::make_shared&lt;Data&lt;int&gt;&gt;(0);</span>
<span class="w">    </span><span class="o">*</span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Function for Alias Got Value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// typedef function pointers</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">FuncPointerAlias</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function_for_alias</span><span class="p">)</span><span class="w"> </span><span class="n">DecltypeFuncPointer</span><span class="p">;</span>
<span class="c1">// typedef class pointers</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ClassMethodPointer</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">decltype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">FPClass</span><span class="o">::</span><span class="n">InFunction</span><span class="p">)</span><span class="w"> </span><span class="n">DecltypeClassMethodPointer</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="k">typedef</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">IntDataRaw</span><span class="p">;</span>
<span class="w">    </span><span class="n">IntDataRaw</span><span class="w"> </span><span class="n">TestPointerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Data</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">function_for_alias</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;D is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// basic function pointer</span>
<span class="w">        </span><span class="n">FuncPointerAlias</span><span class="w"> </span><span class="n">func_pointer_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function_for_alias</span><span class="p">;</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func_pointer_alias</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// decltype() function pointer</span>
<span class="w">        </span><span class="n">DecltypeFuncPointer</span><span class="w"> </span><span class="n">dt_func_pointer_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function_for_alias</span><span class="p">;</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt_func_pointer_alias</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// basic class method pointer</span>
<span class="w">        </span><span class="n">ClassMethodPointer</span><span class="w"> </span><span class="n">class_pointer_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FPClass</span><span class="o">::</span><span class="n">InFunction</span><span class="p">;</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">class_pointer_alias</span><span class="p">(</span><span class="s">&quot;Test ClassMethodPointer&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="c1">// decltype class method pointer</span>
<span class="w">        </span><span class="n">DecltypeClassMethodPointer</span><span class="w"> </span><span class="n">dt_class_pointer_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FPClass</span><span class="o">::</span><span class="n">InFunction</span><span class="p">;</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt_class_pointer_alias</span><span class="p">(</span><span class="s">&quot;Test DecltypeClassMethodPointer&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;result is set to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/0851ab49f9be36f095464d0248d96f6f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="0851ab49f9be36f095464d0248d96f6f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/0851ab49f9be36f095464d0248d96f6f.png" /></a></p>
<p>Обратите внимание, что при указании <code>typedef</code> на метод класса я использую <code>static</code>  метод. Не <code>static</code> методы функций таким образом в <code>typedef</code> поместить не получится из-за привязки к экземпляру класса.</p>
<h2 id="typedef-typename"><code>typedef typename</code></h2>
<p>Иногда на глаза попадаются такие конструкции:
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">class</span><span class="o">::</span><span class="n">value_type</span><span class="w"> </span><span class="n">value_type</span><span class="p">;</span>
</code></pre></div>
Кажется, будто ключевое слово <code>typename</code> нарушает общую структуру команды, но это не так. Ключевое слово <code>typename</code> тут всего-лишь гарантирует для компилятора, что <code>class::value_type</code> будет именно типом или классом.</p>
<h2 id="typedef_1"><code>typedef</code> и шаблонные аргументы</h2>
<p>Используя <code>typedef</code> можно создавать синонимы не только для обычных классов, но и для шаблонных классов.
<div class="highlight"><pre><span></span><code><span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">First</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Second</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">third</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SomeType</span><span class="p">;</span>
<span class="k">template</span><span class="o">&lt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Second</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">TypedefName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SomeType</span><span class="o">&lt;</span><span class="n">OtherType</span><span class="p">,</span><span class="w"> </span><span class="n">Second</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div></p>
<h2 id="using-typedef"><code>using</code> вместо <code>typedef</code></h2>
<p>Директиву <code>using</code> можно использовать для определения синонима типа, взамен <code>typedef</code>.
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">OtherType</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span><span class="w">  </span><span class="c1">// Старый стиль</span>
<span class="k">using</span><span class="w"> </span><span class="n">OtherType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span><span class="w"> </span><span class="c1">// Новый синтаксис</span>
</code></pre></div></p>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            К началу
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      aftamat4ik
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.top", "toc.follow"], "search": "../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "\u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0432 \u0431\u0443\u0444\u0435\u0440", "clipboard.copy": "\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440", "search.result.more.one": "\u0415\u0449\u0451 1 \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.more.other": "\u0415\u0449\u0451 # \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.none": "\u0421\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e", "search.result.one": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e 1 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435", "search.result.other": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439: #", "search.result.placeholder": "\u041d\u0430\u0447\u043d\u0438\u0442\u0435 \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430", "search.result.term.missing": "\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442", "select.version": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0435\u0440\u0441\u0438\u044e"}}</script>
    
    
      <script src="../assets/javascripts/bundle.dff1b7c8.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>