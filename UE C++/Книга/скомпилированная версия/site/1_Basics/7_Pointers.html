
<!doctype html>
<html lang="ru" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Справочник Unreal Engine">
      
      
        <meta name="author" content="aftamat4ik">
      
      
      
        <link rel="prev" href="6_Logging.html">
      
      
        <link rel="next" href="8_ModernCpp.html">
      
      
      <link rel="icon" href="../assets/icon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.3.2">
    
    
      
        <title>Указатели - Справочник Unreal Engine</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.30068a00.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.85d0ee34.min.css">
      
      


    
    
      
        <script src="https://unpkg.com/iframe-worker/shim"></script>
      
    
    
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Перейти к содержанию
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Верхний колонтитул">
    <a href="../index.html" title="Справочник Unreal Engine" class="md-header__button md-logo" aria-label="Справочник Unreal Engine" data-md-component="logo">
      
  <img src="../assets/icon.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Справочник Unreal Engine
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Указатели
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Поиск" placeholder="Поиск" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Поиск">
        
        <button type="reset" class="md-search__icon md-icon" title="Очистить" aria-label="Очистить" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Инициализация поиска
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Вкладки" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../index.html" class="md-tabs__link">
        
  
    
  
  Главная

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="1_First_Project.html" class="md-tabs__link">
          
  
  Основы

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../2_Core/1_Delegates.html" class="md-tabs__link">
          
  
  Ключевые системы

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../3_Advanced/1_HUD.html" class="md-tabs__link">
          
  
  Продвинутая разработка

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../4_Resolving%20Issues/LiveCoding_Encoding_Issues.html" class="md-tabs__link">
          
  
  Решение проблем

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../5_Tips/Change_Asset_Icons.html" class="md-tabs__link">
          
  
  Советы

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Навигация" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../index.html" title="Справочник Unreal Engine" class="md-nav__button md-logo" aria-label="Справочник Unreal Engine" data-md-component="logo">
      
  <img src="../assets/icon.png" alt="logo">

    </a>
    Справочник Unreal Engine
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Главная
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Основы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Основы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="1_First_Project.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Создаем первый проект в Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="2_Engine_Introduction.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Знакомство с движком
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="3_CPP_Recommendations.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Рекомендации по написанию кода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="4_SimplePlugin.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Создание простейшего плагина для Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="5_Macroses_Reflection_System.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Макросы Reflection System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="6_Logging.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Печать информации в лог
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Указатели
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="7_Pointers.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Указатели
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Содержание">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Содержание
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Что такое указатели
  </a>
  
    <nav class="md-nav" aria-label="Что такое указатели">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Оператор *&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Ручное управление памятью
  </a>
  
    <nav class="md-nav" aria-label="Ручное управление памятью">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Утечки памяти
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Подготовка к работе
  </a>
  
    <nav class="md-nav" aria-label="Подготовка к работе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Добавляем компонент
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    Зависимости сборки
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    Добавляем компонент к персонажу
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreal-engine" class="md-nav__link">
    Обычные указатели в Unreal Engine
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreal-engine_1" class="md-nav__link">
    Умные указатели в Unreal Engine
  </a>
  
    <nav class="md-nav" aria-label="Умные указатели в Unreal Engine">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    Управляемые умные указатели
  </a>
  
    <nav class="md-nav" aria-label="Управляемые умные указатели">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tobjectptr-raw-object-pointer" class="md-nav__link">
    TObjectPtr - замена raw object pointer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tweakobjectptr" class="md-nav__link">
    TWeakObjectPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsoftobjectptr" class="md-nav__link">
    TSoftObjectPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tassetptr" class="md-nav__link">
    TAssetPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsoftclassptr" class="md-nav__link">
    TSoftClassPtr
  </a>
  
    <nav class="md-nav" aria-label="TSoftClassPtr">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-asset" class="md-nav__link">
    Для DATA ASSET'ов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    Работа с Blueprint классами
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    Неуправляемые умные указатели
  </a>
  
    <nav class="md-nav" aria-label="Неуправляемые умные указатели">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tsharedptr" class="md-nav__link">
    TSharedPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsharedref" class="md-nav__link">
    TSharedRef
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tweakptr" class="md-nav__link">
    TWeakPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuniqueptr" class="md-nav__link">
    TUniquePtr
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    Указатели на функции
  </a>
  
    <nav class="md-nav" aria-label="Указатели на функции">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    Классические указатели на функции в объекте
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stl" class="md-nav__link">
    Указатели на функцию в стандартной библиотеке (STL)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unreal" class="md-nav__link">
    Указатели на функцию в Unreal
  </a>
  
    <nav class="md-nav" aria-label="Указатели на функцию в Unreal">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tfunction" class="md-nav__link">
    TFunction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tfunctionref" class="md-nav__link">
    TFunctionRef
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuniquefunction" class="md-nav__link">
    TUniqueFunction
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    Лямбды в С++
  </a>
  
    <nav class="md-nav" aria-label="Лямбды в С++">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    Формат лямбда-выражения
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    Спецификаторы
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    Псевдонимы спецификаторов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    Автозапуск лямбды
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    Обращение к методам класса из тела лямбды
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    Вызов метода класса из тела лямбды
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    Передача лямбды в функцию по указателю
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreal-engine_2" class="md-nav__link">
    Лямбды в Unreal Engine
  </a>
  
    <nav class="md-nav" aria-label="Лямбды в Unreal Engine">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unreal_1" class="md-nav__link">
    Лямбды как аргументы функций в Unreal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    Пример использования лямбд для сортировки массива
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blueprint_1" class="md-nav__link">
    Пузырьковая сортировка на blueprint
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tsoftobjectptr_1" class="md-nav__link">
    Загрузка ассетов из TSoftObjectPtr и генерация компонентов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#skeletalmesh" class="md-nav__link">
    Генерация SkeletalMesh компонента с копированием настроек
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="8_ModernCpp.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Возможности современного c++
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="9_Working_With_Strings.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа со строками
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="10_Timers_In_%D0%A1%2B%2B.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Таймеры
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="11_Instances_Access.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Доступ к различным сущностям
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_12" >
        
          <label class="md-nav__link" for="__nav_2_12" id="__nav_2_12_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Debug
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_12_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_12">
            <span class="md-nav__icon md-icon"></span>
            Debug
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="Debug/Debug_Asserts.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Asserts
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="Debug/Debug_Console_Commands.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Debug Console Commands
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Ключевые системы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Ключевые системы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/1_Delegates.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    События и Делегаты
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/2_Components.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Компоненты в Unreal Engine
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/3_SubObjects.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Суб Объекты
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/4_Multithreading.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Многопоточность
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/5_Function_Libraries.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Библиотеки Функций для Blueprint
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/6_Latent_And_Async_Actions.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Latent и Async Action
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/7_Gameplay_Tags.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gameplay Tags
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/8_DataAssets_AssetManager.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа с ассетами и данными
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/9_FileSystem.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Работа с файловой системой
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/10_Anim_Instance.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Anim Instance
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/11_SubSystems.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Подсистемы
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../2_Core/12.%20UObject%20Interface.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UObject Interface или UInterface
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Продвинутая разработка
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Продвинутая разработка
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/1_HUD.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    HUD или Heads-up Display
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/2_UFUNCTION_Wildcard.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UFUNCTION Wildcard
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/3_Slate%20Runtime.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Slate Runtimе, введение в Slate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/4_UMG.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UMG
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/5_K2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    K2
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/6_Registe_New_Asset_Type.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Регистрируем новый тип ассета
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/7_ACharacter_And_Enhanced%20Input.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ACharacter и Enhanced Input
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/8_Gameplay_Ability_System.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Gameplay Ability System
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/9_Global_Data_Access.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глобальнный доступ к данным
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../3_Advanced/10_Global_Event_Bus.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Глобальная шина событий
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Решение проблем
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Решение проблем
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/LiveCoding_Encoding_Issues.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Проблемы с кодировкой в LiveCoding
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/Reset_Project.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Сброс (Reset) проекта
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../4_Resolving%20Issues/generatedh_Problems.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Проблемы с файлом .generated.h
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Советы
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Советы
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Change_Asset_Icons.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Change Asset Icons
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Character_And_EnhancedInput.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Character Boilerplate with Enhanced Input Setup
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/DefaultToSelf_WorldContext.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DefaultToSelf WorldContext
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Different_UPROPERTY.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Переменные разных типов
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/GameInputMode.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Изменение GameInputMode
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Get_UScriptStruct_FromStruct.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ::UScriptStruct из встроенной структуры
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Input_Binding.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    События ввода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Iterate_TMap.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Iterate TMap
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Read_Blueprint_Properties.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Чтение параметров Blueprint класса
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Return_UObject.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Возвращение UObject по ссылке из функции
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Run_Console_Commands.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Запуск консольных команд
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Screen_Size.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Размер экрана
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Slate_Snippets.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Полезные сниппеты Slate
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Spawn_Actors.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Spawn, призыв объектов
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Time_Measuring.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Замер времени исполнения кода
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Trace.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Trace
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/UEnum_To_String.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UEnum to FString
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/UObject_Base_Class.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    UObject Base Class
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/Variable_Type_Print_Template.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Шаблон для печати типа переменной
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../5_Tips/struct_operator%3D%3D.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    struct и оператор ==
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Содержание">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Содержание
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    Что такое указатели
  </a>
  
    <nav class="md-nav" aria-label="Что такое указатели">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    Оператор *&amp;
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    Ручное управление памятью
  </a>
  
    <nav class="md-nav" aria-label="Ручное управление памятью">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    Утечки памяти
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    Подготовка к работе
  </a>
  
    <nav class="md-nav" aria-label="Подготовка к работе">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    Добавляем компонент
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    Зависимости сборки
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    Добавляем компонент к персонажу
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreal-engine" class="md-nav__link">
    Обычные указатели в Unreal Engine
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreal-engine_1" class="md-nav__link">
    Умные указатели в Unreal Engine
  </a>
  
    <nav class="md-nav" aria-label="Умные указатели в Unreal Engine">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    Управляемые умные указатели
  </a>
  
    <nav class="md-nav" aria-label="Управляемые умные указатели">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tobjectptr-raw-object-pointer" class="md-nav__link">
    TObjectPtr - замена raw object pointer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tweakobjectptr" class="md-nav__link">
    TWeakObjectPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsoftobjectptr" class="md-nav__link">
    TSoftObjectPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tassetptr" class="md-nav__link">
    TAssetPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsoftclassptr" class="md-nav__link">
    TSoftClassPtr
  </a>
  
    <nav class="md-nav" aria-label="TSoftClassPtr">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-asset" class="md-nav__link">
    Для DATA ASSET'ов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blueprint" class="md-nav__link">
    Работа с Blueprint классами
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    Неуправляемые умные указатели
  </a>
  
    <nav class="md-nav" aria-label="Неуправляемые умные указатели">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tsharedptr" class="md-nav__link">
    TSharedPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tsharedref" class="md-nav__link">
    TSharedRef
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tweakptr" class="md-nav__link">
    TWeakPtr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuniqueptr" class="md-nav__link">
    TUniquePtr
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    Указатели на функции
  </a>
  
    <nav class="md-nav" aria-label="Указатели на функции">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    Классические указатели на функции в объекте
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stl" class="md-nav__link">
    Указатели на функцию в стандартной библиотеке (STL)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unreal" class="md-nav__link">
    Указатели на функцию в Unreal
  </a>
  
    <nav class="md-nav" aria-label="Указатели на функцию в Unreal">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tfunction" class="md-nav__link">
    TFunction
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tfunctionref" class="md-nav__link">
    TFunctionRef
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tuniquefunction" class="md-nav__link">
    TUniqueFunction
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    Лямбды в С++
  </a>
  
    <nav class="md-nav" aria-label="Лямбды в С++">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    Формат лямбда-выражения
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    Спецификаторы
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    Псевдонимы спецификаторов
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    Автозапуск лямбды
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    Обращение к методам класса из тела лямбды
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    Вызов метода класса из тела лямбды
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    Передача лямбды в функцию по указателю
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#unreal-engine_2" class="md-nav__link">
    Лямбды в Unreal Engine
  </a>
  
    <nav class="md-nav" aria-label="Лямбды в Unreal Engine">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unreal_1" class="md-nav__link">
    Лямбды как аргументы функций в Unreal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    Пример использования лямбд для сортировки массива
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blueprint_1" class="md-nav__link">
    Пузырьковая сортировка на blueprint
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tsoftobjectptr_1" class="md-nav__link">
    Загрузка ассетов из TSoftObjectPtr и генерация компонентов
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#skeletalmesh" class="md-nav__link">
    Генерация SkeletalMesh компонента с копированием настроек
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">Указатели</h1>
<p>Изначально я не собирался посвящать этой теме отдельную статью. Хотя-бы потому что мои статьи не являются учебником, это просто - сборник рецептов и экспериментов.</p>
<p>Так почему же я сейчас пишу это?
В чате для программистов я, в один момент, показал участок своего кода.</p>
<p><a class="glightbox" href="../images/91890873f53de961c717e650b2772f3c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="91890873f53de961c717e650b2772f3c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/91890873f53de961c717e650b2772f3c.png" /></a></p>
<p>Конкретно этот.</p>
<p>И одному из участников дискуссии стало интересно - нет ли у меня тут утечки памяти. Ведь я, по его мнению, постоянно "выделяю  память" внутри цикла, и не "очищаю ее".</p>
<p>Вот в этом участке:
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">USceneComponent</span><span class="o">*</span><span class="w"> </span><span class="n">pConnectedComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">USceneComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ChildComponents</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</code></pre></div>
Причем это замечание мне сделал довольно опытный коллега, работающий в энтерпрайз разработке (правда на <code>C#</code>) уже 5 или 6 лет… или сколько там прошло с <code>2016</code> года.</p>
<p>Надо сказать, что спорщик из меня "так себе", к тому-же особым сверх "авторитетом" среди других кодеров я не пользуюсь. Никогда за таким не следил.</p>
<p>Так что не уверен, что тот спор мной был выигран. Но важнее другое - я понял, что многие люди, даже опытные, понятия не имеют как работают указатели. Для них это такая "магия".</p>
<p>Они не понимают когда происходит выделение памяти, не понимают что вообще из себя представляет "указатель", как работает память и ее адреса.</p>
<p>Именно поэтому я постараюсь покрыть большинство вопросов по указателям для тебя, дорогой читатель.</p>
<h2 id="_2">Что такое указатели</h2>
<p>Начнем с того, что все переменные - помещаются в оперативную память. То место, куда они помещаются, называется <code>heap</code>, то есть куча.</p>
<!-- ![dd7a4e398a5e5799ec5a33a72edbc657.png](../images/dd7a4e398a5e5799ec5a33a72edbc657.png){align=center; display=block; margin: 0 auto;} -->

<p>Почему Куча? Потому что объекты, переменные и функции помещаются в память в произвольном порядке. Точнее в том, в котором они вызываются внутри кода.</p>
<p>Поскольку программе надо знать, где находятся те или иные переменные - адрес каждого элемента кучи сохраняется в т.н. стек указателей.</p>
<blockquote>
<p>Указатели - это переменные, значения которых соответствуют адресам ячеек в памяти.</p>
</blockquote>
<p>Как в картотеке карточка указывает в каком каталоге находится та или иная папка, так и указатель указывает где находится переменная или функция.</p>
<p><a class="glightbox" href="../images/ae82aa4682a80c3d835d6a5e9db20c9a.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ae82aa4682a80c3d835d6a5e9db20c9a.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ae82aa4682a80c3d835d6a5e9db20c9a.png" /></a></p>
<p>Можно ли увидеть адрес, размещенный внутри указателя? Да, можно, для этого достаточно напечатать указатель. Обычным <code>printf</code> или <code>cout</code>.
Я создал простенькое <code>c++</code> приложение, чтобы продемонстрировать в нем основы указателей.
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// берем адрес, в котором находится Num и помещаем в указатель</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">pNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Num</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pNum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Тут я создаю переменную <code>Num</code>, которой присваиваю значение <code>10</code>.
Далее я беру адрес этой переменной через амперсанд, то есть <code>&amp;Num</code> и печатаю его.</p>
<p>Давайте посмотрим, какой результат выдает этот код при компиляции.</p>
<p><a class="glightbox" href="../images/4651273ad2f45e60e0540b0d690a1ee4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4651273ad2f45e60e0540b0d690a1ee4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4651273ad2f45e60e0540b0d690a1ee4.png" /></a></p>
<p>Сверху мы видим значение <code>int Num</code>, это <code>10</code>, а снизу значение <code>int* pNum</code> и это как раз - адрес переменной <code>Num</code> в памяти <code>000000B659D8FC74</code>. (у меня компиляция под x64, поэтому адрес указателя занимает <code>8</code> байт)</p>
<p>Как получить данные, на которые указывает указатель?</p>
<p>Для этого перед указателем надо прописать <code>*</code>, таким образом.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Addres = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pNum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Addres Value = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pNum</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div>
Если теперь скомпилировать код, то увидим следующее:</p>
<p><a class="glightbox" href="../images/7433adc6fbb7ec5600562a42389e7c91.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7433adc6fbb7ec5600562a42389e7c91.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7433adc6fbb7ec5600562a42389e7c91.png" /></a></p>
<p>Рассмотрим частные случаи работы с указателями.</p>
<p>Указателю нельзя присвоить значение "напрямую":
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
</code></pre></div>
Текст ошибки: <code>a value of type "int" cannot be used to initialize an entity of type "int *"</code>;
Так делать тоже нельзя, хотя ошибку и не напишет:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">pTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="mi">100</span><span class="p">;</span>
</code></pre></div>
Почему? Указатель хранит адрес в памяти. А число 100 это временное <code>rvalue</code> значение, у которого еще нет постоянного адреса в памяти.</p>
<p>Исключением является тип <code>char*</code>:
<div class="highlight"><pre><span></span><code><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">pTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;My Text!&quot;</span><span class="p">;</span>
</code></pre></div>
Это исключительно особенность данного типа, упрощающая работу со строками Она унаследована от языка <code>c</code>.</p>
<h3 id="_3">Оператор <code>*&amp;</code></h3>
<p>Обратите внимание, что команды <code>&amp;</code> и <code>*</code> являются взаимоисключающими. Первая - берет адрес, а вторая - берет значение по этому адресу.</p>
<p>Поэтому вывод двух следующих строк будет одинаковым.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Number = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;*&amp; = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*&amp;</span><span class="n">Num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/df63e28fef15abf178c7709be02b12fd.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="df63e28fef15abf178c7709be02b12fd.png" auto_="auto;" display="block;" margin:="margin:" src="../images/df63e28fef15abf178c7709be02b12fd.png" /></a></p>
<p>Тем не менее, в некоторых ситуациях, использование очень странного оператора <code>*&amp;</code> вполне возможно.</p>
<p>Вот пример:
<div class="highlight"><pre><span></span><code><span class="c1">// Function that should return two objects</span>
<span class="n">UFUNCTION</span><span class="p">(</span><span class="n">BlueprintCallable</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Custom Functions|UObjectReturn&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">meta</span><span class="o">=</span><span class="p">(</span><span class="n">HideSelfPin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">))</span>
<span class="kt">void</span><span class="w"> </span><span class="n">TwoUObjectsReturn</span><span class="p">(</span><span class="n">UObject</span><span class="w"> </span><span class="o">*&amp;</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">UObject</span><span class="w"> </span><span class="o">*&amp;</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetMutableDefault</span><span class="o">&lt;</span><span class="n">UObject</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetMutableDefault</span><span class="o">&lt;</span><span class="n">UObject</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>
Этот код используется, чтобы вернуть из функции два инициализированных <code>UObject'а</code>.</p>
<p><a class="glightbox" href="../images/65a492b9d2aeef8140e00e8e81d46f20.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="65a492b9d2aeef8140e00e8e81d46f20.png" auto_="auto;" display="block;" margin:="margin:" src="../images/65a492b9d2aeef8140e00e8e81d46f20.png" /></a></p>
<h3 id="_4">Ручное управление памятью</h3>
<p>Из <code>c</code> в языке <code>c++</code> имеется следующий набор функций:
<code>void *malloc(size_t bytes)</code> - выдеделение памяти, <code>Memory Allocation</code>.
<code>void *calloc(size_t num, size_t size)</code> - тоже выделяет память, но перед выделением присваивает новым байтам значение <code>0</code>, <code>Clear Allocation</code>.
С точки зрения кодера обе функции работают абсолютно одинаково, с небольшой поправкой на нулевые значения.</p>
<p>Приведенные ниже сегменты кода делают одно и то-же.
<div class="highlight"><pre><span></span><code><span class="c1">// не забываем про \0 - итоговая длинна строки всегда на 1 символ больше</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">string_to_load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;| Test |&quot;</span><span class="p">;</span>
<span class="c1">// Выделяем память под strlen(string_to_load) + 1 букв размерности char</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_load</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="c1">// Выделяем память под strlen(string_to_load) + 1 букв char, предварительно очищая память</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_load</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
</code></pre></div>
Разницу между <code>malloc</code> и <code>calloc</code> можно увидеть, напечатав выделенную память:
<div class="highlight"><pre><span></span><code><span class="c1">// не забываем про \0 - итоговая длинна строки всегда на 1 символ больше</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">string_to_load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;| Test |&quot;</span><span class="p">;</span>
<span class="c1">// Выделяем память под strlen(string_to_load) + 1 букв размерности char</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_load</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="c1">// Выделяем память под strlen(string_to_load) + 1 букв char, предварительно очищая память</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_load</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="c1">// смотрим что внутри памяти находится сейчас</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Malloc Content: &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Calloc Content: &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/fe80b6508325315682da2403d55664f1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fe80b6508325315682da2403d55664f1.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fe80b6508325315682da2403d55664f1.png" /></a></p>
<p>Как вы видите, содержимое памяти, выделенное через <code>malloc</code> небыло очищено и содержит какой-то мусор.</p>
<p>Ну а память выделенная через <code>calloc</code> содержит пустоту.</p>
<p>Таким образом <code>malloc</code> быстрее, а <code>calloc</code> безопаснее.</p>
<p>Рассмотрим запись данных в выделенную память на примере <code>c</code> строки <code>string_to_load</code>.
<div class="highlight"><pre><span></span><code><span class="n">strcpy</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">string_to_load</span><span class="p">);</span>
</code></pre></div>
Что если мы бы хотели добавить к <code>c</code> строке дополнительный суффикс?
Это возможно сделать, изменив память через оператор <code>void *realloc(void *ptr, size_t newsize)</code>. Данный оператор перераспределяет уже выделенную память, причем как в большую, так и в меньшую сторону.</p>
<p>В нашем случае мы можем сделать так:
<div class="highlight"><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">string_to_append</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; Appended Text |&quot;</span><span class="p">;</span>
<span class="n">malloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_append</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// strlen не учитывает символ \0</span>
</code></pre></div>
И добавить текст переменной <code>string_to_append</code> в новую освобожденную память мы можем методом <code>strcat</code>.
<div class="highlight"><pre><span></span><code><span class="n">strcat</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">string_to_append</span><span class="p">);</span>
</code></pre></div>
После всех операций память, выделенную под указатель, необходимо освободить. "Пометить для системы, что память можно перезаписывать".</p>
<p>Делается это командой <code>void free(void *ptr)</code>, которая должна вызываться для каждого указателя, память которого была выделена через <code>malloc</code>.
<div class="highlight"><pre><span></span><code><span class="n">free</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">);</span>
</code></pre></div>
Полный код тестовой программы вышел такой:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="c1">// не забываем про \0 - итоговая длинна строки всегда на 1 символ больше</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">string_to_load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;| Test |&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Выделяем память под strlen(string_to_load) + 1 букв размерности char</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_load</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Выделяем память под strlen(string_to_load) + 1 букв char, предварительно очищая память</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_load</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
<span class="w">    </span><span class="c1">// смотрим что внутри памяти находится сейчас</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Malloc Content: &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Calloc Content: &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Помещаем слово string_to_load внутрь каждого фрагмента памяти</span>
<span class="w">    </span><span class="n">strcpy</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">string_to_load</span><span class="p">);</span>
<span class="w">    </span><span class="n">strcpy</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">string_to_load</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Malloc Text :&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// я знаю про std::endl, но где-то читал, что &quot;\n&quot; быстрее, не помню где</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Calloc Text :&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">string_to_append</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot; Appended Text |&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_append</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">string_to_append</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
<span class="w">    </span><span class="n">strcat</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">string_to_append</span><span class="p">);</span>
<span class="w">    </span><span class="n">strcat</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">,</span><span class="w"> </span><span class="n">string_to_append</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Reallocated Malloc Text: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">malloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Reallocated Calloc Text: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">calloc_test</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; size &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">malloc_test</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">calloc_test</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/f7c7e028588b39d72942b878facc35a6.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f7c7e028588b39d72942b878facc35a6.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f7c7e028588b39d72942b878facc35a6.png" /></a></p>
<p>Обратите внимание, когда я выделяю новые блоки памяти в <code>malloc</code> и <code>realloc</code> я не использую <code>sizeof()</code>. Почему?
Дело в том, что <code>sizeof</code> не работает с кучей (heap), в которой мы выделяем память. Не умеет работать. И единственный способ узнать, каков реальный размер объекта в куче - это использовать для строк <code>strlen</code>, ну а для других данных - иные методы подсчета, например перебором в цикле.</p>
<p>Единственное для чего <code>sizeof</code> реально годится - для измерения массивов, размер которых изначально известен (и не будет меняться), а так-же для измерения размерности типов.</p>
<p>Условно говоря <code>sizeof</code> не будет работать тут:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">222</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the size of ints is &quot;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="n">ints</span><span class="p">;</span>
</code></pre></div>
Но будет работать тут:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">ints2</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;the ints2 size is &quot;</span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ints2</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div>
Можете сами проверить, в первом случае, вам напишет не <code>222*sizeof(int)</code>, а просто <code>sizeof(int)</code>, то есть, в моем случае это <code>4</code>. Четыре. Не <code>222</code>.
Ну а во втором - <code>10</code>.</p>
<p><a class="glightbox" href="../images/cb00cd632bf41a3230303c91e3843f50.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="cb00cd632bf41a3230303c91e3843f50.png" auto_="auto;" display="block;" margin:="margin:" src="../images/cb00cd632bf41a3230303c91e3843f50.png" /></a></p>
<p>При работе с кучей, разработчик должен сам сохранять размерность массива. Лучше всего это делать внутри <code>private</code> переменной класса.</p>
<p>Встроенные в стандартную библиотеку контейнера типа <code>std::vector</code>, <code>std::string</code> и прочие - сами считают свой размер всякий раз как получают новые данные или теряют их.
<code>c++</code> привносит в синтаксис си элементы ооп. Все "новые" возможности управления памятью в <code>с++</code> сводятся к ключевым словам <code>new</code> и <code>delete</code>. Ключевое слово <code>new</code> упрощает выделение памяти под объекты, потому что не всегда можно просчитать размерностью объекта для оператора <code>malloc</code>, как я уже показал на примере <code>sizeof</code>.
Ключевое слово <code>delete</code> удаляет объект из памяти.</p>
<p>Пример использования:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vector_test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">222</span><span class="p">);</span>
<span class="n">vector_test</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span><span class="w"> </span><span class="c1">// put number 15 at position of 5</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Vector Size: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">vector_test</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Vector value 5 before deletion: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">vector_test</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">delete</span><span class="w"> </span><span class="n">vector_test</span><span class="p">;</span><span class="w"> </span><span class="c1">// deleting vector</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Vector value 5 after deletion: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">vector_test</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div>
В конце этот код выдаст ошибку, ибо я пытаюсь обратиться к уже удаленной памяти. Намеренно. Чтобы продемонстрировать.</p>
<p><a class="glightbox" href="../images/143775e640e2fdabe198a5b05ed01eda.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="143775e640e2fdabe198a5b05ed01eda.png" auto_="auto;" display="block;" margin:="margin:" src="../images/143775e640e2fdabe198a5b05ed01eda.png" /></a></p>
<p>Так-же в<code>c++</code>введено понятие конструктора и деструктора класса. В современном<code>c++</code>есть более расширенные понятия конструктора класса, это <code>copy constructor, move constructor, copy assignment, move assignment, default constructor</code>, это т.н. принцип <code>4+1</code>. Видимо придется на этом тоже остановиться… в другой главе.</p>
<h4 id="_5">Утечки памяти</h4>
<p>Помните, что если ваше приложение закроется до освобождения памяти объекта, то выделенная память останется заблокированной, до перезагрузки компьютера.</p>
<p>Оператры <code>free()</code> и <code>delete</code> помечают память как доступную для перезаписи другими прилжениями и процессами. Их вызов - обязателен.</p>
<p>Утечки памяти - одна из главных претензций большинства разработчиков и к <code>с</code> и к <code>с++</code>.
Рассмотрим следующий код:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">test_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="c1">// заполняем массив</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">test_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// тут sizeof(test_array)/sizeof(int) сработает, потому что в компайл тайме уже известен размер массива - 10 элементов</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">array_item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">test_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">array_item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Array Size: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/bc468e1963ad7ea812daaa703699f1a9.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="bc468e1963ad7ea812daaa703699f1a9.png" auto_="auto;" display="block;" margin:="margin:" src="../images/bc468e1963ad7ea812daaa703699f1a9.png" /></a></p>
<p>Это доведенный до абсурда пример из вступления. Обратите внимание на этот участок <code>const int * array_item = &amp;test_array[i];</code>.
Как вы считаете, есть ли в теле цикла утечка памяти?
Если вы внимательно читали мои предыдущие объяснения, то поймете, что тут ее нет. И пусть слово <code>const</code> вас не сбивает с толку, потому что это <code>compile time operator</code>.
В теле цикла нигде не использутеся <code>new</code>, не используется <code>malloc</code> или <code>calloc</code>.
Что делает эта строчка: <code>const int * array_item = &amp;test_array[i];</code>?
Тут берется адрес в ПАМЯТИ элемента массива по индексу <code>i</code>. То есть не сам элемент, а его адрес в памяти. Понимаете? Он ведь находится в памяти, вот я его адрес и беру.</p>
<p>А в какого типа переменных хранятся адреса памяти? В указателях.</p>
<p>Вот я и сую этот адрес в указатель. Заметьте, в указатель идет лишь адрес, а не память как таковая. Таким образом утечки памяти тут нет.</p>
<p>И я, таки, делаю ваше внимание на тот факт, что в обоих циклах у меня используется индекс <code>i</code>. И в верхнем и в нижнем. Как же такое возможно? Разве это не вызывает конфликт имен, спросит юный и неопытный коллега? Как видите - не вызывает. У этих переменных разная область видимости <code>{}</code>. Я часто использую этот трюк в коде.</p>
<p>Данные, которые выделяются в теле цикла, будь это переменные или указатели, сбрасываются по выходу из своей области видимости <code>{}</code>. Да, указатели тоже сбрасываются. Но <strong>память</strong>, на которую они указывают, <em>не сбрасывается</em>, пока вы ее вручную не очистите через <code>free</code> или <code>delete</code>.
Как тут все запороть и, таки, создать утечку памяти на мою голову?</p>
<p><a class="glightbox" href="../images/fe138181424f43d661f9e4a5cfef513d.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fe138181424f43d661f9e4a5cfef513d.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fe138181424f43d661f9e4a5cfef513d.png" /></a></p>
<p><div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">array_item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">test_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">useless_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">array_item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Вот так. Значение переменной <code>useless_pointer</code> сбросится, по выходу из цикла она не будет существовать. А вот память, выделенная в <code>malloc</code> существовать будет. Просто на нее ничто не будет указывать и потому очистить ее никак не получится.</p>
<p>Это и есть самый страшный пример "утечки памяти".</p>
<p>Утечку памяти можно сделать и так (через <code>new</code>):
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">array_item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">test_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">useless_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">array_item</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Теперь, когда мы разобрались с обычными указателями, самое время переходить к Unreal Engine.</p>
<h2 id="_6">Подготовка к работе</h2>
<p>Поскольку класс из предыдущей статьи у нас разросся до невозможности, в этот раз мы будем работать с новым классом. Пусть это будет класс компонента, который мы просто добавим к <code>BP_ThirdPersonCharacter</code>.
Про компоненты отдельно мы поговорим в следующей статье. А в этой просто используем класс компонента для своих тестов.</p>
<h3 id="_7">Добавляем компонент</h3>
<p>Чтобы добавить компонент идем, как обычно, <code>Tools -&gt; New C++ Class</code>.
Выбираем <code>ActorComponent</code>.</p>
<p><a class="glightbox" href="../images/9ca1aaec541e2c486cc90ee876f762cc.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9ca1aaec541e2c486cc90ee876f762cc.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9ca1aaec541e2c486cc90ee876f762cc.png" /></a></p>
<p>Называем <code>PointersComponent</code>. Компонент должен добавляться в модуль - <code>TestModule</code>.</p>
<p><a class="glightbox" href="../images/3fb62abaf4703f9f8e011dc0dd23696f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3fb62abaf4703f9f8e011dc0dd23696f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3fb62abaf4703f9f8e011dc0dd23696f.png" /></a></p>
<h3 id="_8">Зависимости сборки</h3>
<p>В файле <code>TestModule.build.cs</code> прописываем следующие зависимости:
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">UnrealBuildTool</span><span class="p">;</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TestModule</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ModuleRules</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">TestModule</span><span class="p">(</span><span class="n">ReadOnlyTargetRules</span><span class="w"> </span><span class="n">Target</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">base</span><span class="p">(</span><span class="n">Target</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">PCHUsage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PCHUsageMode</span><span class="p">.</span><span class="n">UseExplicitOrSharedPCHs</span><span class="p">;</span>
<span class="w">        </span><span class="n">PublicDependencyModuleNames</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s">&quot;Core&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;CoreUObject&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;Engine&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;Slate&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;SlateCore&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;LocalizationCommandletExecution&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="s">&quot;GameplayTags&quot;</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">        </span><span class="n">PrivateDependencyModuleNames</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="s">&quot;InputCore&quot;</span>
<span class="w">            </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;EnhancedInput&quot;</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">        </span><span class="n">PublicIncludePaths</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span><span class="s">&quot;TestModule/Public&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;TestModule/Public/Enums&quot;</span><span class="w"> </span><span class="p">});</span>
<span class="w">        </span><span class="n">PrivateIncludePaths</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">string</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Path</span><span class="p">.</span><span class="n">Combine</span><span class="p">(</span><span class="n">ModuleDirectory</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Private&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="_9">Добавляем компонент к персонажу</h3>
<p>Открываем <code>BP_ThirdPersonCharacter</code>, добавляем туда наш компонент.</p>
<p><a class="glightbox" href="../images/6a5fee0d95a8466a4e59f36a4228c9ab.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6a5fee0d95a8466a4e59f36a4228c9ab.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6a5fee0d95a8466a4e59f36a4228c9ab.png" /></a></p>
<h2 id="unreal-engine">Обычные указатели в <code>Unreal Engine</code></h2>
<p>Давайте начнем разбор указателей в движке с обычных.</p>
<p>Как вы знаете в <code>Unreal Engine</code> имеется встроенная система сборки мусора, автоматически следящая за памятью и ее использованием. Это достаточно удобный инструмент, однако обычные указатели не всегда обрабатываются этой системой. Поэтому работать с ними надо крайне осторожно.</p>
<p>В каких случаях использование обычных указателей безопасно?
Тут есть два варианта:</p>
<ol>
<li>Если обычный указатель ссылается на <code>UObject</code>, то его автоматически будет обрабатывать сборщик мусора. Таким образом вы можете спокойно использовать обчные указатели с объектами типа: <code>UObject, AActor, APawn, ACharacter, AActorComponent, ASceneComponent</code>, а так-же с любыми объектами, унаследованными от этих классов.</li>
<li>Если обычный указатель используется как <code>UPROPERTY</code> параметр. Система <code>Unreal Header Tool</code> умеет преобразовывать обычные указатели в управляемые автоматически, в момент компиляции, если они используются как параметры.</li>
</ol>
<p><div class="highlight"><pre><span></span><code><span class="c1">// Actor RAW refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">AActor</span><span class="o">*</span><span class="w"> </span><span class="n">SomeActorRefrence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</code></pre></div>
Если скомпилировать указанный выше код, добавив его в класс <code>PointersComponent</code>, мы получим поле, в котором можно указать объект текущего, открытого, уровня.</p>
<p><a class="glightbox" href="../images/57b5d6c89cdc617e464b7a2f1181a56e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="57b5d6c89cdc617e464b7a2f1181a56e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/57b5d6c89cdc617e464b7a2f1181a56e.png" /></a></p>
<h2 id="unreal-engine_1">Умные указатели в <code>Unreal Engine</code></h2>
<p>"Умные" указатели отличаются от обычных тем, что предоставляют разработчику дополнительные возможности по управлению объектами, на которые ссылаются.</p>
<p>Память, на которую ссылаются "умные" указатели - автоматически очищается при сбоях системы или закрытии приложения. Это гарантирует безопасность при работе с такими указателями.</p>
<p>Есть умные указатели, интегрированные и не интегрированные в сборщик мусора. Работают они по разному.</p>
<h3 id="_10">Управляемые умные указатели</h3>
<p>Управляемые классы умных указателей работают совместно с системой сборки мусора <code>Unreal</code> и поэтому могут свободно работать с объектами, унаследованными от <code>UObject, AActor, APawn, ACharacter, AActorComponent, ASceneComponent</code>.</p>
<h4 id="tobjectptr-raw-object-pointer"><code>TObjectPtr</code> - замена <code>raw object pointer</code></h4>
<p><a href="https://docs.unrealengine.com/5.0/en-US/API/Runtime/CoreUObject/UObject/TObjectPtr/">Документация.</a></p>
<p><code>TObjectPtr</code> - это относительно новый класс умных указателей (появился в <code>Unreal Engine 5</code>), выступающий как альтернатива использованию чистых указателей для <code>UPROPERTY</code>.</p>
<p>Разработчики советуют использовать в <code>Unreal 5</code> именно <code>TObjectPtr</code> и воздержаться от использования чистых указателей.
<code>TObjectPtr</code> работает как блокирующий указатель, который не позволяет системе сборки мусора удалять объект, на который ссылается указатель, до тех пор, пока сам указатель используется хоть в одном активном классе.
<code>TObjectPtr</code> используют для хранения ссылок на объекты или для создания новых объектов.</p>
<p>Ниже будет ряд примеров использования данного указателя совместно с <code>UPROPERTY</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Texture2D asset refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">UTexture2D</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SomeTexture2D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="c1">//Texture asset refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">UTexture</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SomeTexture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="c1">// Static Mesh Refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">UStaticMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StaticMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="c1">// Skeletal Mesh Refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">USkeletalMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SkeletalMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="c1">// Physics Asset Refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">UPhysicsAsset</span><span class="o">&gt;</span><span class="w"> </span><span class="n">PhysicsAsset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</code></pre></div></p>
<h4 id="tweakobjectptr"><code>TWeakObjectPtr</code></h4>
<p>Это "не блокирующий" указатель. Память, на которую он ссылается, может быть удалена или очищена вне зависимости от того, активен указатель или нет.</p>
<p>Eго предназначение - работа с объектами, которые уже сконструированы и присутствуют на уровне.</p>
<p>Например, мы можем взять ссылку на любой объект с уровня и  поместить ее в <code>TWeakObjectPtr</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Actor Weak Refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ActorWeakRefrence</span><span class="p">;</span>
</code></pre></div>
Загрузим объект <code>PlayerStart</code> по его пути на уровне.
<div class="highlight"><pre><span></span><code><span class="c1">// setting Weak Refrence to Actor on Level</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ActorWeakRefrence</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StringObjectOnLevelPathW</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;/Game/ThirdPerson/Maps/ThirdPersonMap.ThirdPersonMap:PersistentLevel.PlayerStart_0&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// search for StringObjectOnLevelPath using FObjectFinder</span>
<span class="w">    </span><span class="n">ConstructorHelpers</span><span class="o">::</span><span class="n">FObjectFinder</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FoundActor</span><span class="p">(</span><span class="o">*</span><span class="n">StringObjectOnLevelPathW</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FoundActor</span><span class="p">.</span><span class="n">Succeeded</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">ActorWeakRefrence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeWeakObjectPtr</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">FoundActor</span><span class="p">.</span><span class="n">Object</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="tsoftobjectptr"><code>TSoftObjectPtr</code></h4>
<p>Это "не блокирующий" указатель. Работает как <code>TWeakObjectPtr</code>, но в отличие от него может ссылаться на еще не загруженные в игру объекты или на объекты, находящиеся на других уровнях.</p>
<p>Этот указатель хранит путь до ассета на который ссылается и поэтому он предоставляет дополнительный функционал по инициализации объектов. Ниже мы это рассмотрим.
<div class="highlight"><pre><span></span><code><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TSoftObjectPtr</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SomeSoftActorRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</code></pre></div>
Сослаться на ассет на любом уровне можно следующим образом. Сначала выставляем этот ассет в полученном <code>UPROPERTY</code>. Щелкаем на поле ПКМ и нажимаем <code>Copy</code>.</p>
<p><a class="glightbox" href="../images/bfd5f114062621c8bdf59cd791b3e606.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="bfd5f114062621c8bdf59cd791b3e606.png" auto_="auto;" display="block;" margin:="margin:" src="../images/bfd5f114062621c8bdf59cd791b3e606.png" /></a></p>
<p>Полученную ссылку можно загрузить в <code>TSoftObjectPtr</code> используя такой код:
<div class="highlight"><pre><span></span><code><span class="c1">// soft actor ref</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SomeSoftActorRef</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StringObjectOnLevelPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;/Game/ThirdPerson/Maps/ThirdPersonMap.ThirdPersonMap:PersistentLevel.PlayerStart_0&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SomeSoftActorRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">MakeSoftObjectPath</span><span class="p">(</span><span class="n">StringObjectOnLevelPath</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
При этом <code>SoftObjectPath</code> автоматически преобразуется в <code>TSoftObjectPtr</code>.
Ну и конечно этот код надо вызывать в конструкторе класса, если вы желаете установить данное значение как "по умолчанию" для переменной.</p>
<p><a class="glightbox" href="../images/bf370727571a8ebd37957b5e14c2ebd3.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="bf370727571a8ebd37957b5e14c2ebd3.png" auto_="auto;" display="block;" margin:="margin:" src="../images/bf370727571a8ebd37957b5e14c2ebd3.png" /></a></p>
<p>Получение прямой ссылки на сам ассет, с его автоматической загрузкой, осуществляется методом <code>.Get()</code></p>
<p><a class="glightbox" href="../images/badfd1632abdb30de028de67b62fa3f4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="badfd1632abdb30de028de67b62fa3f4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/badfd1632abdb30de028de67b62fa3f4.png" /></a></p>
<p>Используя <code>UKismetSystemLibrary</code> можно получить доступ к следующим методам для <code>TSoftObjectPtr</code>:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Kismet/KismetSystemLibrary.h&quot;</span>
<span class="c1">//...</span>
<span class="c1">// Конвертирует указатель в нормальный объект</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">Conv_SoftObjectReferenceToObject</span><span class="p">(</span><span class="n">TSoftObjectPtr</span><span class="p">)</span>
<span class="c1">// Primary Asset Id</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">GetPrimaryAssetIdFromSoftObjectReference</span><span class="p">(</span><span class="n">SomeSoftActorRef</span><span class="p">);</span>
<span class="c1">// Get object refrence from SoftRefrence</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">Conv_SoftObjectReferenceToObject</span><span class="p">(</span><span class="n">SomeSoftActorRef</span><span class="p">);</span>
<span class="c1">// Cheks if object exists at given pointer</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">IsValidSoftObjectReference</span><span class="p">(</span><span class="n">SomeSoftActorRef</span><span class="p">);</span>
</code></pre></div>
Так-же из <code>TSoftObjectPtr</code> доступны дополнительные методы работы с привязанной ссылкой на ассет.</p>
<p><a class="glightbox" href="../images/21317f7ebbc322c74158f2b3e1c72105.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="21317f7ebbc322c74158f2b3e1c72105.png" auto_="auto;" display="block;" margin:="margin:" src="../images/21317f7ebbc322c74158f2b3e1c72105.png" /></a></p>
<p><a class="glightbox" href="../images/df3ed3358650ac221777a62cad5b5959.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="df3ed3358650ac221777a62cad5b5959.png" auto_="auto;" display="block;" margin:="margin:" src="../images/df3ed3358650ac221777a62cad5b5959.png" /></a></p>
<h4 id="tassetptr"><code>TAssetPtr</code></h4>
<p>Это старый умный указатель, для управления ссылками на ассеты. В данный момент он все еще поддерживается ради совместимости движка со старым кодом. Документация гласит следующее:</p>
<p><a class="glightbox" href="../images/304dd4ca975ed77b5be81f35187e4226.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="304dd4ca975ed77b5be81f35187e4226.png" auto_="auto;" display="block;" margin:="margin:" src="../images/304dd4ca975ed77b5be81f35187e4226.png" /></a></p>
<p>В данный момент <code>TAssetPtr</code> представляет из себя просто <code>typedef</code> от <code>TSoftObjectPtr</code>, то есть это просто псевдоним. И использовать его не рекомендуется, потому что в будущем данный тип указателя может получить статус <code>Deprecated</code>, не поддерживаемого. Используйте <code>TSoftObjectPtr</code>.</p>
<h4 id="tsoftclassptr">TSoftClassPtr</h4>
<p>Работает как <code>TSubclassOf</code>, но может указывать на не-загруженные классы. Классы загружаются посредством подсистемы <code>UAssetManager</code>.
Так-же позволяет осуществлять асинхронную загрузку классов. Однако не может ссылаться на классы типа <code>DataAsset</code>. Для них надо использовать <code>TSubclassOf</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// AnimInstance Class Refrence</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TSubclassOf</span><span class="o">&lt;</span><span class="n">UAnimInstance</span><span class="o">&gt;</span><span class="w"> </span><span class="n">AnimClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UAnimInstance</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">();</span>
<span class="c1">// Soft Class</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;DifferentPointers&quot;</span><span class="p">)</span>
<span class="n">TSoftClassPtr</span><span class="o">&lt;</span><span class="n">UActorComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SomeSoftComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UCameraComponent</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">();</span>
</code></pre></div>
Сослаться на ассет на любом уровне можно следующим образом. Сначала выставляем этот ассет в полученном <code>UPROPERTY</code>. Щелкаем на поле ПКМ и нажимаем <code>Copy</code>.</p>
<p><a class="glightbox" href="../images/580f57b9129b7fb19b6a98cdbc99172f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="580f57b9129b7fb19b6a98cdbc99172f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/580f57b9129b7fb19b6a98cdbc99172f.png" /></a></p>
<p>Полученную ссылку можно загрузить в <code>TSoftClassPtr</code> используя такой код:
<div class="highlight"><pre><span></span><code><span class="c1">// soft component class</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SomeSoftComponentClass</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StringClassPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;/Script/Engine.CameraComponent&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">SomeSoftComponentClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">MakeSoftClassPath</span><span class="p">(</span><span class="n">StringClassPath</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
Если надо получить из <code>TSoftClassPtr</code> сам класс, то используйте метод <code>Get()</code>.</p>
<p><a class="glightbox" href="../images/686fb313382283c0b9df6fa55fc514c7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="686fb313382283c0b9df6fa55fc514c7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/686fb313382283c0b9df6fa55fc514c7.png" /></a></p>
<p>Используя <code>UKismetSystemLibrary</code> можно получить доступ к следующим методам для <code>TSoftClassPtr</code>:
<div class="highlight"><pre><span></span><code><span class="c1">// Конвертирует указатель в нормальный объект</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">Conv_SoftObjectReferenceToObject</span><span class="p">(</span><span class="n">TSoftObjectPtr</span><span class="p">)</span>
<span class="c1">// Primary Asset Id</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">GetPrimaryAssetIdFromSoftClassReference</span><span class="p">(</span><span class="n">SomeSoftComponentClass</span><span class="p">);</span>
<span class="c1">// Check if asset exists on given path</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">IsValidSoftClassReference</span><span class="p">(</span><span class="n">SomeSoftComponentClass</span><span class="p">);</span>
<span class="c1">// Loads class non async</span>
<span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">LoadClassAsset_Blocking</span><span class="p">(</span><span class="n">SomeSoftComponentClass</span><span class="p">);</span>
</code></pre></div></p>
<h5 id="data-asset">Для DATA ASSET'ов</h5>
<p>Чтобы ссылаться на <code>Data Asset</code> нужно использовать не <code>TSoftClassPtr</code>, а <code>TSoftObjectPtr</code>, что немного не логично, но, как есть.
<div class="highlight"><pre><span></span><code><span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditDefaultsOnly</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Input&quot;</span><span class="p">)</span>
<span class="n">TSoftObjectPtr</span><span class="o">&lt;</span><span class="n">UInputAction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">InputAction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="c1">// Input Context as parameter in Data Asset</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">EditDefaultsOnly</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Input&quot;</span><span class="p">)</span>
<span class="n">TSoftObjectPtr</span><span class="o">&lt;</span><span class="n">UInputMappingContext</span><span class="o">&gt;</span><span class="w"> </span><span class="n">InputContext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/dd2103b22da26a8514c0cab3cd05c195.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="dd2103b22da26a8514c0cab3cd05c195.png" auto_="auto;" display="block;" margin:="margin:" src="../images/dd2103b22da26a8514c0cab3cd05c195.png" /></a></p>
<h5 id="blueprint">Работа с <code>Blueprint</code> классами</h5>
<p>Если мы хотим сослаться не на<code>c++</code>класс или ассет, а на <code>blueprint</code> класс, то к тексту рефренса этого ассета надо добавить постфикс <code>_C</code>.
Например такой рефренс у <code>Animation Blueprint</code>: <code>/Script/Engine.AnimBlueprint'/Game/Characters/Mannequins/Animations/ABP_Manny.ABP_Manny'</code></p>
<p><a class="glightbox" href="../images/c63c0643cb02c33ea8ef2cdd7afdedf1.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c63c0643cb02c33ea8ef2cdd7afdedf1.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c63c0643cb02c33ea8ef2cdd7afdedf1.png" /></a></p>
<p>Чтобы присвоить это значение для переменной типа <code>TSoftClassPtr</code> нужен такой код:
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="w"> </span><span class="n">AnimationInstanceAsset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;/Script/Engine.AnimBlueprint&#39;/Game/Characters/Mannequins/Animations/ABP_Manny.ABP_Manny_C&#39;&quot;</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">TSoftClassPtr</span><span class="o">&lt;</span><span class="n">UAnimInstance</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CAnimInst</span><span class="p">(</span><span class="n">AnimationInstanceAsset</span><span class="p">);</span>
<span class="n">MeshComp</span><span class="o">-&gt;</span><span class="n">SetAnimationMode</span><span class="p">(</span><span class="n">EAnimationMode</span><span class="o">::</span><span class="n">AnimationBlueprint</span><span class="p">);</span>
<span class="n">MeshComp</span><span class="o">-&gt;</span><span class="n">SetAnimInstanceClass</span><span class="p">(</span><span class="n">CAnimInst</span><span class="p">.</span><span class="n">LoadSynchronous</span><span class="p">());</span>
</code></pre></div>
Если, в данном случае, постфикс <code>_C</code> не использовать, то вместо <code>blueprint</code> класса, указатель будет ссылаться на <code>AUnimInstance</code>, то есть на первый<code>c++</code>класс доступный как предок данного <code>blueprint</code>.</p>
<h3 id="_11">Неуправляемые умные указатели</h3>
<p>Данные указатели не управляются встроенным сборщиком мусора и не могут работать с классами, унаследованными от <code>UObject</code>. Их предназначение - работать с не управляемыми типами объектов и структур. Это могут быть ваши собственные объекты или объекты из подключенных сторонних библиотек.</p>
<p>Для наших экспериментов создадим простенькую структуру:
<div class="highlight"><pre><span></span><code><span class="c1">// struct to test unmanaged smart pointers</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">FPtrTestStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FPtrTestStruct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Field1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">Field2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Field1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Field2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
Обратите внимание, что мы не использовали в этой структуре макрос <code>USTRUCT</code>, таким образом исключив ее из обработки сборщиком мусора. Представим, что эта структура идет из некой сторонней библиотеки. На ней и будем проводить эксперименты.</p>
<h4 id="tsharedptr"><code>TSharedPtr</code></h4>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/SmartPointerLibrary/SharedPointer/">Документация.</a></p>
<p>Аналог встроенного в стандартную библиотеку<code>c++</code>умного указателя <code>std::shared_ptr</code>. В Unreal можно работать как с <code>TSharedPtr</code> так и с <code>std::shared_ptr</code>.
Это "блокирующий"  и анализирующий свое использование указатель. Память, на которую он ссылается, не может быть очищена сборщиком мусора до тех пор, пока хоть один объект ссылается на этот указатель.</p>
<p>Когда количество объектов, использующих <code>TSharedPtr</code>, становится равным <code>0</code>, этот указатель автоматически уничтожается.</p>
<p>Объект можно инициализировать как <code>TSharedPtr</code> используя вспомогательныe методы <code>MakeShared</code> и <code>MakeShareable</code>.
<div class="highlight"><pre><span></span><code><span class="n">TSharedPtr</span><span class="o">&lt;</span><span class="n">TestClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ObjPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeShareable</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">TestClass</span><span class="p">(</span><span class="n">Args</span><span class="p">));</span><span class="w"> </span><span class="c1">// этот позволяет превратить в указатель любой объект</span>
<span class="n">TSharedPtr</span><span class="o">&lt;</span><span class="n">TestClass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ObjPtr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeShared</span><span class="o">&lt;</span><span class="n">TestClass</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Args</span><span class="p">);</span><span class="w"> </span><span class="c1">// этот позволяет создать экземпляр объекта с аргументами по его классу</span>
<span class="c1">// например</span>
<span class="n">TSharedPtr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">ESPMode</span><span class="o">::</span><span class="n">ThreadSafe</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ThreadsafeIV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeShared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
Когда надо использовать?
Когда нужен указатель на объект, использующийся многими другими объектами. То есть Shared, общий.</p>
<h4 id="tsharedref"><code>TSharedRef</code></h4>
<p>То-же самое, что и <code>TSharedPtr</code>, с одним отличием - этот указатель не может ссылаться на <code>nullptr</code>. Если он ссылается, то выскочит ошибка в работе приложения. Рекомендуется использовать этот тип указателя для аргументов функции.</p>
<h4 id="tweakptr"><code>TWeakPtr</code></h4>
<p><a href="https://docs.unrealengine.com/5.1/en-US/weak-pointers-in-unreal-engine/">Документация.</a></p>
<p>Аналог встроенного в стандартную библиотеку<code>c++</code>умного указателя <code>std::weak_ptr</code>. В Unreal можно работать как с <code>TWeakPtr</code> так и с <code>std::weak_ptr</code>.
Это "не блокирующий" указатель. Память, на которую он ссылается, может быть удалена или очищена вне зависимости от того, активен указатель или нет. Поэтому важно добавлять проверки на то, является ли содержимое указателя <code>nullptr</code>.
Чтобы использовать <code>WeakPtr</code> с <code>UObject</code> типами есть второй указатель - <code>TWeakObjectPtr</code>. Который может работать с <code>UObject</code>. Я его уже рассматривал.</p>
<p>Когда надо использовать?
<code>TWeakPtr</code> используется тогда, когда надо сослаться на уже существующий объект.</p>
<p>Делается это так:
<div class="highlight"><pre><span></span><code><span class="c1">// Allocate a new data object and create a strong reference to it.</span>
<span class="n">TSharedRef</span><span class="o">&lt;</span><span class="n">FMyObjectType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ObjectOwner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeShared</span><span class="o">&lt;</span><span class="n">FMyObjectType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// Create a weak pointer to the new data object.</span>
<span class="n">TWeakPtr</span><span class="o">&lt;</span><span class="n">FMyObjectType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ObjectObserver</span><span class="p">(</span><span class="n">ObjectOwner</span><span class="p">);</span>
</code></pre></div>
У вас не получится сконструировать объект с этим указателем, потому что такой объект сразу вычистит система сборки мусора, а указатель в итоге будет ссылаться на <code>nullptr</code>.
При необходимости <code>TWeakPtr</code> можно преобразовать в <code>TSharedPtr</code>, благодаря методу <code>Pin()</code>.
<div class="highlight"><pre><span></span><code><span class="n">TWeakPtr</span><span class="o">&lt;</span><span class="n">UPointersComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">;</span>
<span class="n">TSharedPtr</span><span class="o">&lt;</span><span class="n">UPointersComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">component</span><span class="p">.</span><span class="n">Pin</span><span class="p">();</span>
</code></pre></div></p>
<h4 id="tuniqueptr">TUniquePtr</h4>
<p><a href="https://docs.unrealengine.com/4.27/en-US/API/Runtime/Core/Templates/TUniquePtr/">Документация.</a> </p>
<p>Надо сказать, что информации по этому указателю в интернете почти нет (как нет ее и по остальным указателям, люди их буквально не используют). В гугле всего 4 страницы выдает. Благо, как и  все остальные указатели для неуправляемого кода, данный является лишь аналогом к <code>std::unique_ptr</code>. А значит документация из стандартной библиотеки верна и для Unreal.
Это "блокирующий" указатель, работающий вне стандартного сборщика мусора и конфликтующий с ним. Память, на которую ссылается <code>TUniquePtr</code> автоматически очищается, когда программа выходит за область действия этого указателя. Например когда заканчивается функция, в которой этот указатель был создан. Сборщик мусора не управляет этим указателем. Этот указатель нельзя передать в другие функции в качестве аргумента.</p>
<p>Поскольку этот указатель работает вне стандартной системы сборки мусора - он не может управлять объектами, которые уже привязаны к сборщику мусора. То есть этот указатель нельзя создать для классов, унаследованных от <code>UObject</code>. Или для классов созданных при участии макросов <code>UCLASS</code> / <code>USTRUCT</code>.
Вы не сможете засунуть в этот указатель класс <code>AActor</code>. Зато в него можно засунуть указатели на классы и структуры от сторонних библиотек.</p>
<blockquote>
<p>Этот тип указателя работает только с классами и структурами <strong>не управляющимися встроенным сборщиком мусора</strong>.</p>
</blockquote>
<p>Создание указателя для примитивной "чистой" структуры выглядит так:
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">FUniquePtrTestStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FUniquePtrTestStruct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Field1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">Field2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Field1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Field2</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// ----</span>
<span class="c1">// загрузка структуры в указатель</span>
<span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Unique</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">Unique</span><span class="o">-&gt;</span><span class="n">Field1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="n">Unique</span><span class="o">-&gt;</span><span class="n">Field2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">7.4f</span><span class="p">;</span>
<span class="n">FString</span><span class="w"> </span><span class="n">ToPrint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FString</span><span class="o">::</span><span class="n">Printf</span><span class="p">(</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Field1 = %i</span><span class="se">\n</span><span class="s">Field2 = %f&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Unique</span><span class="o">-&gt;</span><span class="n">Field1</span><span class="p">,</span><span class="w"> </span><span class="n">Unique</span><span class="o">-&gt;</span><span class="n">Field2</span><span class="p">);</span>
<span class="n">GEngine</span><span class="o">-&gt;</span><span class="n">AddOnScreenDebugMessage</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="n">FColor</span><span class="o">::</span><span class="n">Cyan</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ToPrint</span><span class="p">);</span>
</code></pre></div>
Обратите внимание на тот факт, что структура создана без макроса <code>USTRUCT</code>. Если изменить ее под этот макрос, например так:
<div class="highlight"><pre><span></span><code><span class="n">USTRUCT</span><span class="p">(</span><span class="n">BlueprintType</span><span class="p">)</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">FUniquePtrTestStruct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">GENERATED_USTRUCT_BODY</span><span class="p">()</span>
<span class="w">    </span><span class="n">FUniquePtrTestStruct</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Field1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">Field2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Field1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">Field2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
Ваш код вызовет сбой движка в момент компиляции, потому что переменная структуры не может одновременно управляться указателем <code>TUniquePtr</code> и системой сборки мусора.</p>
<p>Помните об этом.
<code>TUniquePtr</code> не копируется. Что это значит? Это значит что вот такой код не сработает, выдав ошибку <code>cannot be refrenced -- it is a deleted function</code>.
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">TestPointerArg</span><span class="p">(</span><span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{};</span>
<span class="c1">// ----</span>
<span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Unique</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">TestPointerArg</span><span class="p">(</span><span class="n">Unique</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/bef79b7b3c7a77f819720757f6e8f0fd.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="bef79b7b3c7a77f819720757f6e8f0fd.png" auto_="auto;" display="block;" margin:="margin:" src="../images/bef79b7b3c7a77f819720757f6e8f0fd.png" /></a></p>
<p>Дело в том, что при передаче аргументов внутрь функции - они копируются. В примере я передаю в функцию <code>TestPointerArg</code> наш указатель как один из аргументов. Из-за того, что <code>TUniquePtr</code> нельзя копировать - код выдает ошибку.</p>
<p>Однако данное ограничение можно обойти за счет перемещения памяти используя <code>MoveTemp</code>,  <code>std::move</code> или за счет встроенного в указатель метода <code>Release</code>. Вместо копирования памяти указателя - мы просто ее перемещаем.</p>
<p>Делается это так:
<div class="highlight"><pre><span></span><code><span class="c1">// make first pointer</span>
<span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Unique</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MakeUnique</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">// release it to second pointer</span>
<span class="n">TUniquePtr</span><span class="o">&lt;</span><span class="n">FUniquePtrTestStruct</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Unique1</span><span class="p">(</span><span class="n">Unique</span><span class="p">.</span><span class="n">Release</span><span class="p">());</span>
<span class="n">Unique1</span><span class="o">-&gt;</span><span class="n">Field1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="n">Unique1</span><span class="o">-&gt;</span><span class="n">Field2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">7.4f</span><span class="p">;</span>
<span class="n">FString</span><span class="w"> </span><span class="n">ToPrint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FString</span><span class="o">::</span><span class="n">Printf</span><span class="p">(</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Field1 = %i</span><span class="se">\n</span><span class="s">Field2 = %f</span><span class="se">\n</span><span class="s">Is first pointer valid? = %s&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Unique1</span><span class="o">-&gt;</span><span class="n">Field1</span><span class="p">,</span><span class="w"> </span><span class="n">Unique1</span><span class="o">-&gt;</span><span class="n">Field2</span><span class="p">,</span><span class="w"> </span><span class="n">Unique</span><span class="p">.</span><span class="n">IsValid</span><span class="p">()</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;true&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;false&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="n">GEngine</span><span class="o">-&gt;</span><span class="n">AddOnScreenDebugMessage</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="n">FColor</span><span class="o">::</span><span class="n">Cyan</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ToPrint</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/adbf6a3aa47ed72647efcaac5bb0d4f2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="adbf6a3aa47ed72647efcaac5bb0d4f2.png" auto_="auto;" display="block;" margin:="margin:" src="../images/adbf6a3aa47ed72647efcaac5bb0d4f2.png" /></a></p>
<p>Когда <code>TUniquePtr</code> надо использовать?
Данный указатель рассчитан на использование с классами и структурами, не добавленными в сборщик мусора Unreal, потому что изначально под него не создавались, например с классами из сторонних<code>c++</code>библиотек или совместно с виджетами Slate.
Так-же некоторые аргументы функций и методы движка возвращают этот тип указателя.</p>
<h2 id="_12">Указатели на функции</h2>
<p>Поскольку функции тоже имеют свой адрес в памяти, очевидно, что на них можно получить указатель, а потом вызвать их по этому указателю.</p>
<p>Зачем это используется? Для расширения возможностей обычных функций, а так-же для передачи событий.</p>
<p>Например, в функцию сортировки можно скормить указатель на другую функцию, которая будет сравнивать сортируемые элементы. В Unreal есть тип TArray -&gt; Sort, который именно так и работает (с UObject).
Поэтому обойти данную тему никак не получится.</p>
<h3 id="_13">Классические указатели на функции в объекте</h3>
<p>Начнем с классики, с встроенной в язык<code>c++</code>механики указателей на функции. Без оберток, шаблонов и сторонних вспомогательных элементов.</p>
<p>Но сначала пара оговорок.</p>
<p>Функции внутри объектов принято называть методами. Но про термин "указатель на метод" я ниразу не слышал. Может он и есть, однако он не "звучит". Поэтому я буду пользоваться термином - "указатель на функцию", даже если это не функция, а метод.</p>
<p>Почему я решил рассмотреть именно указатель на функцию в объекте, а не просто указатель на функцию внутри примитивного демо?
Причина тут проста - примеров <em>обычных</em> указателей на <em>обычные</em> функции в гугле полно. И вы можете почитать оттуда все что надо сами. Я же предпочитаю писать о том, про что больше нигде почитать не получится.</p>
<p>Давайте создадим метод, над которым будем работать.</p>
<p>Для нас крайне важно, чтобы на этом методе можно было показать как можно больше примеров работы с данными.</p>
<p>Таким образом метод должен: принимать значение переменной классическим способом, по сслыке, по указателю, а так-же возвращать некое значение.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TESTMODULE_API</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">UActorComponent</span>
<span class="p">{</span>
<span class="c1">// код из этой секции был убран, чтобы уместить все внутрь статьи</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// This function will be passed as arg</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">LogApple</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ApplesCount</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;LogApple&quot;</span><span class="p">))</span>
<span class="w">        </span><span class="c1">// Note* FString can&#39;t be passed to UE_LOG directly, it needs wchar, so convert it via adding * before string arg - *Arg2</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Apples Count = %d, Const StringArg = %s, FloatArg = %f&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ApplesCount</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="p">)</span>
<span class="w">        </span><span class="c1">// change refrenced variables to test if changes are passed</span>
<span class="w">        </span><span class="n">ApplesCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ApplesCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="o">*</span><span class="n">Arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.1</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">ApplesCount</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
Обратите внимание, что сам метод находится в <code>public</code> секции класса <code>UPointersComponent</code>.
Теперь создадим указатель на этот метод. Указатель будет реализован в качестве "виртуального поля" для класса. Такое поле не создается непосредственно в самом классе, а привязывается к нему "на лету". Так  можно делать, но только с указателями.
<div class="highlight"><pre><span></span><code><span class="c1">// only memebers of UPointersComponent can call it&#39;s functions directly by ref</span>
<span class="c1">// so i create &quot;virtual pointer&quot; UPointersComponent::*pFunc</span>
<span class="c1">// that will be bound to the class and can interact with it</span>
<span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">UPointersComponent</span><span class="o">::*</span><span class="n">pFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">){</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">LogApple</span><span class="w"> </span><span class="c1">// default bound function, not necessary</span>
<span class="p">};</span>
<span class="n">pFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">LogApple</span><span class="p">;</span>
</code></pre></div>
<code>UPointersComponent::*pFunc</code> - тут я привязываю указатель pFunc к классу <code>UPointersComponent</code>.
Формат указателя на функцию следующий:
<div class="highlight"><pre><span></span><code><span class="c1">// чистое определение</span>
<span class="n">возвращаемый_тип</span><span class="w"> </span><span class="p">(</span><span class="n">класс_владелец_функции</span><span class="o">::*</span><span class="n">название_указателя</span><span class="p">)(</span><span class="n">аргументы</span><span class="p">){</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">функция_на_которую_ссылаемся</span><span class="s">&quot;по умолчанию&quot;</span>
<span class="p">}</span>
<span class="c1">// можно использовать using:</span>
<span class="k">using</span><span class="w"> </span><span class="n">название_указателя</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">возвращаемый_тип</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">аргументы</span><span class="p">);</span>
<span class="c1">// или typedef</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">возвращаемый_тип</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">название_указателя</span><span class="p">)(</span><span class="n">аргументы</span><span class="p">);</span>
</code></pre></div>
Присвоить функцию к такому указателю можно следующей строкой:
<div class="highlight"><pre><span></span><code><span class="n">pFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">LogApple</span><span class="p">;</span>
</code></pre></div>
По сути мы берем адрес функции внутри класса, используя оператор <code>&amp;</code> и присваиваем его указателю.</p>
<p>Поскольку у нас значение <code>&amp;UPointersComponent::LogApple;</code> уже присвоено указателю при его создании, как значение "по умолчанию", в этой строчке <code>pFunc = &amp;UPointersComponent::LogApple;</code> нет никакого смысла. Она тут исключительно для демонстрации.</p>
<p>Теперь этот указатель надо передать в другую функцию, в качестве ее аргумента.
<div class="highlight"><pre><span></span><code><span class="c1">// This function recives pointer to other function as argument</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ReciveFunctionPointerAsArg</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">objectPtr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="n">UPointersComponent</span><span class="o">::*</span><span class="n">pFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">FVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.1f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StrVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Test String&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Run Function</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">objectPtr</span><span class="o">-&gt;*</span><span class="n">pFunc</span><span class="p">)(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">StrVar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVar</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Classic Pointer&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Apples Returned = %d, Float Var Returned = %f, Const StringVar Returned = %s&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="p">,</span><span class="w"> </span><span class="n">FVar</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">StrVar</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
Аргумент передаваемой функции задается по точно тому-же формату, то есть <code>int(UPointersComponent::*pFunc)(int, const FString&amp;, float*)</code>, где <code>pFunc</code> - название указателя. Я просто скопировал, потому что ленивый.</p>
<p>Чтобы вызвать функцию, переданную по аргументу, я использовал следующий код:
<div class="highlight"><pre><span></span><code><span class="c1">// Run Function</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">objectPtr</span><span class="o">-&gt;*</span><span class="n">pFunc</span><span class="p">)(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">StrVar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVar</span><span class="p">);</span>
</code></pre></div>
Вместе с указателем на функцию мы передаем так-же  и объект, к которому привязан этот указатель<code>UPointersComponent * objectPtr</code>.
Без передачи объекта вызвать указатель <code>pFunc</code> у вас НЕ ПОЛУЧИТСЯ (там есть вариант использовать TFunctionRef, встроенный в Unreal Engine, но этот вариант мы рассмотрим чуть пожже).
Чтобы передать указатель на функцию <code>LogApple</code> в функцию <code>ReciveFunctionPointerAsArg</code> используется следующий код:
<div class="highlight"><pre><span></span><code><span class="c1">// only memebers of UPointersComponent can call it&#39;s functions directly by ref</span>
<span class="c1">// so i create &quot;virtual pointer&quot; UPointersComponent::*pFunc</span>
<span class="c1">// that will be bound to the class and can interact with it</span>
<span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="n">UPointersComponent</span><span class="o">::*</span><span class="n">pFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">){</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">LogApple</span><span class="w"> </span><span class="p">};</span>
<span class="n">pFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">LogApple</span><span class="p">;</span>
<span class="c1">// pass function ref</span>
<span class="n">ReciveFunctionPointerAsArg</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">pFunc</span><span class="p">);</span>
</code></pre></div>
Обратите внимание на то, что в качестве указателя на объект я передаю <code>this</code>. Я бы мог этого не делать, поскольку оба метода принадлежат одному классу.</p>
<p>Так что код мог бы выглядеть вот так:
<div class="highlight"><pre><span></span><code><span class="c1">// This function recives pointer to other function as argument</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ReciveFunctionPointerAsArg</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="n">UPointersComponent</span><span class="o">::*</span><span class="n">pFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">FVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.1f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StrVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Test String&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Run Function</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;*</span><span class="n">pFunc</span><span class="p">)(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">StrVar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVar</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Classic Pointer&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Apples Returned = %d, Float Var Returned = %f, Const StringVar Returned = %s&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="p">,</span><span class="w"> </span><span class="n">FVar</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">StrVar</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
И это отлично будет работать.</p>
<p>Но я решил продемонстрировать как именно передавать указатель, если он вдруг принадлежит другому объекту.</p>
<p>Я поместил код создания указателя в конструктор компонента <code>UPointersComponent</code>.</p>
<p><a class="glightbox" href="../images/ae6170be5d4aafd63205f13ea5be1f1a.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ae6170be5d4aafd63205f13ea5be1f1a.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ae6170be5d4aafd63205f13ea5be1f1a.png" /></a></p>
<p>После компиляции мы увидим следующее:
<div class="highlight"><pre><span></span><code><span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">LogApple</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">Apples</span><span class="w"> </span><span class="n">Count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">StringArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">FloatArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.100000</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">Classic</span><span class="w"> </span><span class="n">Pointer</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">Apples</span><span class="w"> </span><span class="n">Returned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">Float</span><span class="w"> </span><span class="n">Var</span><span class="w"> </span><span class="n">Returned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.200000</span><span class="p">,</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">StringVar</span><span class="w"> </span><span class="n">Returned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="n">String</span>
</code></pre></div>
Обратите внимание как меняет свое значение <code>float</code> параметр.</p>
<p>В функции <code>LogApple</code> я меняю его значение следующим образом:
<div class="highlight"><pre><span></span><code><span class="o">*</span><span class="n">Arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.1</span><span class="p">;</span>
</code></pre></div>
Поскольку значение данного аргумента передано по указателю, то оно изменяется и в исходной функции.</p>
<p><a class="glightbox" href="../images/e2c4684e7e1abd9283aec7ac5d4af407.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="e2c4684e7e1abd9283aec7ac5d4af407.png" auto_="auto;" display="block;" margin:="margin:" src="../images/e2c4684e7e1abd9283aec7ac5d4af407.png" /></a></p>
<p>поэтому <code>FloatArg = 3.100000</code> после вызова функции по ссылке становится <code>Float Var Returned = 4.200000</code>.</p>
<h3 id="stl">Указатели на функцию в стандартной библиотеке (STL)</h3>
<p>В стандартной библиотеке<code>c++</code>есть шаблон - <code>std::function</code> который представляет из себя умный указатель на функцию.</p>
<p>Формат:
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function_name</span><span class="p">;</span>
</code></pre></div>
Где <code>return_type</code> это возвращаемый функцией тип, а <code>arg1, arg2</code> - аргументы функции.</p>
<p>Используется так:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="c1"> // std::function</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> // printf</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">test_calculations</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">test_function_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">test_calculations</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;called function template pointer value = %f&quot;</span><span class="p">,</span><span class="n">test_function_pointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/4db56e7a214b38e14bc41e6fdff998db.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4db56e7a214b38e14bc41e6fdff998db.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4db56e7a214b38e14bc41e6fdff998db.png" /></a></p>
<p>Однако учтите, что шаблон <code>std::function</code> не может работать с классами напрямую. Дальше я рассмотрю как такое ограничение можно обойти через лямбды.</p>
<p>Такой код работать не будет:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="c1"> // std::function</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> // printf</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassTest</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">test_calculations</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">test_function_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ClassTest</span><span class="o">::</span><span class="n">test_calculations</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;called function template pointer value = %f&quot;</span><span class="p">,</span><span class="n">test_function_pointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/27af92d646f7b0d8b0e29177f85872fb.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="27af92d646f7b0d8b0e29177f85872fb.png" auto_="auto;" display="block;" margin:="margin:" src="../images/27af92d646f7b0d8b0e29177f85872fb.png" /></a></p>
<p>Причина проблем с указателями на методы классов состоит в том, что они привязаны к экземплярам классов. Если добавить к функции модификатор <code>static</code> код сработает.
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span><span class="c1"> // std::function</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> // printf</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ClassTest</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">test_calculations</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(){</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">test_function_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ClassTest</span><span class="o">::</span><span class="n">test_calculations</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;called function template pointer value = %f&quot;</span><span class="p">,</span><span class="n">test_function_pointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="unreal">Указатели на функцию в Unreal</h3>
<p>Unreal предоставляет разработчику следующие шаблоны для реализации указателей на функцию:
<code>TFunction</code> - шаблонный класс, который хранит в себе копию лямбды или статичной функции. Под копией подразумевается прямое копирование памяти, в которой находится функция или лямбда. Это позволяет использовать переменные типа <code>TFunction</code> даже там, где нет доступа к пространству из которого лямда или функция были созданы.
<code>TUniqueFunction</code> - шаблонный класс, который хранит в себе копию вызываемой лямбды или статичной функции. То есть работает как <code>TFunction</code>. Однако отличие есть и  оно существенно. Сами экземпляры <code>TUniqueFunction</code> нельзя копировать. Это такой аналог <code>TUniquePtr</code> для указателей на функции. Экземпляр данного класса не получится передать в качестве аргумента на функцию, без использования <code>MoveTemp</code> или <code>std::move</code>.
<code>TFunctionRef</code> - шаблонный класс, который хранит в себе указатель на статичную функцию или лямбду. Область возможного вызова переменной типа <code>TFunctionRef</code> ограничена областью ее видимости. <code>TFunctionRef</code> в принципе нельзя передать в другие методы, если только переменная типа <code>TFunctionRef</code> не находится в глобальном пространстве.</p>
<p>Как и в случае с <code>std::function</code>, каждый из вышеуказанных шаблонных классов может ссылаться лишь на <code>static</code> функции классов. Чтобы обойти это ограничение можно использовать лямбду, про это читайте в главе про лямбды, ниже.</p>
<p>Формат каждого из шаблонных типов следующий:
Формат:
<div class="highlight"><pre><span></span><code><span class="n">TFunction</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function_name</span><span class="p">;</span>
<span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function_name</span><span class="p">;</span>
<span class="n">TFunctionRef</span><span class="o">&lt;</span><span class="n">return_type</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function_name</span><span class="p">;</span>
</code></pre></div>
Где <code>return_type</code> это возвращаемый функцией тип, а <code>arg1, arg2</code> - аргументы функции.</p>
<blockquote>
<p><em>тем кто не понимает как в<code>c++</code>работают лямбды - ниже я написал целую главу, которая посвящена этому вопросу</em>
Рассмотрим примеры использования.</p>
</blockquote>
<h4 id="tfunction"><code>TFunction</code></h4>
<p>Хранит в себе копию лямбды или статичного метода, позволяя вызывать их даже в том случае, если оригинальный объект, содаржащий их - уничтожен или не доступен.
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// This function is used to test function pointers to static functions</span>
<span class="c1">// This function is used to test function pointers to static methods</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">TestSummFunc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// This will test TFunction as arg</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TFunctionAsArgTest</span><span class="p">(</span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Value = %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// BeginPlay</span>
<span class="c1">// Create pointer</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; === TFunction ===&quot;</span><span class="p">));</span>
<span class="c1">// Create pointer</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FuncPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">TestSummFunc</span><span class="p">;</span>
<span class="w">    </span><span class="n">FuncPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Call pointer directly</span>
<span class="w">    </span><span class="n">TFunctionAsArgTest</span><span class="p">(</span><span class="n">FuncPointer</span><span class="p">);</span><span class="w"> </span><span class="c1">// Pass pointer as arg</span>
<span class="p">}</span>
<span class="c1">// With Lambda</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; === Lambda ===&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LambdaPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">LambdaPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Call lambda directly</span>
<span class="w">    </span><span class="n">TFunctionAsArgTest</span><span class="p">(</span><span class="n">LambdaPointer</span><span class="p">);</span><span class="w"> </span><span class="c1">// Pass lambda as arg</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/20efe5e1bb3e3394ac953bf81acdff78.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="20efe5e1bb3e3394ac953bf81acdff78.png" auto_="auto;" display="block;" margin:="margin:" src="../images/20efe5e1bb3e3394ac953bf81acdff78.png" /></a></p>
<p><a class="glightbox" href="../images/ab18c8befebc6d7a9a397de5ea2e4ba7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ab18c8befebc6d7a9a397de5ea2e4ba7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ab18c8befebc6d7a9a397de5ea2e4ba7.png" /></a></p>
<p><a class="glightbox" href="../images/19da434d43a3420c0a8423fdd438233f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="19da434d43a3420c0a8423fdd438233f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/19da434d43a3420c0a8423fdd438233f.png" /></a></p>
<h4 id="tfunctionref"><code>TFunctionRef</code></h4>
<p>Представляет из себя альтернативу <code>TFunction</code>, просто хранит в себе указатель на статичный метод или лямбду. Если объект, в котором задана эта лямбда или метод - удалены, то указатель в <code>TFunctionRef</code> становится <code>nullptr</code>. Из-за этой особенности <code>TFunctionRef</code> не получится передать в другие методы, если только указатель не задан глобально.
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// This function is used to test function pointers</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">TestSummFunc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// This will test TFunctionRef as arg</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TFunctionAsArgTest</span><span class="p">(</span><span class="n">TFunctionRef</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Value = %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// BeginPlay</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; === TFunctionRef ===&quot;</span><span class="p">));</span>
<span class="c1">// Create pointer</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TFunctionRef</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FuncPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">TestSummFunc</span><span class="p">;</span>
<span class="w">    </span><span class="n">FuncPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Call pointer directly</span>
<span class="p">}</span>
<span class="c1">// With Lambda</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; === Lambda ===&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">TFunctionRef</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LambdaPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">LambdaPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Call lambda directly</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/5a6a1eb7ec6bb2ecf48c3b1f3ee6b599.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5a6a1eb7ec6bb2ecf48c3b1f3ee6b599.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5a6a1eb7ec6bb2ecf48c3b1f3ee6b599.png" /></a></p>
<h4 id="tuniquefunction"><code>TUniqueFunction</code></h4>
<p>Функция с отключенной возможностью копирования. В памяти может быть лишь по 1 экземпляру этого типа.</p>
<p>Передать <code>TUniqueFunction</code> в качестве аргумента функции обычным способом у нас не получится.</p>
<p><a class="glightbox" href="../images/da66f1d26370c10f11dc4216776ed399.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="da66f1d26370c10f11dc4216776ed399.png" auto_="auto;" display="block;" margin:="margin:" src="../images/da66f1d26370c10f11dc4216776ed399.png" /></a></p>
<p>Придется использовать <code>MoveTemp</code>. Просто оберните вызов при передаче.</p>
<p><a class="glightbox" href="../images/81ebc3e1930c574422649ccb2a45465f.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="81ebc3e1930c574422649ccb2a45465f.png" auto_="auto;" display="block;" margin:="margin:" src="../images/81ebc3e1930c574422649ccb2a45465f.png" /></a></p>
<p>Общий код:
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// This function is used to test function pointers</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">TestSummFunc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// This will test TUniqueFunction as arg</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TFunctionAsArgTest</span><span class="p">(</span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TestFuncPtr</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Value = %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Value</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ..</span>
<span class="c1">// .cpp</span>
<span class="c1">// BeginPlay</span>
<span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; === TUniqueFunction ===&quot;</span><span class="p">));</span>
<span class="c1">// Create pointer</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FuncPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">UPointersComponent</span><span class="o">::</span><span class="n">TestSummFunc</span><span class="p">;</span>
<span class="w">    </span><span class="n">FuncPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Call pointer directly</span>
<span class="w">    </span><span class="n">TFunctionAsArgTest</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">FuncPointer</span><span class="p">));</span><span class="w"> </span><span class="c1">// Pass pointer as arg</span>
<span class="p">}</span>
<span class="c1">// With Lambda</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot; === Lambda ===&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="n">TUniqueFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LambdaPointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span><span class="p">{</span>
<span class="w">        </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;C is %s, Summ IS %d&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">LambdaPointer</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TEST&quot;</span><span class="p">));</span><span class="w"> </span><span class="c1">// Call lambda directly</span>
<span class="w">    </span><span class="n">TFunctionAsArgTest</span><span class="p">(</span><span class="n">MoveTemp</span><span class="p">(</span><span class="n">LambdaPointer</span><span class="p">));</span><span class="w"> </span><span class="c1">// Pass lambda as arg</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/03a5255e7819865e632439a6714c6e55.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="03a5255e7819865e632439a6714c6e55.png" auto_="auto;" display="block;" margin:="margin:" src="../images/03a5255e7819865e632439a6714c6e55.png" /></a></p>
<h2 id="_14">Лямбды в С++</h2>
<p>Лямбды в <code>с++</code> представляют собой оператор, который разворачивается во вложенную структуру т.н. функтор. Главное преимущество лямбд состоит универсальности.</p>
<p>В последующих статьях я очень часто использую лямбды (и вам рекомендую), поэтому, пожалуйста, прочитайте эту главу.</p>
<h4 id="-">Формат лямбда-выражения</h4>
<p>Давайте рассмотрим формат лямбда-выражения.
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">спецификаторы</span><span class="p">](</span><span class="n">аргументы</span><span class="p">)</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">возвращаемый_тип</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">тело_лямбды</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">возвращаемый_тип</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
Технически лямбды представляют собой оператор препроцессора, который разворачивает указанную выше конструкцию в функтор примерно следующего вида:
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">LambdaName</span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="n">Args</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// ваши вычисления</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
Таким образом лямбда не более чем оператор препроцессора, а не полноценный рунтайм оператор языка. Это важно понимать, потому что при передаче лямбды по указателю возникают противоречия между декларируемым определением (анонимная функция) и фактическим поведением (как объект). Потому что лямбда в <code>с++</code> - это никакая не анонимная функция (в чем нас уверяют некоторые интернет-туториалы). Лямбда - это генерируемый функтор, по сути заплатка над старым ядром языка.</p>
<h4 id="_15">Спецификаторы</h4>
<p>Рассмотрим массив <code>спецификаторы</code> (lambda captures). Он используется для передачи доступа к переменным из функции или класса в лямбду.</p>
<p>Например если сделать так:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
То мы увидим следующую ошибку: <code>an enclosing-function local variable cannot be refrenced in a lambda body unless it is in the caputre list</code>.</p>
<p><a class="glightbox" href="../images/5c7f61e96f41cc65151ec90598f1eae6.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="5c7f61e96f41cc65151ec90598f1eae6.png" auto_="auto;" display="block;" margin:="margin:" src="../images/5c7f61e96f41cc65151ec90598f1eae6.png" /></a></p>
<p>Но если в список <code>[]</code> передать по ссылке переменную <code>a</code> - ошибка исчезнет.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">a</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/f2616102c01a282a7407633477db623e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f2616102c01a282a7407633477db623e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f2616102c01a282a7407633477db623e.png" /></a></p>
<p>При этом значение не обязательно передавать по ссылке именно так. Мы можем заставить все переменные, переданные внутрь лямбды передаваться по ссылке используя ключевое слово <code>mutable</code>. В основном этот трюк используется вместе с многопоточностью.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/fe5d9274ae39bdb6ca363064da56467e.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fe5d9274ae39bdb6ca363064da56467e.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fe5d9274ae39bdb6ca363064da56467e.png" /></a></p>
<p>Согласитесь, передавать каждую переменную из функции в лямбду поштучно - не очень практично.</p>
<p>С++ предоставляет нам ряд спецификаторов, которыми можно пользоваться, чтобы упростить себе жизнь.
<code>&amp;</code> - данный спецификатор позволит использовать внутри тела лямбды все переменные, которые были заданы в функции. При этом переменные будут передаваться в лямбду "по ссылке", то есть их можно будет изменить в лямбде.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/fc7c2c49e9aa17388100f8e0d8d8554b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="fc7c2c49e9aa17388100f8e0d8d8554b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/fc7c2c49e9aa17388100f8e0d8d8554b.png" /></a></p>
<p><code>=</code> - данный  спецификатор передает в тело переменные из функции "по значению". Переданные переменные нельзя будет изменить из тела лямбды. Можно будет лишь получить их значения.</p>
<p>Поэтому такой код работать не будет:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/7bbe1a9aeb8b3574649e2829f4d80e4a.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="7bbe1a9aeb8b3574649e2829f4d80e4a.png" auto_="auto;" display="block;" margin:="margin:" src="../images/7bbe1a9aeb8b3574649e2829f4d80e4a.png" /></a></p>
<p>А вот такой код работать будет, потому что тут я не пытаюсь изменить переменную <code>a</code>, которая передается "по значению":
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/6ff8bc4bd9dd56e01665dc7c3767ddb8.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="6ff8bc4bd9dd56e01665dc7c3767ddb8.png" auto_="auto;" display="block;" margin:="margin:" src="../images/6ff8bc4bd9dd56e01665dc7c3767ddb8.png" /></a></p>
<p>Однако, это ограничение легко обходится, благодаря ключевому слову <code>mutable</code>.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;num = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"> </span><span class="c1">// 5</span>
<span class="p">[</span><span class="o">=</span><span class="p">]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"> </span><span class="c1">// now we can change variable value in local space</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;num = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"> </span><span class="c1">// 7</span>
<span class="p">}();</span><span class="w"> </span><span class="c1">// this lambda will be self-executed</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;num = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span><span class="w"> </span><span class="c1">// but this won&#39;t affect lambda value outside</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/91f1a754f03553b9325937579ea09e2b.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="91f1a754f03553b9325937579ea09e2b.png" auto_="auto;" display="block;" margin:="margin:" src="../images/91f1a754f03553b9325937579ea09e2b.png" /></a></p>
<p>Как вы видите из этого примера - <code>mutable</code> спецификатор не выводит значение переменной за пределы лямбды.</p>
<h4 id="_16">Псевдонимы спецификаторов</h4>
<p>Через спецификаторы можно здавать псевдонимы для тех или иных переменных используя следующий синтаксис:
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">alias</span><span class="o">=</span><span class="n">variable</span><span class="p">]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="p">{}</span>
</code></pre></div>
Например так.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var = %i&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">l</span><span class="p">();</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/4a24d019c0eff5d083a3375f018d11f7.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4a24d019c0eff5d083a3375f018d11f7.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4a24d019c0eff5d083a3375f018d11f7.png" /></a></p>
<p>Создавать переменную псевдонима отдельно от тела лямбды - не надо, она генерируется автоматически.</p>
<p>Псевдоним переменной получает данные "по значению", а значит - его не поулчится изменить в теле лямбды, если не использовать спецификатор <code>mutable</code>.
То есть такой код не сработает:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var = %i&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">l</span><span class="p">();</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/3b7bb236e60cb8cae3dc968176367e23.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="3b7bb236e60cb8cae3dc968176367e23.png" auto_="auto;" display="block;" margin:="margin:" src="../images/3b7bb236e60cb8cae3dc968176367e23.png" /></a></p>
<p>Зато  с <code>mutable</code> лямбдой все работает, правда значение псевдонима, измененное в теле лямбды, не отражается на оригинальном значении переменной.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;n = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// 7</span>
<span class="k">auto</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">]()</span><span class="w"> </span><span class="k">mutable</span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span><span class="w"> </span><span class="c1">// 2</span>
<span class="p">};</span>
<span class="n">l</span><span class="p">();</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;n = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"> </span><span class="c1">// still 7</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/70dfdc8823c1c708da3564c192d08630.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="70dfdc8823c1c708da3564c192d08630.png" auto_="auto;" display="block;" margin:="margin:" src="../images/70dfdc8823c1c708da3564c192d08630.png" /></a></p>
<p>Используя псевдонимы можно работать с <code>move</code> семантикой внутри лямбды.</p>
<p>Я еще не рассматривал эту тему, но если вы знаете, о чем речь, то вот так можно передать переменную <code>a</code> в лямбду через <code>std::move</code>:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;a = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// 7</span>
<span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">)]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="p">}();</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;a = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// 7</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/a7e7fdc3009b72e648e283c50241af51.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a7e7fdc3009b72e648e283c50241af51.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a7e7fdc3009b72e648e283c50241af51.png" /></a></p>
<p>Правда на значениях применение <code>move</code>  семантики никак не сказыается. Потому что у стандартных типов, вроде <code>int</code>, <code>char</code> и так далее - нет <code>move</code> конструктора и оператора присваивания.</p>
<p>А вот у <code>std::string</code> он есть, давайте проверим.
<div class="highlight"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;in&quot;</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;str = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"> </span><span class="c1">// &quot;in&quot;</span>
<span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str</span><span class="p">)]()</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span>
<span class="w">    </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;out&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"> </span><span class="c1">// &quot;out&quot;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>
<span class="p">}();</span><span class="w"> </span><span class="c1">// lambda will be self-executed, thanks to the ending &#39;()&#39;, and it&#39;s return value will be put in to str variable</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;str = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span><span class="w"> </span><span class="c1">// &quot;out&quot;</span>
</code></pre></div></p>
<h4 id="_17">Автозапуск лямбды</h4>
<p>В приведенном выше коде я использовал т.н. автозапуск лямбды.</p>
<p>Если прописать <code>()</code> после лямбды - она запустится  автоматически.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="p">[</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">)]()</span><span class="o">-&gt;</span><span class="kt">void</span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;var = %i&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>
<span class="p">}();</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/a7c8c3b9b5d0119215fd0a68ce8a7413.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a7c8c3b9b5d0119215fd0a68ce8a7413.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a7c8c3b9b5d0119215fd0a68ce8a7413.png" /></a></p>
<p>Можно даже вернуть из лямбды значение или передать в нее аргументы таким образом.
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">summ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
<span class="p">}(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span><span class="c1">// this will run lambda with 2 arguments: 3 and 5</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;summ = %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">summ</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/f9fd84b6cc6981e15487fc32211f92a6.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="f9fd84b6cc6981e15487fc32211f92a6.png" auto_="auto;" display="block;" margin:="margin:" src="../images/f9fd84b6cc6981e15487fc32211f92a6.png" /></a></p>
<h4 id="_18">Обращение к методам класса из тела лямбды</h4>
<p>Теперь рассмотрим обращение к методам класса, на примере <code>LogApple</code>.
Если обратиться к этому методу не используя спецификаторы, то будет ошибка: <code>the enclosing-function 'this' cannot be referenced in a lambda body unless it is in the capture list</code>.
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">FVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.3f</span><span class="p">;</span>
<span class="w">        </span><span class="n">LogApple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;123&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVal</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/02e5359d1bc0244e01c5ff4b01c6df53.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="02e5359d1bc0244e01c5ff4b01c6df53.png" auto_="auto;" display="block;" margin:="margin:" src="../images/02e5359d1bc0244e01c5ff4b01c6df53.png" /></a></p>
<p>Текст ошибки прямо намекает, что параметр <code>this</code> должен находиться в массиве спецификаторов <code>capture list</code>.
Если его добавить - ошибка исчезнет.
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">FVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.3f</span><span class="p">;</span>
<span class="w">        </span><span class="n">LogApple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;123&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVal</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/1000b87b489a4352072852a78af109b5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1000b87b489a4352072852a78af109b5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1000b87b489a4352072852a78af109b5.png" /></a></p>
<p>Рассмотрим спецификаторы классов:
<code>this</code> - данный спецификатор передает класс внутрь лямбды по указателю, то есть мы сможем менять его внутренние значения и вызывать методы.</p>
<p>Введем, для наглядности, дополнительную переменную <code>LabdaCaptureTest</code>. Да, это опечатка, заметил уже когда закончил статью.</p>
<p><a class="glightbox" href="../images/992a580dd7e31e12ae7e74fc67f0ea30.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="992a580dd7e31e12ae7e74fc67f0ea30.png" auto_="auto;" display="block;" margin:="margin:" src="../images/992a580dd7e31e12ae7e74fc67f0ea30.png" /></a></p>
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">FVal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.3f</span><span class="p">;</span>
<span class="w">        </span><span class="n">LogApple</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;123&quot;</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVal</span><span class="p">);</span>
<span class="w">        </span><span class="n">LabdaCaptureTest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
</code></pre></div>
<p><a class="glightbox" href="../images/c8d6ab7d4e06e8e5f22214752ff22443.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c8d6ab7d4e06e8e5f22214752ff22443.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c8d6ab7d4e06e8e5f22214752ff22443.png" /></a></p>
<p><code>*this</code> - данный спецификатор передает класс внутрь лямбды по "значению". Это значит, что мы не сможем изменить поля класса внутри лямбды. Так-же мы не сможем вызвать из тела лямбды другие методы класса. Мы сможем лишь получить значение полей и все.</p>
<p>Поэтому предыдущий код с этим спецификатором выдаст нам ошибку: <code>the object has type qualifiers that are not compatible ...</code>.</p>
<p><a class="glightbox" href="../images/350a60964abd56a29e948282d8a63208.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="350a60964abd56a29e948282d8a63208.png" auto_="auto;" display="block;" margin:="margin:" src="../images/350a60964abd56a29e948282d8a63208.png" /></a></p>
<p>Зато следующий код будет работать:
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">*</span><span class="k">this</span><span class="p">]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LambdaCaptureTest</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/51184a9c75d0b2b3f924eb273462ce02.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="51184a9c75d0b2b3f924eb273462ce02.png" auto_="auto;" display="block;" margin:="margin:" src="../images/51184a9c75d0b2b3f924eb273462ce02.png" /></a></p>
<p>Теперь, ознакомившись с лямбдами, мы можем рассмотреть их передачу в функции и  методы.</p>
<h4 id="_19">Вызов метода класса из тела лямбды</h4>
<p>Для начала подготовим небольшой код, который будет передавать лямбда.</p>
<p>Воспользуемся методом <code>UPointersComponent::LogApple</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// This function will be passed as arg</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">UPointersComponent::LogApple</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">ApplesCount</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;LogApple&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="c1">// Note* FString can&#39;t be passed to UE_LOG directly, it needs wchar, so convert it via adding * before string arg - *Arg2</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Apples Count = %d, Const StringArg = %s, FloatArg = %f&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ApplesCount</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// change refrenced variables to test if changes are passed</span>
<span class="w">    </span><span class="n">ApplesCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ApplesCount</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">Arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">Arg3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1.1</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ApplesCount</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
Поместим вызов метода <code>UPointersComponent::LogApple</code> внутрь лямбды, для дальнейшего тестирования.</p>
<p>Чтобы вызывать метод класса из тела лямбды, надо передать в лямбду, так или иначе, указатель на оригинальный класс.</p>
<p>Сделать это можно двумя способами:
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">Arg3</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">LogApple</span><span class="p">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="n">Arg3</span><span class="p">);</span>
<span class="p">};</span>
<span class="k">auto</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">Arg3</span><span class="p">,</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="w"> </span><span class="o">*</span><span class="n">SrcClass</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SrcClass</span><span class="o">-&gt;</span><span class="n">LogApple</span><span class="p">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="n">Arg3</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
Первый способ - <code>auto lambda1 = [this](int Arg1, const FString&amp; Arg2, float* Arg3) -&gt; int{ return LogApple(Arg1, Arg2, Arg3); };</code> использует спецификатор <code>[this]</code>.
Недостаток данного способа создания лямбды  следующий  - эту лямбду нельзя передать в функцию по указателю стандартными средствами.</p>
<p>Зато данная лямбда куда короче второй, а ее код куда более лаконичный.</p>
<p>Второй способ - <code>auto lambda = [](int Arg1, const FString&amp; Arg2, float* Arg3, UPointersComponent *SrcClass) -&gt; int{ return SrcClass-&gt;LogApple(Arg1, Arg2, Arg3); };</code>. Эта лямбда не использует захват пространства и класса, но она длиннее, из-за необходимости ввода еще одного аргумента - <code>UPointersComponent *SrcClass</code>. Ведь очевидно, что без этого аргумента вызвать метод <code>LogApple</code> внутри лямбды не получится.</p>
<p>Зато данная лямбда может быть преобразована в указатель на функцию.</p>
<p>Именно ее мы и будем передавать.</p>
<h4 id="_20">Передача лямбды в функцию по указателю</h4>
<p>Функция, в которую будет передаваться лямбда выглядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// This function recives pointer to other function as argument</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ReciveFunctionPointerAsArgLambda</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="o">*</span><span class="w"> </span><span class="n">objectPtr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">pFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="o">*</span><span class="w"> </span><span class="n">SrcClass</span><span class="p">)</span>
<span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">FVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.1f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StrVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Test String&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Run Function</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pFunc</span><span class="p">)(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">StrVar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVar</span><span class="p">,</span><span class="w"> </span><span class="n">objectPtr</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Lambda in function&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Apples Returned = %d, Float Var Returned = %f, Const StringVar Returned = %s&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="p">,</span><span class="w"> </span><span class="n">FVar</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">StrVar</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
Как вы видите, аргумент по которому передается лямбда - <code>int(*pFunc)(int, const FString&amp;, float*, UPointersComponent* SrcClass)</code> - являет собой обычный указатель на функцию. <code>С++</code> автоматически преобразовывает лямбду без модификаторов в указатель на функцию.</p>
<p>Вызывается лямбда тоже классическим способом - <code>int ApplesReturn = (*pFunc)(5, StrVar, &amp;FVar, objectPtr);</code>.
Код, передающий лямбду, выглядит так:
<div class="highlight"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">Arg3</span><span class="p">,</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="w"> </span><span class="o">*</span><span class="n">SrcClass</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">SrcClass</span><span class="o">-&gt;</span><span class="n">LogApple</span><span class="p">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="n">Arg3</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="n">ReciveFunctionPointerAsArgLambda</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">lambda</span><span class="p">);</span>
</code></pre></div>
Я добавил его в конструктор класса <code>UPointersComponent</code></p>
<p><a class="glightbox" href="../images/1ea7afe2cb1fcc39dd050dcb168bf4c5.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1ea7afe2cb1fcc39dd050dcb168bf4c5.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1ea7afe2cb1fcc39dd050dcb168bf4c5.png" /></a></p>
<p>Если сейчас запустить выполнение этого кода, мы увидим следующий результат:
<div class="highlight"><pre><span></span><code><span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">LogApple</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">Apples</span><span class="w"> </span><span class="n">Count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">StringArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">FloatArg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.100000</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">Lambda</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">function</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="n">Apples</span><span class="w"> </span><span class="n">Returned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">Float</span><span class="w"> </span><span class="n">Var</span><span class="w"> </span><span class="n">Returned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.200000</span><span class="p">,</span><span class="w"> </span><span class="n">Const</span><span class="w"> </span><span class="n">StringVar</span><span class="w"> </span><span class="n">Returned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Test</span><span class="w"> </span><span class="n">String</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/219600e1f2818ac6bca18b091fd91653.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="219600e1f2818ac6bca18b091fd91653.png" auto_="auto;" display="block;" margin:="margin:" src="../images/219600e1f2818ac6bca18b091fd91653.png" /></a></p>
<p>Как вы видите, значение переданное по ссылке в лямбду (это <code>float</code>) изменяется, лямбда прекрасно работает.</p>
<h2 id="unreal-engine_2">Лямбды в <code>Unreal Engine</code></h2>
<p>Согласитесь, задавать аргумент функции с нужной лямбдой таким способом:
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">pFunc</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">UPointersComponent</span><span class="o">*</span><span class="w"> </span><span class="n">SrcClass</span><span class="p">)</span>
</code></pre></div>
крайне неудобно.
<code>Unreal Engine</code> предлагает разработчику ряд шаблонов, позволяющих ссылаться на те или иные лямбды или даже <code>blueprint</code> функции гораздо проще.</p>
<p>Это <code>TFunction</code>, <code>TUniqueFunction</code> и <code>TFunctionRef</code>.
Вот так, например, в <code>TFunction</code> можно поместить лямбду, вызывающую метод <code>LogApple</code>:
<div class="highlight"><pre><span></span><code><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pTFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">Arg3</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">LogApple</span><span class="p">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="n">Arg3</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="n">TFunctionRef</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pTFuncRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">Arg3</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">LogApple</span><span class="p">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="n">Arg3</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
</code></pre></div>
Обратите внимание на тот факт, что в передаваемых таким образом лямбдах Можно использовать спецификаторы. Тут я использую <code>[this]</code>. Это очень сильно упрощает работу.</p>
<h3 id="unreal_1">Лямбды как аргументы функций в <code>Unreal</code></h3>
<p>Рассмотрим функцию, принимающую <code>TFunction</code> как аргумент.
<div class="highlight"><pre><span></span><code><span class="c1">// This function recives pointer to other function as argument</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">ReciveFunctionPointerAsArgTF</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pFunc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">FVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.3f</span><span class="p">;</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StrVar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Test String&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Run Function</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pFunc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">StrVar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVar</span><span class="p">);</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;TFunction Pointer&quot;</span><span class="p">))</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;Apples Returned = %d, Float Var Returned = %f, Const StringVar Returned = %s&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="p">,</span><span class="w"> </span><span class="n">FVar</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">StrVar</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
Данная функция выглядит в разы проще, чем примеры из передачи лямбд по указателю, которые я приводил выше.</p>
<p>Чтобы вызвать переданную в <code>TFunction</code> лямбду я использую такой код:
<div class="highlight"><pre><span></span><code><span class="c1">// Run Function</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ApplesReturn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pFunc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">StrVar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">FVar</span><span class="p">);</span>
</code></pre></div>
Просто сравните этот метод с теми, что мы писали ранее. Он куда короче.</p>
<p><a class="glightbox" href="../images/119a8c8c4e77a79256659b333fe3b8fc.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="119a8c8c4e77a79256659b333fe3b8fc.png" auto_="auto;" display="block;" margin:="margin:" src="../images/119a8c8c4e77a79256659b333fe3b8fc.png" /></a></p>
<p>Вызов метода для тестирования я провожу из конструктора нашего <code>UPointersComponent</code>.
Код для передачи лямбды в функцию выглядит так:
<div class="highlight"><pre><span></span><code><span class="n">TFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pTFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">FString</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">Arg3</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">int</span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">LogApple</span><span class="p">(</span><span class="n">Arg1</span><span class="p">,</span><span class="w"> </span><span class="n">Arg2</span><span class="p">,</span><span class="w"> </span><span class="n">Arg3</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="c1">//TFunctionRef&lt;int(int, FString&amp;, float*)&gt; pTFuncRef = [this]( int Arg1, const FString&amp; Arg2, float* Arg3) -&gt; int{ return LogApple(Arg1, Arg2, Arg3); };</span>
<span class="n">ReciveFunctionPointerAsArgTF</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">pTFunc</span><span class="p">);</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/d88982a57092532dbc57da595248e036.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="d88982a57092532dbc57da595248e036.png" auto_="auto;" display="block;" margin:="margin:" src="../images/d88982a57092532dbc57da595248e036.png" /></a></p>
<p><a class="glightbox" href="../images/9db9da23791ecf647bcf2a1fa5f35517.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="9db9da23791ecf647bcf2a1fa5f35517.png" auto_="auto;" display="block;" margin:="margin:" src="../images/9db9da23791ecf647bcf2a1fa5f35517.png" /></a></p>
<p>К стати говоря, использовать <code>TFunction</code> для передачи лямбды - не самый оптимальный способ работы. Дело в том, что данный шаблон, при передаче его в функцию - копируется. И вот, вместо одной лямбды в памяти - у вас две лямбды в памяти. Это не оптимальный подход. Куда логичнее было бы использовать <code>TUniqueFunction</code> и <code>MoveTemp</code>.
Но для начала разберемся, что это за функции такие.</p>
<h3 id="_21">Пример использования лямбд для сортировки массива</h3>
<p>В качестве сортируемого элемента используем структуру.</p>
<p>Задаем в <code>PointersComponent.h</code>, в самом начале, такую структуру:
<div class="highlight"><pre><span></span><code><span class="c1">// .h</span>
<span class="c1">// Struct to test array sorting</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">FSortTests</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">FSortTests</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">InNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InNumber</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
Она содержит всего одно поле - <code>Number</code>, по которому и будет проводиться сортировка.</p>
<p>Теперь нужен массив типа <code>TArray</code> и заполнение его произвольными структурами.
<div class="highlight"><pre><span></span><code><span class="c1">// Sort TArray of structs using lambda</span>
<span class="n">TArray</span><span class="o">&lt;</span><span class="n">FSortTests</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StructsArray</span><span class="p">;</span>
<span class="c1">// add some items to array</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">11</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">17</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">28</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
</code></pre></div>
Для сортировки у класса <code>TArray</code> есть метод <code>Sort</code>, который принимает лямбду.</p>
<p>Код вызова данного метода выглядит так:
<div class="highlight"><pre><span></span><code><span class="n">StructsArray</span><span class="p">.</span><span class="n">Sort</span><span class="p">([](</span><span class="n">FSortTests</span><span class="w"> </span><span class="n">Item1</span><span class="p">,</span><span class="w"> </span><span class="n">FSortTests</span><span class="w"> </span><span class="n">Item2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// compare</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Item1</span><span class="p">.</span><span class="n">Number</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Item2</span><span class="p">.</span><span class="n">Number</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div>
Для  сортировки по возрастанию лямбда должна возвращать <code>true</code> если первый аргумент меньше второго, иначе - <code>false</code>.
Общий код выглядит так:
<div class="highlight"><pre><span></span><code><span class="c1">// Sort TArray of structs using lambda</span>
<span class="n">TArray</span><span class="o">&lt;</span><span class="n">FSortTests</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StructsArray</span><span class="p">;</span>
<span class="c1">// add some items to array</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">11</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">17</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">28</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">FSortTests</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
<span class="c1">// sorting</span>
<span class="n">StructsArray</span><span class="p">.</span><span class="n">Sort</span><span class="p">([](</span><span class="n">FSortTests</span><span class="w"> </span><span class="n">Item1</span><span class="p">,</span><span class="w"> </span><span class="n">FSortTests</span><span class="w"> </span><span class="n">Item2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// compare</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Item1</span><span class="p">.</span><span class="n">Number</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Item2</span><span class="p">.</span><span class="n">Number</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">// print sorted values to log</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">FSortTests</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">StructsArray</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">UE_LOG</span><span class="p">(</span><span class="n">LogTemp</span><span class="p">,</span><span class="w"> </span><span class="n">Warning</span><span class="p">,</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;%i&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">Item</span><span class="p">.</span><span class="n">Number</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
Я добавил его в конструктор класса <code>UPointersComponent</code>.</p>
<p><a class="glightbox" href="../images/ce58fe4604a465e520fac33c13eeb3bb.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="ce58fe4604a465e520fac33c13eeb3bb.png" auto_="auto;" display="block;" margin:="margin:" src="../images/ce58fe4604a465e520fac33c13eeb3bb.png" /></a></p>
<p>После компиляции и запуска, в консоли будет напечатано следующее:
<div class="highlight"><pre><span></span><code><span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">4</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">4</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">5</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">9</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">11</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">17</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">28</span>
<span class="nl">LogTemp</span><span class="p">:</span><span class="w"> </span><span class="n">Warning</span><span class="o">:</span><span class="w"> </span><span class="mi">100</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/350e757db33916744c5888663be91660.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="350e757db33916744c5888663be91660.png" auto_="auto;" display="block;" margin:="margin:" src="../images/350e757db33916744c5888663be91660.png" /></a></p>
<p>Как вы видите - сортировка сработала.</p>
<p>Именно так рекомендуется сортировать объекты внутри игры. Есть, конечно, возможность сделать пузырьковую сортировку чисто на <code>blueprint</code>, но работать она будет ужасно медленно.</p>
<p>А так будет выглядеть сортировка массива с <code>Actor'ами</code> по их дистанции до персонажа:
<div class="highlight"><pre><span></span><code><span class="n">FVector3d</span><span class="w"> </span><span class="n">PlayerLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetOwner</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetActorLocation</span><span class="p">();</span>
<span class="n">Array</span><span class="p">.</span><span class="n">Sort</span><span class="p">([</span><span class="n">PlayerLoc</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">AActor</span><span class="o">*</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">AActor</span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">FVector</span><span class="o">::</span><span class="n">DistSquared</span><span class="p">(</span><span class="n">PlayerLoc</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">-&gt;</span><span class="n">GetActorLocation</span><span class="p">())</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FVector</span><span class="o">::</span><span class="n">DistSquared</span><span class="p">(</span><span class="n">PlayerLoc</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">-&gt;</span><span class="n">GetActorLocation</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div></p>
<h3 id="blueprint_1">Пузырьковая сортировка на blueprint</h3>
<p>Раз уж мы затронули тему сортировки, замечу, что в <code>blueprint</code> делать ее не рекомендуется. Но если все-же без этого никак не обойтись (например вы пишете <code>blueprint</code> ассет на продажу и не можете использовать там <code>с++</code> код) то вот пример реализации такого рода сортировки:
Это мой старый код, выложенный на <a href="https://forums.unrealengine.com/t/help-with-sorting-an-array-in-a-blueprint/341376/4?u=alexanderst">форуме</a>.</p>
<p><a class="glightbox" href="../images/c057a64ce398bc4ead2ad80465ec4554.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="c057a64ce398bc4ead2ad80465ec4554.png" auto_="auto;" display="block;" margin:="margin:" src="../images/c057a64ce398bc4ead2ad80465ec4554.png" /></a></p>
<p><a class="glightbox" href="../images/49cfc0461f091624dc5f3d2b94ade32c.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="49cfc0461f091624dc5f3d2b94ade32c.png" auto_="auto;" display="block;" margin:="margin:" src="../images/49cfc0461f091624dc5f3d2b94ade32c.png" /></a></p>
<p><a class="glightbox" href="../images/57daa08ba779064bb8951da2c201a021.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="57daa08ba779064bb8951da2c201a021.png" auto_="auto;" display="block;" margin:="margin:" src="../images/57daa08ba779064bb8951da2c201a021.png" /></a></p>
<h2 id="tsoftobjectptr_1">Загрузка ассетов из <code>TSoftObjectPtr</code> и генерация компонентов</h2>
<p>Давайте протестируем загрузку данных из <code>TSoftObjectPtr</code> в генерируемый в рантайме компонент.</p>
<p>Для начала создадим переменную <code>TSoftObjectPtr</code>, в которой будет храниться указатель, на загружаемый ассет. Загружать будем <code>UStaticMesh</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// Static mesh ref that will be loaded into spawned component</span>
<span class="n">UPROPERTY</span><span class="p">(</span><span class="n">BlueprintReadWrite</span><span class="p">,</span><span class="w"> </span><span class="n">EditAnywhere</span><span class="p">,</span><span class="w"> </span><span class="n">Category</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;PointerLoadingTest&quot;</span><span class="p">)</span>
<span class="n">TSoftObjectPtr</span><span class="o">&lt;</span><span class="n">UStaticMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LoadedStaticMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
</code></pre></div>
Зададим данной переменной значение "по умолчанию" через конструктор.</p>
<p>В качестве меша будем использовать уже приевшийся нам синий кубик. Щелкаем по нему правой кнопкой мыши и выбираем пункт <code>Copy Refrence</code>.</p>
<p><a class="glightbox" href="../images/1eaf3760b5d70196183828ebe6e985cc.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1eaf3760b5d70196183828ebe6e985cc.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1eaf3760b5d70196183828ebe6e985cc.png" /></a></p>
<p>Загружаем в конструкторе данный рефренс в переменную, если ее значение равно <code>nullptr</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// soft static mesh ref</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">LoadedStaticMesh</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FString</span><span class="w"> </span><span class="n">StringAssetPath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;/Script/Engine.StaticMesh&#39;/Game/LevelPrototyping/Meshes/SM_ChamferCube.SM_ChamferCube&#39;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">LoadedStaticMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UKismetSystemLibrary</span><span class="o">::</span><span class="n">MakeSoftObjectPath</span><span class="p">(</span><span class="n">StringAssetPath</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<p><a class="glightbox" href="../images/b2161adf9f0f0d67ed7af63901ff5e16.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b2161adf9f0f0d67ed7af63901ff5e16.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b2161adf9f0f0d67ed7af63901ff5e16.png" /></a></p>
<p>Если теперь скомпилировать код, то в компоненте <code>PointersComponent</code> мы увидим переменную, со ссылкой на куб.</p>
<p><a class="glightbox" href="../images/4baeb6aa3e6b2b5c989d2e813df2faa2.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="4baeb6aa3e6b2b5c989d2e813df2faa2.png" auto_="auto;" display="block;" margin:="margin:" src="../images/4baeb6aa3e6b2b5c989d2e813df2faa2.png" /></a></p>
<p>Теперь давайте загрузим этот куб в <code>UStaticMeshComponent</code> внутри нашего персонажа.</p>
<p>Для этих целей нам потребуется функция, создающая озвученный компонент, а так-же функицонал асинхронного вызова этой функции.</p>
<p>Добавляем в <code>.h</code> файл функцию, которая будет спавнить компонент, а так-же переменную типа <code>TObjectPtr</code>, в которую будет помещена ссылка на созданный компонент.
<div class="highlight"><pre><span></span><code><span class="c1">// Spawned Static Mesh Component refrence</span>
<span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">UStaticMeshComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">StaticComponent</span><span class="p">;</span>
<span class="c1">// Spawns Static Mesh Component and attaches it to character</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">SpawnStaticMeshComponent</span><span class="p">();</span>
</code></pre></div>
И пишем реализацию.
<div class="highlight"><pre><span></span><code><span class="c1">// Spawns Static Mesh Component and attaches it to character</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UPointersComponent::SpawnStaticMeshComponent</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OwnerActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetOwner</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// component name</span>
<span class="w">    </span><span class="n">FName</span><span class="w"> </span><span class="n">NewMeshCompName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;CustomStaticComponent&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// create new static mesh object</span>
<span class="w">    </span><span class="n">StaticComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NewObject</span><span class="o">&lt;</span><span class="n">UStaticMeshComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">UStaticMeshComponent</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">(),</span><span class="w"> </span><span class="n">NewMeshCompName</span><span class="p">,</span><span class="w"> </span><span class="n">RF_NoFlags</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">StaticComponent</span><span class="o">-&gt;</span><span class="n">SetupAttachment</span><span class="p">(</span><span class="n">OwnerActor</span><span class="o">-&gt;</span><span class="n">GetRootComponent</span><span class="p">());</span><span class="w"> </span><span class="c1">// Attach to actor&#39;s root</span>
<span class="w">    </span><span class="n">StaticComponent</span><span class="o">-&gt;</span><span class="n">RegisterComponent</span><span class="p">();</span>
<span class="w">    </span><span class="n">OwnerActor</span><span class="o">-&gt;</span><span class="n">AddInstanceComponent</span><span class="p">(</span><span class="n">StaticComponent</span><span class="p">);</span><span class="w"> </span><span class="c1">//without this, component wont show up in properties</span>
<span class="p">}</span>
</code></pre></div>
Давайте протестируем работу нашей функции, добавив ее вызов в BeginPlay.</p>
<p><a class="glightbox" href="../images/b783833c61b9283ad9698f46ba83516a.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b783833c61b9283ad9698f46ba83516a.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b783833c61b9283ad9698f46ba83516a.png" /></a></p>
<p>Если сейчас запустить игру, в нашем персонаже сгенерируется компонент с именем <code>CustomStaticComponent</code>.</p>
<p><a class="glightbox" href="../images/cd8b177aa0e5f183d0cc8db9f2076ec4.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="cd8b177aa0e5f183d0cc8db9f2076ec4.png" auto_="auto;" display="block;" margin:="margin:" src="../images/cd8b177aa0e5f183d0cc8db9f2076ec4.png" /></a></p>
<p>Правда пока он пуст.</p>
<p>Теперь зададим компоненту меш, который приведен в указателе <code>LoadedStaticMesh</code>, который, если вы помните, имеет тип <code>TSoftObjectPtr</code>.
<div class="highlight"><pre><span></span><code><span class="n">SpawnStaticMeshComponent</span><span class="p">();</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">StaticComponent</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">LoadedStaticMesh</span><span class="p">.</span><span class="n">IsNull</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">UStaticMesh</span><span class="o">&gt;</span><span class="w"> </span><span class="n">SMesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LoadedStaticMesh</span><span class="p">.</span><span class="n">LoadSynchronous</span><span class="p">();</span>
<span class="w">    </span><span class="n">StaticComponent</span><span class="o">-&gt;</span><span class="n">SetStaticMesh</span><span class="p">(</span><span class="n">SMesh</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div>
Тут я сделал загрузку меша "синхронной" используя метод <code>.LoadSynchronous();</code>. В нашем случае использование такого метода не вызовет никаких проблем, поскольку мы загружаем простой куб. Но если бы это был более объемный ассет, с миллионом полигонов, вероятно могли бы возникнуть сложности.</p>
<p>Проверим работает ли код.</p>
<p><a class="glightbox" href="../images/1f7c9e4c779c098f9572259c11c75c93.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1f7c9e4c779c098f9572259c11c75c93.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1f7c9e4c779c098f9572259c11c75c93.png" /></a></p>
<h2 id="skeletalmesh">Генерация SkeletalMesh компонента с копированием настроек</h2>
<p>Раз уж я затронул тему генерации компонентов из кода для <code>StaticMesh</code>, давайте рассмотрим и генерацию <code>SkeletalMesh</code>, вместе с дублированием настроек (есть и такая возможность). Unreal предоставляет довольно гибкий функционал для шаблона <code>NewObject</code>.
Сам компонент генерируется так:
<div class="highlight"><pre><span></span><code><span class="c1">// Spawn skeletal mesh component on owning character and copy parameters of character-&gt;mesh to it</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UPointersComponent::SpawnSkeletalMeshComponent</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OwnerActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetOwner</span><span class="p">();</span>
<span class="w">    </span><span class="n">FName</span><span class="w"> </span><span class="n">NewMeshCompName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;CustomSkeletalComponent&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">USkeletalMeshComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pNewSkeletalMeshComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NewObject</span><span class="o">&lt;</span><span class="n">USkeletalMeshComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">USkeletalMeshComponent</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">(),</span><span class="w"> </span><span class="n">NewMeshCompName</span><span class="p">,</span><span class="w"> </span><span class="n">RF_NoFlags</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">pNewSkeletalMeshComponent</span><span class="o">-&gt;</span><span class="n">SetupAttachment</span><span class="p">(</span><span class="n">OwnerActor</span><span class="o">-&gt;</span><span class="n">GetRootComponent</span><span class="p">());</span><span class="w"> </span><span class="c1">// Attach to actor&#39;s root</span>
<span class="w">    </span><span class="n">pNewSkeletalMeshComponent</span><span class="o">-&gt;</span><span class="n">RegisterComponent</span><span class="p">();</span>
<span class="w">    </span><span class="n">OwnerActor</span><span class="o">-&gt;</span><span class="n">AddInstanceComponent</span><span class="p">(</span><span class="n">pNewSkeletalMeshComponent</span><span class="p">);</span><span class="w"> </span><span class="c1">//without this, component wont show up in properties</span>
<span class="p">}</span>
</code></pre></div>
Если сейчас добавить вызов этой функции в BeginPlay и потом скомпилировать код то мы увидим следующее:</p>
<p><a class="glightbox" href="../images/2dd84846d10328e57bf18c9cc6c68e63.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="2dd84846d10328e57bf18c9cc6c68e63.png" auto_="auto;" display="block;" margin:="margin:" src="../images/2dd84846d10328e57bf18c9cc6c68e63.png" /></a></p>
<p>Компонент с именем <code>CustomSkeletalComponent</code> генерируется, однако он пуст.</p>
<p>Давайте копируем в этот компонент содержимое компонента Mesh нашего <code>BP_ThirdPresonCharacter'а</code>.
Вместе с материалами, настройками AnimGraph и прочим.</p>
<p><a class="glightbox" href="../images/a26f26abdf6ce10ad80513c1e0b7c748.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="a26f26abdf6ce10ad80513c1e0b7c748.png" auto_="auto;" display="block;" margin:="margin:" src="../images/a26f26abdf6ce10ad80513c1e0b7c748.png" /></a></p>
<p>Чтобы это провернуть нам надо для начала получить указатель на этот самый <code>Mesh</code>.
Для этого придется провести ряд приведений типов, через <code>Cast</code>.
<div class="highlight"><pre><span></span><code><span class="c1">// cast owner to character class</span>
<span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">ACharacter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OwningCharacter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">ACharacter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">OwnerActor</span><span class="p">);</span>
<span class="c1">// take refrence of character&#39;s Mesh component</span>
<span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">UObject</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FoundSkeletalMeshComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OwningCharacter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">FoundSkeletalMeshComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">UObject</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">OwningCharacter</span><span class="o">-&gt;</span><span class="n">GetMesh</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<blockquote>
<p>Мы не можем сделать <code>GetMesh()</code>, не приводя тип <code>AActor</code> к <code>ACharacter</code>.
Теперь мы можем скормить значение переменной <code>FoundSkeletalMeshComponent</code> в наш шаблон <code>NewObject</code>, в качестве параметра Template.</p>
</blockquote>
<p><a class="glightbox" href="../images/b6f318ed938e199b4ddb90e5f77a9998.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="b6f318ed938e199b4ddb90e5f77a9998.png" auto_="auto;" display="block;" margin:="margin:" src="../images/b6f318ed938e199b4ddb90e5f77a9998.png" /></a></p>
<p>Итоговый код будет таким:
<div class="highlight"><pre><span></span><code><span class="c1">// Spawn skeletal mesh component on owning character and copy parameters of character-&gt;mesh to it</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">UPointersComponent::SpawnSkeletalMeshComponent</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">AActor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OwnerActor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetOwner</span><span class="p">();</span>
<span class="w">    </span><span class="n">FName</span><span class="w"> </span><span class="n">NewMeshCompName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TEXT</span><span class="p">(</span><span class="s">&quot;CustomSkeletalComponent&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// cast owner to character class</span>
<span class="w">    </span><span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">ACharacter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">OwningCharacter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">ACharacter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">OwnerActor</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// copy properties of character&#39;s Skeletal Mesh component into new spawned component</span>
<span class="w">    </span><span class="c1">// take refrence of character&#39;s Mesh component</span>
<span class="w">    </span><span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">UObject</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FoundSkeletalMeshComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OwningCharacter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">FoundSkeletalMeshComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Cast</span><span class="o">&lt;</span><span class="n">UObject</span><span class="o">&gt;</span><span class="p">(</span><span class="w"> </span><span class="n">OwningCharacter</span><span class="o">-&gt;</span><span class="n">GetMesh</span><span class="p">()</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//take note of last argument here, it almost makes a perfect copy of FoundSkeletalMeshComponent, including scale and USkeletalMesh</span>
<span class="w">    </span><span class="n">TObjectPtr</span><span class="o">&lt;</span><span class="n">USkeletalMeshComponent</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pNewSkeletalMeshComponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NewObject</span><span class="o">&lt;</span><span class="n">USkeletalMeshComponent</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">USkeletalMeshComponent</span><span class="o">::</span><span class="n">StaticClass</span><span class="p">(),</span><span class="w"> </span><span class="n">NewMeshCompName</span><span class="p">,</span><span class="w"> </span><span class="n">RF_NoFlags</span><span class="p">,</span><span class="w"> </span><span class="n">FoundSkeletalMeshComponent</span><span class="p">.</span><span class="n">Get</span><span class="p">());</span>
<span class="w">    </span><span class="n">pNewSkeletalMeshComponent</span><span class="o">-&gt;</span><span class="n">SetupAttachment</span><span class="p">(</span><span class="n">OwnerActor</span><span class="o">-&gt;</span><span class="n">GetRootComponent</span><span class="p">());</span><span class="w"> </span><span class="c1">// Attach to actor&#39;s root</span>
<span class="w">    </span><span class="n">pNewSkeletalMeshComponent</span><span class="o">-&gt;</span><span class="n">RegisterComponent</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//pNewSkeletalMeshComponent-&gt;AttachToComponent(args) this will crash the game, and its redundant as RegisterComponent does an AttachToComponent using data from SetupAttachment!!!</span>
<span class="w">    </span><span class="n">OwnerActor</span><span class="o">-&gt;</span><span class="n">AddInstanceComponent</span><span class="p">(</span><span class="n">pNewSkeletalMeshComponent</span><span class="p">);</span><span class="w"> </span><span class="c1">//without this, component wont show up in properties</span>
<span class="p">}</span>
</code></pre></div>
И если все скомпилировать, а потом запустить, мы получим компонент <code>CustomSkeletalComponent</code>, который копирует все параметры компонента <code>Mesh</code>.</p>
<p><a class="glightbox" href="../images/1b899f94ddf58c16e01f6e27e4b16087.png" data-type="image" data-width="100%" data-height="auto" data-desc-position="bottom"><img 0="0" align="center;" alt="1b899f94ddf58c16e01f6e27e4b16087.png" auto_="auto;" display="block;" margin:="margin:" src="../images/1b899f94ddf58c16e01f6e27e4b16087.png" /></a></p>





                
              </article>
            </div>
          
          
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            К началу
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      aftamat4ik
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.top", "toc.follow"], "search": "../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "\u0421\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043e \u0432 \u0431\u0443\u0444\u0435\u0440", "clipboard.copy": "\u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0432 \u0431\u0443\u0444\u0435\u0440", "search.result.more.one": "\u0415\u0449\u0451 1 \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.more.other": "\u0415\u0449\u0451 # \u043d\u0430 \u044d\u0442\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435", "search.result.none": "\u0421\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e", "search.result.one": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e 1 \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0435", "search.result.other": "\u041d\u0430\u0439\u0434\u0435\u043d\u043e \u0441\u043e\u0432\u043f\u0430\u0434\u0435\u043d\u0438\u0439: #", "search.result.placeholder": "\u041d\u0430\u0447\u043d\u0438\u0442\u0435 \u043f\u0435\u0447\u0430\u0442\u0430\u0442\u044c \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430", "search.result.term.missing": "\u041e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442", "select.version": "\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u0432\u0435\u0440\u0441\u0438\u044e"}}</script>
    
    
      <script src="../assets/javascripts/bundle.dff1b7c8.min.js"></script>
      
    
  <script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>